// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-31 21:46:24.141427 +0800 WITA m=+0.018610501

package v8

import (
	"github.com/moontrade/dtc-go/message"
	"github.com/moontrade/log"
)

type Handler interface {
	// OnEncodingRequest Requirements: Not required for Servers. Required for Clients if the Client
	// needs to discover the encoding the Server uses.
	//
	// The EncodingRequest message is a message requesting to change the DTC
	// encoding for messages.
	//
	// For the procedure to work with this message, refer to Encoding Request
	// Sequence.
	OnEncodingRequest(msg EncodingRequest) error

	// OnEncodingRequestExtended Requirements: Not required for Servers. Required for Clients if the Client
	// needs to discover the encoding the Server uses.
	//
	// The EncodingRequest message is a message requesting to change the DTC
	// encoding for messages.
	//
	// For the procedure to work with this message, refer to Encoding Request
	// Sequence.
	OnEncodingRequestExtended(msg EncodingRequestExtended) error

	// OnEncodingResponse Requirements: Required for Servers. Required for Clients if the Client
	// needs to discover the encoding the Server uses.
	//
	// The EncodingResponse is a message from the Server to the Client, telling
	// the Client what message encoding it must use to communicate with the Server.
	// the Client what message encoding it must use to communicate with the Server.
	//
	// For the procedure to work with this message, refer to Encoding Request
	// Sequence.
	OnEncodingResponse(msg EncodingResponse) error

	// OnLogonRequest The LogonRequest message is sent from the Client to the Server requesting
	// to logon to the Server.
	//
	// This is the very first message the Client sends to the Server before being
	// allowed to send any other message other than the EncodingRequest.
	OnLogonRequest(msg LogonRequest) error

	// OnLogonResponse This is a response message indicating either success or an error logging
	// on to the Server.
	OnLogonResponse(msg LogonResponse) error

	// OnLogoff A Logoff is a message which can be sent either by the Client or the Server
	// to the other side. It indicates that the Client or the Server is logging
	// off and going to be closing the connection.
	//
	// When one side receives this message, it should expect the connection will
	// be closed. It should not be expected that any messages will follow the
	// Logoff message, and it should close the network connection and consider
	// it finished. The side receiving this message can send a Logoff message
	// to the other side before closing the connection.
	OnLogoff(msg Logoff) error

	// OnHeartbeat Both the Client and the Server need to send to the other side a heartbeat
	// at the interval specified by the HeartbeatIntervalInSeconds member in
	// the LogonRequest.
	//
	// There are no required member fields to set in this message. The purpose
	// of the Heartbeat message is so that the Client or the Server can determine
	// whether the other side is still connected.
	//
	// It is recommended that if there is a loss of Heartbeat messages from the
	// other side, for twice the amount of the HeartbeatIntervalInSeconds time
	// that it is safe to assume that the other side is no longer present and
	// the network socket should be then gracefully closed.
	//
	// The Server may choose to send a heartbeat message every second to the
	// Client. In this particular case, it is recommended the Client use a minimum
	// time of about 5 to 10 seconds without a heartbeat to determine the loss
	// of the connection rather than the standard of twice the amount of the
	// heartbeat time interval.
	OnHeartbeat(msg Heartbeat) error

	// OnHeartbeatExtended Both the Client and the Server need to send to the other side a heartbeat
	// at the interval specified by the HeartbeatIntervalInSeconds member in
	// the LogonRequest.
	//
	// There are no required member fields to set in this message. The purpose
	// of the Heartbeat message is so that the Client or the Server can determine
	// whether the other side is still connected.
	//
	// It is recommended that if there is a loss of Heartbeat messages from the
	// other side, for twice the amount of the HeartbeatIntervalInSeconds time
	// that it is safe to assume that the other side is no longer present and
	// the network socket should be then gracefully closed.
	//
	// The Server may choose to send a heartbeat message every second to the
	// Client. In this particular case, it is recommended the Client use a minimum
	// time of about 5 to 10 seconds without a heartbeat to determine the loss
	// of the connection rather than the standard of twice the amount of the
	// heartbeat time interval.
	OnHeartbeatExtended(msg HeartbeatExtended) error

	// OnMarketDataFeedStatus The s_MarketDataFeed_STATUS message is an optional message sent by the
	// Server to indicate the overall status of the market data feed. This status
	// applies to all symbols that have been subscribed to for market data.
	OnMarketDataFeedStatus(msg MarketDataFeedStatus) error

	OnMarketDataFeedSymbolStatus(msg MarketDataFeedSymbolStatus) error

	// OnTradingSymbolStatus Sent by the Server to the Client to indicate the status of the symbol
	// in regards to whether trading is open or closed or some other intermediate
	// state.
	OnTradingSymbolStatus(msg TradingSymbolStatus) error

	// OnMarketDataRequest The MarketDataRequest message will subscribe to market data for a particular
	// Symbol or request a market data snapshot.
	//
	// The Server can also send market depth data in response to this message
	// and not require a MarketDepthRequest.
	OnMarketDataRequest(msg MarketDataRequest) error

	OnMarketDepthRequest(msg MarketDepthRequest) error

	// OnMarketDataReject The MarketDataReject message is sent by the Server to the Client to reject
	// a MarketDataRequest message for any reason.
	OnMarketDataReject(msg MarketDataReject) error

	// OnMarketDataSnapshot The Server sends the MarketDataSnapshot message to the Client immediately
	// after a successful MarketDataRequest message has been received from the
	// Client and it has indicated to subscribe to the symbol or requested the
	// snapshot of data.
	//
	// Any changes to the data fields within the MarketDataSnapshot message during
	// the trading session will be sent by the Server to the Client through the
	// corresponding MARKET_DATA_UPDATE_* messages.
	//
	// It is recommended that the MarketDataSnapshot be sent by the Server at
	// the start of a new trading session.
	//
	// This message can be sent more often, however it is not intended to be
	// sent frequently.
	//
	// This message type does not signify a trade has occurred. It should never
	// be interpreted by the Client in that way.
	//
	// There is no need to send this when there is a new High or Low during the
	// trading session. The Server should use the MarketDataUpdateSessionHigh
	// or MarketDataUpdateSessionLow messages instead.
	OnMarketDataSnapshot(msg MarketDataSnapshot) error

	// OnMarketDepthSnapshotLevel This is a message sent by Server to provide the initial market depth data
	// entries to the Client after the Client subscribes to market data or separately
	// subscribes to market depth data. The Client will need to separately subscribe
	// to market depth data if the Server requires it.
	//
	// Each message provides a single entry of depth data. Therefore, the Server
	// will send multiple MarketDepthSnapshotLevel messages in a series in order
	// for the Client to build up its initial market depth book.
	//
	// The first message will be identified by the IsFirstMessageInBatch field
	// being set to 1. The last message will be identified by the IsLastMessageInBatch
	// field being set to 1.
	//
	// In the case where the market depth book is empty, the Server still needs
	// to send through one single message with the SymbolID set, IsFirstMessageInBatch
	// equal to 1 and IsLastMessageInBatch equal to 1. All other members will
	// be at the default values. The Client will understand this as an empty
	// book.
	OnMarketDepthSnapshotLevel(msg MarketDepthSnapshotLevel) error

	// OnMarketDepthSnapshotLevelFloat This is a message sent by Server to provide the initial market depth data
	// entries to the Client after the Client subscribes to market data or separately
	// subscribes to market depth data. The Client will need to separately subscribe
	// to market depth data if the Server requires it.
	//
	// Each message provides a single entry of depth data. Therefore, the Server
	// will send multiple MarketDepthSnapshotLevelFloat messages in a series
	// in order for the Client to build up its initial market depth book.
	//
	// The first message will be identified by the IsFirstMessageInBatch field
	// being set to 1. The last message will be identified by the IsLastMessageInBatch
	// field being set to 1.
	//
	// In the case where the market depth book is empty, the Server still needs
	// to send through one single message with the SymbolID set, IsFirstMessageInBatch
	// equal to 1 and IsLastMessageInBatch equal to 1. All other members will
	// be at the default values. The Client will understand this as an empty
	// book.
	OnMarketDepthSnapshotLevelFloat(msg MarketDepthSnapshotLevelFloat) error

	// OnMarketDepthUpdateLevel Sent by the Server to the Client to Update/Insert or Delete a particular
	// market depth price level in the market depth book maintained by the Client.
	// market depth price level in the market depth book maintained by the Client.
	//
	// Each MarketDepthUpdateLevel message updates one level of market depth
	// on one side. An insert/update/delete model is used for market depth.
	//
	// The Client will need to determine the based upon the price, what particular
	// market depth level is being updated, inserted or deleted.
	//
	// It is for this reason, that an insert/update is considered as one update
	// type since it is possible to determine whether it is an insert or update
	// based upon the existence of the price level in the existing market depth
	// book on the Client side.
	//
	// What this means is that when the UpdateType field is MARKET_DEPTH_INSERT_UPDATE_LEVEL,
	// it is considered an insert if the price level is not found on the particular
	// side of the market depth being updated. It is considered an update, if
	// the price level is found on the particular side of market depth being
	// updated.
	//
	// This message uses a double datatype for the Price field. There is no level
	// index. It is the responsibility of the Client to determine where in its
	// market depth array it is maintaining where the insert/update/delete operation
	// needs to occur.
	//
	// Since floating-point comparisons are not always precise, there should
	// be a comparison made only to the number of decimal places the symbol specifies
	// in its security definition. This can be determined through the SecurityDefinitionResponse::PriceDisplayFormat
	// field.
	OnMarketDepthUpdateLevel(msg MarketDepthUpdateLevel) error

	// OnMarketDepthUpdateLevelFloatWithMilliseconds Sent by the Server to the Client to Update/Insert or Delete a particular
	// market depth price level in the market depth book maintained by the Client.
	// market depth price level in the market depth book maintained by the Client.
	//
	// This message is a more compact version of the MarketDepthUpdateLevel message.
	// For the Price and Quantity fields, it uses a 4 byte float for compactness.
	// It also supports millisecond precision for the timestamp.
	OnMarketDepthUpdateLevelFloatWithMilliseconds(msg MarketDepthUpdateLevelFloatWithMilliseconds) error

	// OnMarketDepthUpdateLevelNoTimestamp Sent by the Server to the Client to Update/Insert or Delete a particular
	// market depth price level in the market depth book maintained by the Client.
	// market depth price level in the market depth book maintained by the Client.
	//
	// This message is identical to the MarketDepthUpdateLevel message except
	// it has no timestamp field. It needs to be sent when there is no change
	// with the timestamp for the market depth update as compared to the prior
	// update.
	//
	// When the Server sends this message to the Client, the Client needs to
	// use the prior received market depth update timestamp to know what the
	// timestamp is for this message.
	OnMarketDepthUpdateLevelNoTimestamp(msg MarketDepthUpdateLevelNoTimestamp) error

	// OnMarketDataUpdateTradeNoTimestamp This message is optional.
	//
	// Sent by the Server to the Client when a trade occurs. This message is
	// identical to the MarketDataUpdateTrade_WITH_UNBUNDLED_INDICATOR_2 message
	// except it does not have a timestamp. It needs to be sent when there is
	// no change with the timestamp for the trade as compared to the prior trade.
	// no change with the timestamp for the trade as compared to the prior trade.
	//
	// When the Server sends this message to the Client, the Client needs to
	// use the prior received trade timestamp to know what the timestamp is for
	// this message.
	OnMarketDataUpdateTradeNoTimestamp(msg MarketDataUpdateTradeNoTimestamp) error

	// OnMarketDataUpdateSessionSettlement Sent by the Server to the Client to update the session settlement price
	// when the session settlement price changes.
	OnMarketDataUpdateSessionSettlement(msg MarketDataUpdateSessionSettlement) error

	// OnMarketDataUpdateSessionOpen Sent by the Server to the Client to update the session Open.
	OnMarketDataUpdateSessionOpen(msg MarketDataUpdateSessionOpen) error

	// OnMarketDataUpdateSessionNumTrades Sent by the Server to the Client to update the trading session number
	// of trades.
	OnMarketDataUpdateSessionNumTrades(msg MarketDataUpdateSessionNumTrades) error

	// OnMarketDataUpdateTradingSessionDate Sent by the Server to the Client to update the trading session Date.
	OnMarketDataUpdateTradingSessionDate(msg MarketDataUpdateTradingSessionDate) error

	// OnMarketDepthReject The MarketDepthReject message is sent by the Server to the Client to reject
	// a MarketDepthRequest message for any reason.
	OnMarketDepthReject(msg MarketDepthReject) error

	// OnMarketDataUpdateTrade The Server sends this market data feed message to the Client when a trade
	// occurs.
	OnMarketDataUpdateTrade(msg MarketDataUpdateTrade) error

	OnMarketDataUpdateTradeWithUnbundledIndicator(msg MarketDataUpdateTradeWithUnbundledIndicator) error

	// OnMarketDataUpdateTradeWithUnbundledIndicator2 Sent by the Server to the Client when a trade occurs. This message has
	// additional fields as compared to the MarketDataUpdateTrade message and
	// also supports microsecond time stamping.
	OnMarketDataUpdateTradeWithUnbundledIndicator2(msg MarketDataUpdateTradeWithUnbundledIndicator2) error

	// OnMarketDataUpdateBidAsk The Server sends this market data feed message to the Client when the
	// best bid or ask price or size changes.
	OnMarketDataUpdateBidAsk(msg MarketDataUpdateBidAsk) error

	OnMarketDataUpdateBidAskCompact(msg MarketDataUpdateBidAskCompact) error

	// OnMarketDataUpdateBidAskFloatWithMicroseconds This message is optional.
	//
	// Sent by the Server to the Client when there is an update to the Bid Ask
	// prices and/or quantities. This message is identical to the MarketDataUpdateBidAsk
	// message except it does not have a timestamp. It needs to be sent when
	// there is no change with the timestamp for the Bid Ask update as compared
	// to the prior update.
	//
	// When the Server sends this message to the Client, the Client needs to
	// use the prior received Bid Ask update timestamp to know what the timestamp
	// is for this message.
	OnMarketDataUpdateBidAskFloatWithMicroseconds(msg MarketDataUpdateBidAskFloatWithMicroseconds) error

	// OnMarketDataUpdateBidAskNoTimeStamp This message is optional.
	//
	// Sent by the Server to the Client when there is an update to the Bid Ask
	// prices and/or quantities. This message is identical to the MarketDataUpdateBidAsk
	// message except it does not have a timestamp. It needs to be sent when
	// there is no change with the timestamp for the Bid Ask update as compared
	// to the prior update.
	//
	// When the Server sends this message to the Client, the Client needs to
	// use the prior received Bid Ask update timestamp to know what the timestamp
	// is for this message.
	OnMarketDataUpdateBidAskNoTimeStamp(msg MarketDataUpdateBidAskNoTimeStamp) error

	// OnMarketDataUpdateTradeCompact Sent by the Server to the Client when a trade occurs. This message is
	// a more compact MarketDataUpdateTrade. For the price it uses a 4 byte float.
	// a more compact MarketDataUpdateTrade. For the price it uses a 4 byte float.
	OnMarketDataUpdateTradeCompact(msg MarketDataUpdateTradeCompact) error

	// OnMarketDataUpdateSessionVolume Sent by the Server to the Client when the session trade Volume needs to
	// be updated.
	//
	// The recommended rule for the Server to notify the Client of a change with
	// the session trade volume to maintain bandwidth efficiency, is as follows:
	// When a trade occurs for a symbol subscribed to, the Server will send a
	// MarketDataUpdateTrade message to the Client. The Client should then increment
	// its session trade volume value for the symbol by the value in the Volume
	// field in this message.
	//
	// The Server will assume the Client is doing this. Therefore, when a trade
	// occurs and the session trade volume does not equal the prior session trade
	// volume plus the Volume for the most recent trade sent to the Client, then
	// the Server must send out a MarketDataUpdateSessionVolume message to the
	// client since the client calculation of the session trade volume is no
	// longer correct.
	//
	// It is assumed that the reason for this inconsistency is due to trades
	// included within the session trade volume which have not been sent out
	// as normal trades.
	//
	// The Server should also send this message out at the frequency that the
	// Server determines, such as every minute if there also has been a trade
	// at that time.
	OnMarketDataUpdateSessionVolume(msg MarketDataUpdateSessionVolume) error

	// OnMarketDataUpdateOpenInterest The MarketDataUpdateOpenInterest message is sent by the Server to the
	// Client to update the OpenInterest field previously sent through the MarketDataSnapshot
	// message.
	OnMarketDataUpdateOpenInterest(msg MarketDataUpdateOpenInterest) error

	// OnMarketDataUpdateSessionHigh Sent by the Server to the Client to update the session High as the High
	// price changes throughout the session.
	OnMarketDataUpdateSessionHigh(msg MarketDataUpdateSessionHigh) error

	// OnMarketDataUpdateSessionLow Sent by the Server to the Client to update the session Low as the Low
	// price changes throughout the session.
	OnMarketDataUpdateSessionLow(msg MarketDataUpdateSessionLow) error

	// OnMarketDataUpdateLastTradeSnapshot Sent by the Server to the Client to update the last trade price, volume
	// and date-time fields under conditions when there is not a trade.
	//
	// This message type does not signify a trade has occurred. It should never
	// be interpreted by the Client in that way.
	OnMarketDataUpdateLastTradeSnapshot(msg MarketDataUpdateLastTradeSnapshot) error

	OnMarketOrdersRequest(msg MarketOrdersRequest) error

	OnMarketOrdersReject(msg MarketOrdersReject) error

	OnMarketOrdersAdd(msg MarketOrdersAdd) error

	OnMarketOrdersModify(msg MarketOrdersModify) error

	OnMarketOrdersRemove(msg MarketOrdersRemove) error

	OnMarketOrdersSnapshotMessageBoundary(msg MarketOrdersSnapshotMessageBoundary) error

	// OnSubmitNewSingleOrder This message is used to submit a new single order into the market from
	// the Client to the Server.
	OnSubmitNewSingleOrder(msg SubmitNewSingleOrder) error

	OnSubmitFlattenPositionOrder(msg SubmitFlattenPositionOrder) error

	// OnCancelReplaceOrder This message is sent by the Client to the Server to cancel and replace
	// an existing order. This is also known as an order modification.
	//
	// When the cancel and replace operation is completed, an OrderUpdate message
	// is sent by the Server with the OrderUpdateReasonfield set to ORDER_CANCEL_REPLACE_COMPLETE.
	// If the cancel and replace operation cannot be completed, an OrderUpdate
	// message is sent by the Server with the OrderUpdateReason set to ORDER_CANCEL_REPLACE_REJECTED.
	// message is sent by the Server with the OrderUpdateReason set to ORDER_CANCEL_REPLACE_REJECTED.
	OnCancelReplaceOrder(msg CancelReplaceOrder) error

	// OnCancelOrder This is a message from the Client to the Server requesting a previously
	// sent order to be canceled.
	OnCancelOrder(msg CancelOrder) error

	// OnSubmitNewOCOOrder This is a message from the Client to the Server for submitting an order
	// cancels order (OCO) pair into the market. What this means is when one
	// of the orders is filled or canceled, the other order will be canceled.
	// If one order partially fills, the other order will be reduced in quantity
	// by the fill amount of the order that partially filled.
	//
	// A service provider must implement OCO orders on the server so that they
	// can independently be modified (Cancel/Replace) and canceled independently
	// using each order's distinct ServerOrderID. Although, if one of the orders
	// is canceled by the Client, the other order will be canceled as well unless
	// they have a parent order, as specified through the ParentTriggerClientOrderID
	// field, in which case the other order should remain open.
	//
	// If the OCO order pair is rejected, this must be communicated through two
	// separate OrderUpdate messages, 1 for each order, with the OrderUpdateReason
	// set to NEW_ORDER_REJECTED.
	OnSubmitNewOCOOrder(msg SubmitNewOCOOrder) error

	// OnOpenOrdersRequest This is a message from the Client to the Server requesting the currently
	// open orders.
	//
	// The Server will send open/working orders in response to this request through
	// OrderUpdate messages.
	//
	// The Server will not return canceled or filled orders.
	//
	// When the Server responds to this request, it needs to respond with a separate
	// OrderUpdate for each order.
	//
	// When the Server responds to this request, OrderUpdateReason in the OrderUpdate
	// message must be set to OpenOrdersRequest_RESPONSE indicating the orders
	// are being restated.
	//
	// If there are no Open orders, the Server will send back 1 OrderUpdate message
	// with only the TotalNumberMessages, MessageNumber, RequestID, OrderUpdateReason,
	// NoOrders = 1 fields set in the OrderUpdate message.
	OnOpenOrdersRequest(msg OpenOrdersRequest) error

	// OnHistoricalOrderFillsRequest This is a message from the Client to the Server to request order fills/executions
	// for an order or orders.
	OnHistoricalOrderFillsRequest(msg HistoricalOrderFillsRequest) error

	// OnHistoricalOrderFillsReject If the Server is unable to serve the request for a HistoricalOrderFillsRequest
	// message received, for a reason other than there not being any historical
	// order fills, then send this message to the Client.
	OnHistoricalOrderFillsReject(msg HistoricalOrderFillsReject) error

	// OnCurrentPositionsRequest This is a message from the Client to the Server to request the current
	// open Trade Positions.
	OnCurrentPositionsRequest(msg CurrentPositionsRequest) error

	// OnCurrentPositionsReject If the Server is unable to serve the request for an CurrentPositionsRequest
	// message received, for a reason other than there not being any current
	// Trade positions, then send this message to the Client.
	//
	// This must never be sent when there are actually no Trade Positions in
	// the account or accounts requested.
	OnCurrentPositionsReject(msg CurrentPositionsReject) error

	// OnOrderUpdate The OrderUpdate is a unified message from the Server to the Client which
	// communicates the complete details of an order, the Order Status, and the
	// reason for sending the message (OrderUpdateReason).
	//
	// DTC uses this single unified message to provide an update for an order.
	// The OrderUpdateReason field provides a clear indication for each reason
	// this message is being sent.
	OnOrderUpdate(msg OrderUpdate) error

	// OnOpenOrdersReject If the Server is unable to serve the request for an OpenOrdersRequest
	// message received, for a reason other than there not being any open orders,
	// then send this message to the Client.
	OnOpenOrdersReject(msg OpenOrdersReject) error

	// OnHistoricalOrderFillResponse This is a message from the Server to the Client providing an individual
	// historical order fill in response to a HistoricalOrderFillsRequest message.
	// historical order fill in response to a HistoricalOrderFillsRequest message.
	//
	// The Server is expected to send this message to the Client in response
	// to a HistoricalOrderFillsRequest message even when there are no order
	// fills to return. If there are no order fills to return, it needs to set
	// the NoOrderFills field to 1.
	OnHistoricalOrderFillResponse(msg HistoricalOrderFillResponse) error

	// OnPositionUpdate This is a message from the Server to the Client to report a Trade Position
	// for a symbol in any Trade Account for the logged in Username.
	//
	// The Position Update message can either be solicited, in response to CurrentPositionsRequest.
	// Or unsolicited as a Trade Position for a symbol changes during the connection
	// to the Server. Each Trade Position is contained within a single message.
	// to the Server. Each Trade Position is contained within a single message.
	//
	// When the server is responding with one or more PositionUpdate messages
	// in response to a CurrentPositionsRequest message, it must not send any
	// unsolicited PositionUpdate messages interleaved with the solicited PositionUpdate
	// messages in response to the CurrentPositionsRequest message.
	OnPositionUpdate(msg PositionUpdate) error

	OnAddCorrectingOrderFill(msg AddCorrectingOrderFill) error

	OnCorrectingOrderFillResponse(msg CorrectingOrderFillResponse) error

	// OnTradeAccountsRequest This is a message from the Client to the Server to request all of the
	// account identifiers for the logged in Username.
	//
	// If there are no accounts available, then the Server needs to respond with
	// at least one TradeAccountResponse message containing an empty Trade Account.
	// at least one TradeAccountResponse message containing an empty Trade Account.
	OnTradeAccountsRequest(msg TradeAccountsRequest) error

	// OnTradeAccountResponse This is a message from the Server to the Client in response to a TradeAccountsRequest
	// message, providing a single trade account. There is one message for each
	// trade account.
	OnTradeAccountResponse(msg TradeAccountResponse) error

	// OnExchangeListRequest This is a message from the Client to the Server to request a list of all
	// available exchanges from the Server.
	//
	// The server will respond with a separate ExchangeListResponse message for
	// each exchange.
	//
	// In the case where the Server does not specify an exchange with its symbols,
	// then the Server should provide a single response with an empty Exchange.
	// then the Server should provide a single response with an empty Exchange.
	OnExchangeListRequest(msg ExchangeListRequest) error

	// OnExchangeListResponse The server will return this message for each supported exchange.
	//
	// If there are no exchanges to return in response to a request, send through
	// one of these messages with the RequestID set and IsFinalMessage = 1. Leave
	// all other members in the default state and the Client will recognize there
	// are no Exchanges.
	OnExchangeListResponse(msg ExchangeListResponse) error

	// OnSymbolsForExchangeRequest This is a message from the Client to the Server to request all of the
	// Symbols for a particular Exchange.
	//
	// The server will return a SecurityDefinitionResponse message to the Client
	// for each Symbol returned.
	//
	// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
	// message to the Client.
	OnSymbolsForExchangeRequest(msg SymbolsForExchangeRequest) error

	// OnUnderlyingSymbolsForExchangeRequest This is a message from the Client to the Server to request all of the
	// underlying symbols on a particular Exchange. For example, all of the underlying
	// futures symbols on a particular Exchange.
	//
	// The server will return a SecurityDefinitionResponse message to the Client
	// for each Symbol returned.
	//
	// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
	// message to the Client.
	OnUnderlyingSymbolsForExchangeRequest(msg UnderlyingSymbolsForExchangeRequest) error

	// OnSymbolsForUnderlyingRequest This is a message from the Client to the Server for requesting all of
	// the symbols for a particular underlying symbol.
	//
	// For example, all of the futures contracts for a particular underlying
	// futures symbol or all of the option symbols for a specific futures or
	// stock symbol.
	//
	// The server will return a SecurityDefinitionResponse message to the Client
	// for each Symbol returned.
	//
	// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
	// message to the Client.
	OnSymbolsForUnderlyingRequest(msg SymbolsForUnderlyingRequest) error

	// OnSymbolSearchRequest The SymbolSearchRequest message is sent by the Client to the Server to
	// return Security Definitions matching the specified SecurityType and Exchange
	// and where the Symbol or Description contains the specified SearchText.
	//
	// The SearchText can search either the Symbol or the Description field in
	// the SecurityDefinitionResponse message.
	//
	// In either case there does not need to be an exact match. The SearchText
	// only needs to be contained within the Symbol or the Description depending
	// upon which field is being searched.
	//
	// The Server returns SecurityDefinitionResponse messages for all Symbols
	// which match.
	//
	// If there are no matches, the Server needs to send a SecurityDefinitionResponse
	// message to the Client with with all fields at their default values except
	// for the RequestID and IsFinalMessage fields set. This will be a clear
	// indication to the Client that the request returned no matches.
	//
	// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
	// message to the Client.
	OnSymbolSearchRequest(msg SymbolSearchRequest) error

	// OnSecurityDefinitionForSymbolRequest This is a message from the Client to the Server for requesting Security
	// Definition data for a specific symbol.
	//
	// The Server will return a single SecurityDefinitionResponse message in
	// response to this request.
	//
	// The Client must always send a SecurityDefinitionForSymbolRequest message
	// to the Server in order to obtain the IntegerToFloatPriceDivisor value
	// in case the Server uses the integer market data messages.
	//
	// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
	// message to the Client.
	OnSecurityDefinitionForSymbolRequest(msg SecurityDefinitionForSymbolRequest) error

	// OnSecurityDefinitionResponse This is a response from the Server in response to a SymbolsForExchangeRequest,
	// UNDERLYING_SymbolsForExchangeRequest, SymbolsForUnderlyingRequest, SecurityDefinitionForSymbolRequest,
	// SymbolSearchRequest message.
	//
	// If there are no symbols to return in response to a request, the Server
	// needs to send through one of these messages with the RequestID set to
	// the same RequestID value that the request message set it to, and IsFinalMessage
	// = 1. Leave all other member fields in the default state and the Client
	// will recognize there are no symbols.
	//
	// The Client must always send a SecurityDefinitionForSymbolRequest message
	// to the Server to obtain the IntegerToFloatPriceDivisor and FloatToIntPriceMultiplier
	// values in the Security Definition Response message when the Server uses
	// the integer market data and order messages.
	OnSecurityDefinitionResponse(msg SecurityDefinitionResponse) error

	// OnSecurityDefinitionReject This is a message from the Server to the Client indicating the Server
	// is rejecting one of the following messages: SymbolsForExchangeRequest,
	// UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest, SecurityDefinitionForSymbolRequest,
	// SymbolSearchRequest.
	//
	// If there are no symbols to send in response to one of these messages above,
	// then the Server should not send a SecurityDefinitionReject message and
	// instead send a SecurityDefinitionResponse with only the RequestID and
	// IsFinalMessage fields set. This will be a clear indication to the Client
	// that the request returned no Symbols.
	OnSecurityDefinitionReject(msg SecurityDefinitionReject) error

	// OnAccountBalanceRequest This is a message from the Client to the Server to request Trade Account
	// Balance data.
	//
	// The Server will respond with an AccountBalanceUpdate or reject the request.
	// The Server will respond with an AccountBalanceUpdate or reject the request.
	//
	// The Server will set the RequestID in the AccountBalanceUpdate message
	// to match the RequestID in the AccountBalanceRequest.
	//
	// The Server will periodically send AccountBalanceUpdate messages as the
	// Account Balance data changes. The frequency of the updates is determined
	// by the Server. Account Balance updates are considered automatically subscribed
	// to. When unsolicited AccountBalanceUpdate messages are sent by the Server,
	// the RequestID will be 0.
	OnAccountBalanceRequest(msg AccountBalanceRequest) error

	OnAccountBalanceReject(msg AccountBalanceReject) error

	// OnAccountBalanceUpdate This is an optional message from the Server to Client to provide Account
	// Balance information for a particular Trade Account. The server needs to
	// provide a separate message for each Trade Account associated with the
	// logged in username if it supports Account Balance updates.
	//
	// The Server will respond with an AccountBalanceUpdate in response to a
	// AccountBalanceRequest message. The Server will set the RequestID in the
	// AccountBalanceUpdate message to match the RequestID in the AccountBalanceRequest
	// message.
	//
	// The Server will periodically send AccountBalanceUpdate messages as the
	// Account Balance data changes. The frequency of the updates is determined
	// by the Server. Account Balance updates are considered automatically subscribed
	// to. When an unsolicited AccountBalanceUpdate message is sent, the RequestID
	// field will be 0.
	//
	// When the server is responding with one or more AccountBalanceUpdate messages
	// in response to a AccountBalanceRequest message, it must not send any unsolicited
	// AccountBalanceUpdate messages interleaved with the solicited AccountBalanceUpdate
	// messages in response to the AccountBalanceRequest message.
	OnAccountBalanceUpdate(msg AccountBalanceUpdate) error

	OnAccountBalanceAdjustment(msg AccountBalanceAdjustment) error

	OnAccountBalanceAdjustmentReject(msg AccountBalanceAdjustmentReject) error

	OnAccountBalanceAdjustmentComplete(msg AccountBalanceAdjustmentComplete) error

	// OnHistoricalAccountBalancesRequest This is a message from the Client to the Server to request a history of
	// Cash Balance changes for the specified Trade Account.
	//
	// The Server will respond with multiple HISTORICAL_ACCOUNT_BALANCE_RESPONSE
	// messages or reject he request with a message.
	//
	// The Server will set the RequestID in the HISTORICAL_ACCOUNT_BALANCE_RESPONSE
	// message to match the RequestID in the HistoricalAccountBalancesRequest.
	// message to match the RequestID in the HistoricalAccountBalancesRequest.
	OnHistoricalAccountBalancesRequest(msg HistoricalAccountBalancesRequest) error

	// OnHistoricalAccountBalancesReject This is a message from the Server to the Client to reject a HistoricalAccountBalancesRequest
	// request.
	OnHistoricalAccountBalancesReject(msg HistoricalAccountBalancesReject) error

	OnHistoricalAccountBalanceResponse(msg HistoricalAccountBalanceResponse) error

	// OnUserMessage This message from the Server to the Client is for providing a message
	// to the user.
	//
	// This message can be sent even before a LogonResponse.
	OnUserMessage(msg UserMessage) error

	// OnGeneralLogMessage This message from the Server to the Client is a message which is to be
	// added to a log file indicating information from the server. For example,
	// if there are informational messages to provide during the process of a
	// logon, this can be used to send those messages to a Client. A Client should
	// never implement this message as a pop-up type message. Instead, it should
	// be treated as a lower-level log type message.
	//
	// This message can be sent even before a LogonResponse is given.
	OnGeneralLogMessage(msg GeneralLogMessage) error

	OnAlertMessage(msg AlertMessage) error

	OnJournalEntryAdd(msg JournalEntryAdd) error

	OnJournalEntriesRequest(msg JournalEntriesRequest) error

	OnJournalEntriesReject(msg JournalEntriesReject) error

	OnJournalEntryResponse(msg JournalEntryResponse) error

	// OnHistoricalPriceDataRequest This is a message from the Client to the Server for requesting historical
	// price data.
	//
	// This request can be on the same or a separate network socket connection
	// compared to the streaming market data. This is going to be specified by
	// the Server.
	OnHistoricalPriceDataRequest(msg HistoricalPriceDataRequest) error

	// OnHistoricalPriceDataResponseHeader When a historical price data request is not rejected, this message header
	// will begin the historical price data response from the Server. There will
	// be one HistoricalPriceDataResponseHeader message sent ahead of the HistoricalPriceDataRecordResponse
	// / HistoricalPriceDataTickRecordResponse messages. If the NoRecordsToReturn
	// field is nonzero, then there are no further records that will be sent
	// by the Server in response to the request by the Client.
	//
	// This message is never compressed.
	OnHistoricalPriceDataResponseHeader(msg HistoricalPriceDataResponseHeader) error

	// OnHistoricalPriceDataReject When the Server rejects a historical price data request from the Client,
	// a HistoricalPriceDataReject message will be sent.
	//
	// This message is never compressed.
	OnHistoricalPriceDataReject(msg HistoricalPriceDataReject) error

	// OnHistoricalPriceDataRecordResponse The HistoricalPriceDataTickRecordResponse message is used when the RecordInterval
	// field in a historical data request message is set to a value greater than
	// INTERVAL_TICK. For example, if the RecordInterval is INTERVAL_1_MINUTE,
	// then a message of this type will contain data for a 1 minute timeframe
	// with a start time specified by the StartDateTime field.
	//
	// Even when RecordInterval is INTERVAL_TICK, the HistoricalPriceDataTickRecordResponse
	// message can still be used instead of HistoricalPriceDataTickRecordResponse.
	// message can still be used instead of HistoricalPriceDataTickRecordResponse.
	//
	// This message can be part of a compressed series of messages of this same
	// type, if the Client requested compression be used.
	OnHistoricalPriceDataRecordResponse(msg HistoricalPriceDataRecordResponse) error

	// OnHistoricalPriceDataTickRecordResponse This is the response message when the RecordInterval field in a historical
	// data request message is set to INTERVAL_TICK.
	//
	// If the Server does not support 1 Tick historical data or does not have
	// 1 Tick historical data for the specified time period, it can respond with
	// HistoricalPriceDataRecordResponse messages instead. The Server must only
	// respond with messages of one type in response to a particular historical
	// price data request.
	//
	// This message can be part of a compressed series of messages of this same
	// type, if the Client requested compression be used.
	OnHistoricalPriceDataTickRecordResponse(msg HistoricalPriceDataTickRecordResponse) error

	OnHistoricalPriceDataResponseTrailer(msg HistoricalPriceDataResponseTrailer) error

	OnHistoricalMarketDepthDataRequest(msg HistoricalMarketDepthDataRequest) error

	OnHistoricalMarketDepthDataResponseHeader(msg HistoricalMarketDepthDataResponseHeader) error

	OnHistoricalMarketDepthDataReject(msg HistoricalMarketDepthDataReject) error

	OnHistoricalMarketDepthDataRecordResponse(msg HistoricalMarketDepthDataRecordResponse) error

	OnHistoricalTradesRequest(msg HistoricalTradesRequest) error

	OnHistoricalTradesReject(msg HistoricalTradesReject) error

	OnHistoricalTradesResponse(msg HistoricalTradesResponse) error

	OnReplayChartData(msg ReplayChartData) error

	OnReplayChartDataPerformAction(msg ReplayChartDataPerformAction) error

	OnReplayChartDataStatus(msg ReplayChartDataStatus) error

	OnRequestNumCurrentClientConnections(msg RequestNumCurrentClientConnections) error

	OnNumCurrentClientConnectionsResponse(msg NumCurrentClientConnectionsResponse) error

	OnClientDeviceUpdate(msg ClientDeviceUpdate) error

	OnInterprocessSynchronizationRemoteState(msg InterprocessSynchronizationRemoteState) error

	OnInterprocessSynchronizationSnapshotRequest(msg InterprocessSynchronizationSnapshotRequest) error

	OnInterprocessSynchronizationTradeActivityRequest(msg InterprocessSynchronizationTradeActivityRequest) error

	OnWriteIntradayDataFileSessionValue(msg WriteIntradayDataFileSessionValue) error

	OnSCConfigurationSynchronization(msg SCConfigurationSynchronization) error

	OnDownloadHistoricalOrderFillAndAccountBalanceData(msg DownloadHistoricalOrderFillAndAccountBalanceData) error

	OnTradeOrder(msg TradeOrder) error

	OnIndividualTradePosition(msg IndividualTradePosition) error

	OnTradePositionConsolidated(msg TradePositionConsolidated) error

	OnTradeActivityData(msg TradeActivityData) error

	OnTradeAccountDataRequest(msg TradeAccountDataRequest) error

	OnTradeAccountDataResponse(msg TradeAccountDataResponse) error

	OnTradeAccountDataUpdate(msg TradeAccountDataUpdate) error

	OnTradeAccountDataDelete(msg TradeAccountDataDelete) error

	OnTradeAccountDataSymbolLimitsResponse(msg TradeAccountDataSymbolLimitsResponse) error

	OnTradeAccountDataSymbolLimitsUpdate(msg TradeAccountDataSymbolLimitsUpdate) error

	OnTradeAccountDataSymbolCommissionResponse(msg TradeAccountDataSymbolCommissionResponse) error

	OnTradeAccountDataSymbolCommissionUpdate(msg TradeAccountDataSymbolCommissionUpdate) error

	OnTradeAccountDataAuthorizedUsernameResponse(msg TradeAccountDataAuthorizedUsernameResponse) error

	OnTradeAccountDataAuthorizedUsernameAdd(msg TradeAccountDataAuthorizedUsernameAdd) error

	OnTradeAccountDataAuthorizedUsernameRemove(msg TradeAccountDataAuthorizedUsernameRemove) error

	OnTradeAccountDataUsernameToShareWithResponse(msg TradeAccountDataUsernameToShareWithResponse) error

	OnTradeAccountDataUsernameToShareWithAdd(msg TradeAccountDataUsernameToShareWithAdd) error

	OnTradeAccountDataUsernameToShareWithRemove(msg TradeAccountDataUsernameToShareWithRemove) error

	OnTradeAccountDataResponseTrailer(msg TradeAccountDataResponseTrailer) error

	OnTradeAccountDataUpdateOperationComplete(msg TradeAccountDataUpdateOperationComplete) error

	OnProcessedFillIdentifier(msg ProcessedFillIdentifier) error

	OnFlattenPositionsForTradeAccount(msg FlattenPositionsForTradeAccount) error

	OnUserInformation(msg UserInformation) error

	OnMarginDataRequest(msg MarginDataRequest) error

	OnMarginDataResponse(msg MarginDataResponse) error

	OnUnknown(b []byte, t uint16) error

	OnError(b []byte, t uint16, err error)
}

type Stub struct{}

// OnEncodingRequest Requirements: Not required for Servers. Required for Clients if the Client
// needs to discover the encoding the Server uses.
//
// The EncodingRequest message is a message requesting to change the DTC
// encoding for messages.
//
// For the procedure to work with this message, refer to Encoding Request
// Sequence.
func (s *Stub) OnEncodingRequest(msg EncodingRequest) error {
	log.Info("OnEncodingRequest: %s", message.JsonString(msg))
	return nil
}

// OnEncodingRequestExtended Requirements: Not required for Servers. Required for Clients if the Client
// needs to discover the encoding the Server uses.
//
// The EncodingRequest message is a message requesting to change the DTC
// encoding for messages.
//
// For the procedure to work with this message, refer to Encoding Request
// Sequence.
func (s *Stub) OnEncodingRequestExtended(msg EncodingRequestExtended) error {
	log.Info("OnEncodingRequestExtended: %s", message.JsonString(msg))
	return nil
}

// OnEncodingResponse Requirements: Required for Servers. Required for Clients if the Client
// needs to discover the encoding the Server uses.
//
// The EncodingResponse is a message from the Server to the Client, telling
// the Client what message encoding it must use to communicate with the Server.
// the Client what message encoding it must use to communicate with the Server.
//
// For the procedure to work with this message, refer to Encoding Request
// Sequence.
func (s *Stub) OnEncodingResponse(msg EncodingResponse) error {
	log.Info("OnEncodingResponse: %s", message.JsonString(msg))
	return nil
}

// OnLogonRequest The LogonRequest message is sent from the Client to the Server requesting
// to logon to the Server.
//
// This is the very first message the Client sends to the Server before being
// allowed to send any other message other than the EncodingRequest.
func (s *Stub) OnLogonRequest(msg LogonRequest) error {
	log.Info("OnLogonRequest: %s", message.JsonString(msg))
	return nil
}

// OnLogonResponse This is a response message indicating either success or an error logging
// on to the Server.
func (s *Stub) OnLogonResponse(msg LogonResponse) error {
	log.Info("OnLogonResponse: %s", message.JsonString(msg))
	return nil
}

// OnLogoff A Logoff is a message which can be sent either by the Client or the Server
// to the other side. It indicates that the Client or the Server is logging
// off and going to be closing the connection.
//
// When one side receives this message, it should expect the connection will
// be closed. It should not be expected that any messages will follow the
// Logoff message, and it should close the network connection and consider
// it finished. The side receiving this message can send a Logoff message
// to the other side before closing the connection.
func (s *Stub) OnLogoff(msg Logoff) error {
	log.Info("OnLogoff: %s", message.JsonString(msg))
	return nil
}

// OnHeartbeat Both the Client and the Server need to send to the other side a heartbeat
// at the interval specified by the HeartbeatIntervalInSeconds member in
// the LogonRequest.
//
// There are no required member fields to set in this message. The purpose
// of the Heartbeat message is so that the Client or the Server can determine
// whether the other side is still connected.
//
// It is recommended that if there is a loss of Heartbeat messages from the
// other side, for twice the amount of the HeartbeatIntervalInSeconds time
// that it is safe to assume that the other side is no longer present and
// the network socket should be then gracefully closed.
//
// The Server may choose to send a heartbeat message every second to the
// Client. In this particular case, it is recommended the Client use a minimum
// time of about 5 to 10 seconds without a heartbeat to determine the loss
// of the connection rather than the standard of twice the amount of the
// heartbeat time interval.
func (s *Stub) OnHeartbeat(msg Heartbeat) error {
	log.Info("OnHeartbeat: %s", message.JsonString(msg))
	return nil
}

// OnHeartbeatExtended Both the Client and the Server need to send to the other side a heartbeat
// at the interval specified by the HeartbeatIntervalInSeconds member in
// the LogonRequest.
//
// There are no required member fields to set in this message. The purpose
// of the Heartbeat message is so that the Client or the Server can determine
// whether the other side is still connected.
//
// It is recommended that if there is a loss of Heartbeat messages from the
// other side, for twice the amount of the HeartbeatIntervalInSeconds time
// that it is safe to assume that the other side is no longer present and
// the network socket should be then gracefully closed.
//
// The Server may choose to send a heartbeat message every second to the
// Client. In this particular case, it is recommended the Client use a minimum
// time of about 5 to 10 seconds without a heartbeat to determine the loss
// of the connection rather than the standard of twice the amount of the
// heartbeat time interval.
func (s *Stub) OnHeartbeatExtended(msg HeartbeatExtended) error {
	log.Info("OnHeartbeatExtended: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataFeedStatus The s_MarketDataFeed_STATUS message is an optional message sent by the
// Server to indicate the overall status of the market data feed. This status
// applies to all symbols that have been subscribed to for market data.
func (s *Stub) OnMarketDataFeedStatus(msg MarketDataFeedStatus) error {
	log.Info("OnMarketDataFeedStatus: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketDataFeedSymbolStatus(msg MarketDataFeedSymbolStatus) error {
	log.Info("OnMarketDataFeedSymbolStatus: %s", message.JsonString(msg))
	return nil
}

// OnTradingSymbolStatus Sent by the Server to the Client to indicate the status of the symbol
// in regards to whether trading is open or closed or some other intermediate
// state.
func (s *Stub) OnTradingSymbolStatus(msg TradingSymbolStatus) error {
	log.Info("OnTradingSymbolStatus: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataRequest The MarketDataRequest message will subscribe to market data for a particular
// Symbol or request a market data snapshot.
//
// The Server can also send market depth data in response to this message
// and not require a MarketDepthRequest.
func (s *Stub) OnMarketDataRequest(msg MarketDataRequest) error {
	log.Info("OnMarketDataRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketDepthRequest(msg MarketDepthRequest) error {
	log.Info("OnMarketDepthRequest: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataReject The MarketDataReject message is sent by the Server to the Client to reject
// a MarketDataRequest message for any reason.
func (s *Stub) OnMarketDataReject(msg MarketDataReject) error {
	log.Info("OnMarketDataReject: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataSnapshot The Server sends the MarketDataSnapshot message to the Client immediately
// after a successful MarketDataRequest message has been received from the
// Client and it has indicated to subscribe to the symbol or requested the
// snapshot of data.
//
// Any changes to the data fields within the MarketDataSnapshot message during
// the trading session will be sent by the Server to the Client through the
// corresponding MARKET_DATA_UPDATE_* messages.
//
// It is recommended that the MarketDataSnapshot be sent by the Server at
// the start of a new trading session.
//
// This message can be sent more often, however it is not intended to be
// sent frequently.
//
// This message type does not signify a trade has occurred. It should never
// be interpreted by the Client in that way.
//
// There is no need to send this when there is a new High or Low during the
// trading session. The Server should use the MarketDataUpdateSessionHigh
// or MarketDataUpdateSessionLow messages instead.
func (s *Stub) OnMarketDataSnapshot(msg MarketDataSnapshot) error {
	log.Info("OnMarketDataSnapshot: %s", message.JsonString(msg))
	return nil
}

// OnMarketDepthSnapshotLevel This is a message sent by Server to provide the initial market depth data
// entries to the Client after the Client subscribes to market data or separately
// subscribes to market depth data. The Client will need to separately subscribe
// to market depth data if the Server requires it.
//
// Each message provides a single entry of depth data. Therefore, the Server
// will send multiple MarketDepthSnapshotLevel messages in a series in order
// for the Client to build up its initial market depth book.
//
// The first message will be identified by the IsFirstMessageInBatch field
// being set to 1. The last message will be identified by the IsLastMessageInBatch
// field being set to 1.
//
// In the case where the market depth book is empty, the Server still needs
// to send through one single message with the SymbolID set, IsFirstMessageInBatch
// equal to 1 and IsLastMessageInBatch equal to 1. All other members will
// be at the default values. The Client will understand this as an empty
// book.
func (s *Stub) OnMarketDepthSnapshotLevel(msg MarketDepthSnapshotLevel) error {
	log.Info("OnMarketDepthSnapshotLevel: %s", message.JsonString(msg))
	return nil
}

// OnMarketDepthSnapshotLevelFloat This is a message sent by Server to provide the initial market depth data
// entries to the Client after the Client subscribes to market data or separately
// subscribes to market depth data. The Client will need to separately subscribe
// to market depth data if the Server requires it.
//
// Each message provides a single entry of depth data. Therefore, the Server
// will send multiple MarketDepthSnapshotLevelFloat messages in a series
// in order for the Client to build up its initial market depth book.
//
// The first message will be identified by the IsFirstMessageInBatch field
// being set to 1. The last message will be identified by the IsLastMessageInBatch
// field being set to 1.
//
// In the case where the market depth book is empty, the Server still needs
// to send through one single message with the SymbolID set, IsFirstMessageInBatch
// equal to 1 and IsLastMessageInBatch equal to 1. All other members will
// be at the default values. The Client will understand this as an empty
// book.
func (s *Stub) OnMarketDepthSnapshotLevelFloat(msg MarketDepthSnapshotLevelFloat) error {
	log.Info("OnMarketDepthSnapshotLevelFloat: %s", message.JsonString(msg))
	return nil
}

// OnMarketDepthUpdateLevel Sent by the Server to the Client to Update/Insert or Delete a particular
// market depth price level in the market depth book maintained by the Client.
// market depth price level in the market depth book maintained by the Client.
//
// Each MarketDepthUpdateLevel message updates one level of market depth
// on one side. An insert/update/delete model is used for market depth.
//
// The Client will need to determine the based upon the price, what particular
// market depth level is being updated, inserted or deleted.
//
// It is for this reason, that an insert/update is considered as one update
// type since it is possible to determine whether it is an insert or update
// based upon the existence of the price level in the existing market depth
// book on the Client side.
//
// What this means is that when the UpdateType field is MARKET_DEPTH_INSERT_UPDATE_LEVEL,
// it is considered an insert if the price level is not found on the particular
// side of the market depth being updated. It is considered an update, if
// the price level is found on the particular side of market depth being
// updated.
//
// This message uses a double datatype for the Price field. There is no level
// index. It is the responsibility of the Client to determine where in its
// market depth array it is maintaining where the insert/update/delete operation
// needs to occur.
//
// Since floating-point comparisons are not always precise, there should
// be a comparison made only to the number of decimal places the symbol specifies
// in its security definition. This can be determined through the SecurityDefinitionResponse::PriceDisplayFormat
// field.
func (s *Stub) OnMarketDepthUpdateLevel(msg MarketDepthUpdateLevel) error {
	log.Info("OnMarketDepthUpdateLevel: %s", message.JsonString(msg))
	return nil
}

// OnMarketDepthUpdateLevelFloatWithMilliseconds Sent by the Server to the Client to Update/Insert or Delete a particular
// market depth price level in the market depth book maintained by the Client.
// market depth price level in the market depth book maintained by the Client.
//
// This message is a more compact version of the MarketDepthUpdateLevel message.
// For the Price and Quantity fields, it uses a 4 byte float for compactness.
// It also supports millisecond precision for the timestamp.
func (s *Stub) OnMarketDepthUpdateLevelFloatWithMilliseconds(msg MarketDepthUpdateLevelFloatWithMilliseconds) error {
	log.Info("OnMarketDepthUpdateLevelFloatWithMilliseconds: %s", message.JsonString(msg))
	return nil
}

// OnMarketDepthUpdateLevelNoTimestamp Sent by the Server to the Client to Update/Insert or Delete a particular
// market depth price level in the market depth book maintained by the Client.
// market depth price level in the market depth book maintained by the Client.
//
// This message is identical to the MarketDepthUpdateLevel message except
// it has no timestamp field. It needs to be sent when there is no change
// with the timestamp for the market depth update as compared to the prior
// update.
//
// When the Server sends this message to the Client, the Client needs to
// use the prior received market depth update timestamp to know what the
// timestamp is for this message.
func (s *Stub) OnMarketDepthUpdateLevelNoTimestamp(msg MarketDepthUpdateLevelNoTimestamp) error {
	log.Info("OnMarketDepthUpdateLevelNoTimestamp: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateTradeNoTimestamp This message is optional.
//
// Sent by the Server to the Client when a trade occurs. This message is
// identical to the MarketDataUpdateTrade_WITH_UNBUNDLED_INDICATOR_2 message
// except it does not have a timestamp. It needs to be sent when there is
// no change with the timestamp for the trade as compared to the prior trade.
// no change with the timestamp for the trade as compared to the prior trade.
//
// When the Server sends this message to the Client, the Client needs to
// use the prior received trade timestamp to know what the timestamp is for
// this message.
func (s *Stub) OnMarketDataUpdateTradeNoTimestamp(msg MarketDataUpdateTradeNoTimestamp) error {
	log.Info("OnMarketDataUpdateTradeNoTimestamp: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateSessionSettlement Sent by the Server to the Client to update the session settlement price
// when the session settlement price changes.
func (s *Stub) OnMarketDataUpdateSessionSettlement(msg MarketDataUpdateSessionSettlement) error {
	log.Info("OnMarketDataUpdateSessionSettlement: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateSessionOpen Sent by the Server to the Client to update the session Open.
func (s *Stub) OnMarketDataUpdateSessionOpen(msg MarketDataUpdateSessionOpen) error {
	log.Info("OnMarketDataUpdateSessionOpen: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateSessionNumTrades Sent by the Server to the Client to update the trading session number
// of trades.
func (s *Stub) OnMarketDataUpdateSessionNumTrades(msg MarketDataUpdateSessionNumTrades) error {
	log.Info("OnMarketDataUpdateSessionNumTrades: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateTradingSessionDate Sent by the Server to the Client to update the trading session Date.
func (s *Stub) OnMarketDataUpdateTradingSessionDate(msg MarketDataUpdateTradingSessionDate) error {
	log.Info("OnMarketDataUpdateTradingSessionDate: %s", message.JsonString(msg))
	return nil
}

// OnMarketDepthReject The MarketDepthReject message is sent by the Server to the Client to reject
// a MarketDepthRequest message for any reason.
func (s *Stub) OnMarketDepthReject(msg MarketDepthReject) error {
	log.Info("OnMarketDepthReject: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateTrade The Server sends this market data feed message to the Client when a trade
// occurs.
func (s *Stub) OnMarketDataUpdateTrade(msg MarketDataUpdateTrade) error {
	log.Info("OnMarketDataUpdateTrade: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketDataUpdateTradeWithUnbundledIndicator(msg MarketDataUpdateTradeWithUnbundledIndicator) error {
	log.Info("OnMarketDataUpdateTradeWithUnbundledIndicator: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateTradeWithUnbundledIndicator2 Sent by the Server to the Client when a trade occurs. This message has
// additional fields as compared to the MarketDataUpdateTrade message and
// also supports microsecond time stamping.
func (s *Stub) OnMarketDataUpdateTradeWithUnbundledIndicator2(msg MarketDataUpdateTradeWithUnbundledIndicator2) error {
	log.Info("OnMarketDataUpdateTradeWithUnbundledIndicator2: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateBidAsk The Server sends this market data feed message to the Client when the
// best bid or ask price or size changes.
func (s *Stub) OnMarketDataUpdateBidAsk(msg MarketDataUpdateBidAsk) error {
	log.Info("OnMarketDataUpdateBidAsk: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketDataUpdateBidAskCompact(msg MarketDataUpdateBidAskCompact) error {
	log.Info("OnMarketDataUpdateBidAskCompact: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateBidAskFloatWithMicroseconds This message is optional.
//
// Sent by the Server to the Client when there is an update to the Bid Ask
// prices and/or quantities. This message is identical to the MarketDataUpdateBidAsk
// message except it does not have a timestamp. It needs to be sent when
// there is no change with the timestamp for the Bid Ask update as compared
// to the prior update.
//
// When the Server sends this message to the Client, the Client needs to
// use the prior received Bid Ask update timestamp to know what the timestamp
// is for this message.
func (s *Stub) OnMarketDataUpdateBidAskFloatWithMicroseconds(msg MarketDataUpdateBidAskFloatWithMicroseconds) error {
	log.Info("OnMarketDataUpdateBidAskFloatWithMicroseconds: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateBidAskNoTimeStamp This message is optional.
//
// Sent by the Server to the Client when there is an update to the Bid Ask
// prices and/or quantities. This message is identical to the MarketDataUpdateBidAsk
// message except it does not have a timestamp. It needs to be sent when
// there is no change with the timestamp for the Bid Ask update as compared
// to the prior update.
//
// When the Server sends this message to the Client, the Client needs to
// use the prior received Bid Ask update timestamp to know what the timestamp
// is for this message.
func (s *Stub) OnMarketDataUpdateBidAskNoTimeStamp(msg MarketDataUpdateBidAskNoTimeStamp) error {
	log.Info("OnMarketDataUpdateBidAskNoTimeStamp: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateTradeCompact Sent by the Server to the Client when a trade occurs. This message is
// a more compact MarketDataUpdateTrade. For the price it uses a 4 byte float.
// a more compact MarketDataUpdateTrade. For the price it uses a 4 byte float.
func (s *Stub) OnMarketDataUpdateTradeCompact(msg MarketDataUpdateTradeCompact) error {
	log.Info("OnMarketDataUpdateTradeCompact: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateSessionVolume Sent by the Server to the Client when the session trade Volume needs to
// be updated.
//
// The recommended rule for the Server to notify the Client of a change with
// the session trade volume to maintain bandwidth efficiency, is as follows:
// When a trade occurs for a symbol subscribed to, the Server will send a
// MarketDataUpdateTrade message to the Client. The Client should then increment
// its session trade volume value for the symbol by the value in the Volume
// field in this message.
//
// The Server will assume the Client is doing this. Therefore, when a trade
// occurs and the session trade volume does not equal the prior session trade
// volume plus the Volume for the most recent trade sent to the Client, then
// the Server must send out a MarketDataUpdateSessionVolume message to the
// client since the client calculation of the session trade volume is no
// longer correct.
//
// It is assumed that the reason for this inconsistency is due to trades
// included within the session trade volume which have not been sent out
// as normal trades.
//
// The Server should also send this message out at the frequency that the
// Server determines, such as every minute if there also has been a trade
// at that time.
func (s *Stub) OnMarketDataUpdateSessionVolume(msg MarketDataUpdateSessionVolume) error {
	log.Info("OnMarketDataUpdateSessionVolume: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateOpenInterest The MarketDataUpdateOpenInterest message is sent by the Server to the
// Client to update the OpenInterest field previously sent through the MarketDataSnapshot
// message.
func (s *Stub) OnMarketDataUpdateOpenInterest(msg MarketDataUpdateOpenInterest) error {
	log.Info("OnMarketDataUpdateOpenInterest: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateSessionHigh Sent by the Server to the Client to update the session High as the High
// price changes throughout the session.
func (s *Stub) OnMarketDataUpdateSessionHigh(msg MarketDataUpdateSessionHigh) error {
	log.Info("OnMarketDataUpdateSessionHigh: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateSessionLow Sent by the Server to the Client to update the session Low as the Low
// price changes throughout the session.
func (s *Stub) OnMarketDataUpdateSessionLow(msg MarketDataUpdateSessionLow) error {
	log.Info("OnMarketDataUpdateSessionLow: %s", message.JsonString(msg))
	return nil
}

// OnMarketDataUpdateLastTradeSnapshot Sent by the Server to the Client to update the last trade price, volume
// and date-time fields under conditions when there is not a trade.
//
// This message type does not signify a trade has occurred. It should never
// be interpreted by the Client in that way.
func (s *Stub) OnMarketDataUpdateLastTradeSnapshot(msg MarketDataUpdateLastTradeSnapshot) error {
	log.Info("OnMarketDataUpdateLastTradeSnapshot: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketOrdersRequest(msg MarketOrdersRequest) error {
	log.Info("OnMarketOrdersRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketOrdersReject(msg MarketOrdersReject) error {
	log.Info("OnMarketOrdersReject: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketOrdersAdd(msg MarketOrdersAdd) error {
	log.Info("OnMarketOrdersAdd: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketOrdersModify(msg MarketOrdersModify) error {
	log.Info("OnMarketOrdersModify: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketOrdersRemove(msg MarketOrdersRemove) error {
	log.Info("OnMarketOrdersRemove: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarketOrdersSnapshotMessageBoundary(msg MarketOrdersSnapshotMessageBoundary) error {
	log.Info("OnMarketOrdersSnapshotMessageBoundary: %s", message.JsonString(msg))
	return nil
}

// OnSubmitNewSingleOrder This message is used to submit a new single order into the market from
// the Client to the Server.
func (s *Stub) OnSubmitNewSingleOrder(msg SubmitNewSingleOrder) error {
	log.Info("OnSubmitNewSingleOrder: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnSubmitFlattenPositionOrder(msg SubmitFlattenPositionOrder) error {
	log.Info("OnSubmitFlattenPositionOrder: %s", message.JsonString(msg))
	return nil
}

// OnCancelReplaceOrder This message is sent by the Client to the Server to cancel and replace
// an existing order. This is also known as an order modification.
//
// When the cancel and replace operation is completed, an OrderUpdate message
// is sent by the Server with the OrderUpdateReasonfield set to ORDER_CANCEL_REPLACE_COMPLETE.
// If the cancel and replace operation cannot be completed, an OrderUpdate
// message is sent by the Server with the OrderUpdateReason set to ORDER_CANCEL_REPLACE_REJECTED.
// message is sent by the Server with the OrderUpdateReason set to ORDER_CANCEL_REPLACE_REJECTED.
func (s *Stub) OnCancelReplaceOrder(msg CancelReplaceOrder) error {
	log.Info("OnCancelReplaceOrder: %s", message.JsonString(msg))
	return nil
}

// OnCancelOrder This is a message from the Client to the Server requesting a previously
// sent order to be canceled.
func (s *Stub) OnCancelOrder(msg CancelOrder) error {
	log.Info("OnCancelOrder: %s", message.JsonString(msg))
	return nil
}

// OnSubmitNewOCOOrder This is a message from the Client to the Server for submitting an order
// cancels order (OCO) pair into the market. What this means is when one
// of the orders is filled or canceled, the other order will be canceled.
// If one order partially fills, the other order will be reduced in quantity
// by the fill amount of the order that partially filled.
//
// A service provider must implement OCO orders on the server so that they
// can independently be modified (Cancel/Replace) and canceled independently
// using each order's distinct ServerOrderID. Although, if one of the orders
// is canceled by the Client, the other order will be canceled as well unless
// they have a parent order, as specified through the ParentTriggerClientOrderID
// field, in which case the other order should remain open.
//
// If the OCO order pair is rejected, this must be communicated through two
// separate OrderUpdate messages, 1 for each order, with the OrderUpdateReason
// set to NEW_ORDER_REJECTED.
func (s *Stub) OnSubmitNewOCOOrder(msg SubmitNewOCOOrder) error {
	log.Info("OnSubmitNewOCOOrder: %s", message.JsonString(msg))
	return nil
}

// OnOpenOrdersRequest This is a message from the Client to the Server requesting the currently
// open orders.
//
// The Server will send open/working orders in response to this request through
// OrderUpdate messages.
//
// The Server will not return canceled or filled orders.
//
// When the Server responds to this request, it needs to respond with a separate
// OrderUpdate for each order.
//
// When the Server responds to this request, OrderUpdateReason in the OrderUpdate
// message must be set to OpenOrdersRequest_RESPONSE indicating the orders
// are being restated.
//
// If there are no Open orders, the Server will send back 1 OrderUpdate message
// with only the TotalNumberMessages, MessageNumber, RequestID, OrderUpdateReason,
// NoOrders = 1 fields set in the OrderUpdate message.
func (s *Stub) OnOpenOrdersRequest(msg OpenOrdersRequest) error {
	log.Info("OnOpenOrdersRequest: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalOrderFillsRequest This is a message from the Client to the Server to request order fills/executions
// for an order or orders.
func (s *Stub) OnHistoricalOrderFillsRequest(msg HistoricalOrderFillsRequest) error {
	log.Info("OnHistoricalOrderFillsRequest: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalOrderFillsReject If the Server is unable to serve the request for a HistoricalOrderFillsRequest
// message received, for a reason other than there not being any historical
// order fills, then send this message to the Client.
func (s *Stub) OnHistoricalOrderFillsReject(msg HistoricalOrderFillsReject) error {
	log.Info("OnHistoricalOrderFillsReject: %s", message.JsonString(msg))
	return nil
}

// OnCurrentPositionsRequest This is a message from the Client to the Server to request the current
// open Trade Positions.
func (s *Stub) OnCurrentPositionsRequest(msg CurrentPositionsRequest) error {
	log.Info("OnCurrentPositionsRequest: %s", message.JsonString(msg))
	return nil
}

// OnCurrentPositionsReject If the Server is unable to serve the request for an CurrentPositionsRequest
// message received, for a reason other than there not being any current
// Trade positions, then send this message to the Client.
//
// This must never be sent when there are actually no Trade Positions in
// the account or accounts requested.
func (s *Stub) OnCurrentPositionsReject(msg CurrentPositionsReject) error {
	log.Info("OnCurrentPositionsReject: %s", message.JsonString(msg))
	return nil
}

// OnOrderUpdate The OrderUpdate is a unified message from the Server to the Client which
// communicates the complete details of an order, the Order Status, and the
// reason for sending the message (OrderUpdateReason).
//
// DTC uses this single unified message to provide an update for an order.
// The OrderUpdateReason field provides a clear indication for each reason
// this message is being sent.
func (s *Stub) OnOrderUpdate(msg OrderUpdate) error {
	log.Info("OnOrderUpdate: %s", message.JsonString(msg))
	return nil
}

// OnOpenOrdersReject If the Server is unable to serve the request for an OpenOrdersRequest
// message received, for a reason other than there not being any open orders,
// then send this message to the Client.
func (s *Stub) OnOpenOrdersReject(msg OpenOrdersReject) error {
	log.Info("OnOpenOrdersReject: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalOrderFillResponse This is a message from the Server to the Client providing an individual
// historical order fill in response to a HistoricalOrderFillsRequest message.
// historical order fill in response to a HistoricalOrderFillsRequest message.
//
// The Server is expected to send this message to the Client in response
// to a HistoricalOrderFillsRequest message even when there are no order
// fills to return. If there are no order fills to return, it needs to set
// the NoOrderFills field to 1.
func (s *Stub) OnHistoricalOrderFillResponse(msg HistoricalOrderFillResponse) error {
	log.Info("OnHistoricalOrderFillResponse: %s", message.JsonString(msg))
	return nil
}

// OnPositionUpdate This is a message from the Server to the Client to report a Trade Position
// for a symbol in any Trade Account for the logged in Username.
//
// The Position Update message can either be solicited, in response to CurrentPositionsRequest.
// Or unsolicited as a Trade Position for a symbol changes during the connection
// to the Server. Each Trade Position is contained within a single message.
// to the Server. Each Trade Position is contained within a single message.
//
// When the server is responding with one or more PositionUpdate messages
// in response to a CurrentPositionsRequest message, it must not send any
// unsolicited PositionUpdate messages interleaved with the solicited PositionUpdate
// messages in response to the CurrentPositionsRequest message.
func (s *Stub) OnPositionUpdate(msg PositionUpdate) error {
	log.Info("OnPositionUpdate: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnAddCorrectingOrderFill(msg AddCorrectingOrderFill) error {
	log.Info("OnAddCorrectingOrderFill: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnCorrectingOrderFillResponse(msg CorrectingOrderFillResponse) error {
	log.Info("OnCorrectingOrderFillResponse: %s", message.JsonString(msg))
	return nil
}

// OnTradeAccountsRequest This is a message from the Client to the Server to request all of the
// account identifiers for the logged in Username.
//
// If there are no accounts available, then the Server needs to respond with
// at least one TradeAccountResponse message containing an empty Trade Account.
// at least one TradeAccountResponse message containing an empty Trade Account.
func (s *Stub) OnTradeAccountsRequest(msg TradeAccountsRequest) error {
	log.Info("OnTradeAccountsRequest: %s", message.JsonString(msg))
	return nil
}

// OnTradeAccountResponse This is a message from the Server to the Client in response to a TradeAccountsRequest
// message, providing a single trade account. There is one message for each
// trade account.
func (s *Stub) OnTradeAccountResponse(msg TradeAccountResponse) error {
	log.Info("OnTradeAccountResponse: %s", message.JsonString(msg))
	return nil
}

// OnExchangeListRequest This is a message from the Client to the Server to request a list of all
// available exchanges from the Server.
//
// The server will respond with a separate ExchangeListResponse message for
// each exchange.
//
// In the case where the Server does not specify an exchange with its symbols,
// then the Server should provide a single response with an empty Exchange.
// then the Server should provide a single response with an empty Exchange.
func (s *Stub) OnExchangeListRequest(msg ExchangeListRequest) error {
	log.Info("OnExchangeListRequest: %s", message.JsonString(msg))
	return nil
}

// OnExchangeListResponse The server will return this message for each supported exchange.
//
// If there are no exchanges to return in response to a request, send through
// one of these messages with the RequestID set and IsFinalMessage = 1. Leave
// all other members in the default state and the Client will recognize there
// are no Exchanges.
func (s *Stub) OnExchangeListResponse(msg ExchangeListResponse) error {
	log.Info("OnExchangeListResponse: %s", message.JsonString(msg))
	return nil
}

// OnSymbolsForExchangeRequest This is a message from the Client to the Server to request all of the
// Symbols for a particular Exchange.
//
// The server will return a SecurityDefinitionResponse message to the Client
// for each Symbol returned.
//
// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
// message to the Client.
func (s *Stub) OnSymbolsForExchangeRequest(msg SymbolsForExchangeRequest) error {
	log.Info("OnSymbolsForExchangeRequest: %s", message.JsonString(msg))
	return nil
}

// OnUnderlyingSymbolsForExchangeRequest This is a message from the Client to the Server to request all of the
// underlying symbols on a particular Exchange. For example, all of the underlying
// futures symbols on a particular Exchange.
//
// The server will return a SecurityDefinitionResponse message to the Client
// for each Symbol returned.
//
// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
// message to the Client.
func (s *Stub) OnUnderlyingSymbolsForExchangeRequest(msg UnderlyingSymbolsForExchangeRequest) error {
	log.Info("OnUnderlyingSymbolsForExchangeRequest: %s", message.JsonString(msg))
	return nil
}

// OnSymbolsForUnderlyingRequest This is a message from the Client to the Server for requesting all of
// the symbols for a particular underlying symbol.
//
// For example, all of the futures contracts for a particular underlying
// futures symbol or all of the option symbols for a specific futures or
// stock symbol.
//
// The server will return a SecurityDefinitionResponse message to the Client
// for each Symbol returned.
//
// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
// message to the Client.
func (s *Stub) OnSymbolsForUnderlyingRequest(msg SymbolsForUnderlyingRequest) error {
	log.Info("OnSymbolsForUnderlyingRequest: %s", message.JsonString(msg))
	return nil
}

// OnSymbolSearchRequest The SymbolSearchRequest message is sent by the Client to the Server to
// return Security Definitions matching the specified SecurityType and Exchange
// and where the Symbol or Description contains the specified SearchText.
//
// The SearchText can search either the Symbol or the Description field in
// the SecurityDefinitionResponse message.
//
// In either case there does not need to be an exact match. The SearchText
// only needs to be contained within the Symbol or the Description depending
// upon which field is being searched.
//
// The Server returns SecurityDefinitionResponse messages for all Symbols
// which match.
//
// If there are no matches, the Server needs to send a SecurityDefinitionResponse
// message to the Client with with all fields at their default values except
// for the RequestID and IsFinalMessage fields set. This will be a clear
// indication to the Client that the request returned no matches.
//
// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
// message to the Client.
func (s *Stub) OnSymbolSearchRequest(msg SymbolSearchRequest) error {
	log.Info("OnSymbolSearchRequest: %s", message.JsonString(msg))
	return nil
}

// OnSecurityDefinitionForSymbolRequest This is a message from the Client to the Server for requesting Security
// Definition data for a specific symbol.
//
// The Server will return a single SecurityDefinitionResponse message in
// response to this request.
//
// The Client must always send a SecurityDefinitionForSymbolRequest message
// to the Server in order to obtain the IntegerToFloatPriceDivisor value
// in case the Server uses the integer market data messages.
//
// If the Server is rejecting this request, then it needs to send a SecurityDefinitionReject
// message to the Client.
func (s *Stub) OnSecurityDefinitionForSymbolRequest(msg SecurityDefinitionForSymbolRequest) error {
	log.Info("OnSecurityDefinitionForSymbolRequest: %s", message.JsonString(msg))
	return nil
}

// OnSecurityDefinitionResponse This is a response from the Server in response to a SymbolsForExchangeRequest,
// UNDERLYING_SymbolsForExchangeRequest, SymbolsForUnderlyingRequest, SecurityDefinitionForSymbolRequest,
// SymbolSearchRequest message.
//
// If there are no symbols to return in response to a request, the Server
// needs to send through one of these messages with the RequestID set to
// the same RequestID value that the request message set it to, and IsFinalMessage
// = 1. Leave all other member fields in the default state and the Client
// will recognize there are no symbols.
//
// The Client must always send a SecurityDefinitionForSymbolRequest message
// to the Server to obtain the IntegerToFloatPriceDivisor and FloatToIntPriceMultiplier
// values in the Security Definition Response message when the Server uses
// the integer market data and order messages.
func (s *Stub) OnSecurityDefinitionResponse(msg SecurityDefinitionResponse) error {
	log.Info("OnSecurityDefinitionResponse: %s", message.JsonString(msg))
	return nil
}

// OnSecurityDefinitionReject This is a message from the Server to the Client indicating the Server
// is rejecting one of the following messages: SymbolsForExchangeRequest,
// UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest, SecurityDefinitionForSymbolRequest,
// SymbolSearchRequest.
//
// If there are no symbols to send in response to one of these messages above,
// then the Server should not send a SecurityDefinitionReject message and
// instead send a SecurityDefinitionResponse with only the RequestID and
// IsFinalMessage fields set. This will be a clear indication to the Client
// that the request returned no Symbols.
func (s *Stub) OnSecurityDefinitionReject(msg SecurityDefinitionReject) error {
	log.Info("OnSecurityDefinitionReject: %s", message.JsonString(msg))
	return nil
}

// OnAccountBalanceRequest This is a message from the Client to the Server to request Trade Account
// Balance data.
//
// The Server will respond with an AccountBalanceUpdate or reject the request.
// The Server will respond with an AccountBalanceUpdate or reject the request.
//
// The Server will set the RequestID in the AccountBalanceUpdate message
// to match the RequestID in the AccountBalanceRequest.
//
// The Server will periodically send AccountBalanceUpdate messages as the
// Account Balance data changes. The frequency of the updates is determined
// by the Server. Account Balance updates are considered automatically subscribed
// to. When unsolicited AccountBalanceUpdate messages are sent by the Server,
// the RequestID will be 0.
func (s *Stub) OnAccountBalanceRequest(msg AccountBalanceRequest) error {
	log.Info("OnAccountBalanceRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnAccountBalanceReject(msg AccountBalanceReject) error {
	log.Info("OnAccountBalanceReject: %s", message.JsonString(msg))
	return nil
}

// OnAccountBalanceUpdate This is an optional message from the Server to Client to provide Account
// Balance information for a particular Trade Account. The server needs to
// provide a separate message for each Trade Account associated with the
// logged in username if it supports Account Balance updates.
//
// The Server will respond with an AccountBalanceUpdate in response to a
// AccountBalanceRequest message. The Server will set the RequestID in the
// AccountBalanceUpdate message to match the RequestID in the AccountBalanceRequest
// message.
//
// The Server will periodically send AccountBalanceUpdate messages as the
// Account Balance data changes. The frequency of the updates is determined
// by the Server. Account Balance updates are considered automatically subscribed
// to. When an unsolicited AccountBalanceUpdate message is sent, the RequestID
// field will be 0.
//
// When the server is responding with one or more AccountBalanceUpdate messages
// in response to a AccountBalanceRequest message, it must not send any unsolicited
// AccountBalanceUpdate messages interleaved with the solicited AccountBalanceUpdate
// messages in response to the AccountBalanceRequest message.
func (s *Stub) OnAccountBalanceUpdate(msg AccountBalanceUpdate) error {
	log.Info("OnAccountBalanceUpdate: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnAccountBalanceAdjustment(msg AccountBalanceAdjustment) error {
	log.Info("OnAccountBalanceAdjustment: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnAccountBalanceAdjustmentReject(msg AccountBalanceAdjustmentReject) error {
	log.Info("OnAccountBalanceAdjustmentReject: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnAccountBalanceAdjustmentComplete(msg AccountBalanceAdjustmentComplete) error {
	log.Info("OnAccountBalanceAdjustmentComplete: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalAccountBalancesRequest This is a message from the Client to the Server to request a history of
// Cash Balance changes for the specified Trade Account.
//
// The Server will respond with multiple HISTORICAL_ACCOUNT_BALANCE_RESPONSE
// messages or reject he request with a message.
//
// The Server will set the RequestID in the HISTORICAL_ACCOUNT_BALANCE_RESPONSE
// message to match the RequestID in the HistoricalAccountBalancesRequest.
// message to match the RequestID in the HistoricalAccountBalancesRequest.
func (s *Stub) OnHistoricalAccountBalancesRequest(msg HistoricalAccountBalancesRequest) error {
	log.Info("OnHistoricalAccountBalancesRequest: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalAccountBalancesReject This is a message from the Server to the Client to reject a HistoricalAccountBalancesRequest
// request.
func (s *Stub) OnHistoricalAccountBalancesReject(msg HistoricalAccountBalancesReject) error {
	log.Info("OnHistoricalAccountBalancesReject: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalAccountBalanceResponse(msg HistoricalAccountBalanceResponse) error {
	log.Info("OnHistoricalAccountBalanceResponse: %s", message.JsonString(msg))
	return nil
}

// OnUserMessage This message from the Server to the Client is for providing a message
// to the user.
//
// This message can be sent even before a LogonResponse.
func (s *Stub) OnUserMessage(msg UserMessage) error {
	log.Info("OnUserMessage: %s", message.JsonString(msg))
	return nil
}

// OnGeneralLogMessage This message from the Server to the Client is a message which is to be
// added to a log file indicating information from the server. For example,
// if there are informational messages to provide during the process of a
// logon, this can be used to send those messages to a Client. A Client should
// never implement this message as a pop-up type message. Instead, it should
// be treated as a lower-level log type message.
//
// This message can be sent even before a LogonResponse is given.
func (s *Stub) OnGeneralLogMessage(msg GeneralLogMessage) error {
	log.Info("OnGeneralLogMessage: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnAlertMessage(msg AlertMessage) error {
	log.Info("OnAlertMessage: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnJournalEntryAdd(msg JournalEntryAdd) error {
	log.Info("OnJournalEntryAdd: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnJournalEntriesRequest(msg JournalEntriesRequest) error {
	log.Info("OnJournalEntriesRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnJournalEntriesReject(msg JournalEntriesReject) error {
	log.Info("OnJournalEntriesReject: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnJournalEntryResponse(msg JournalEntryResponse) error {
	log.Info("OnJournalEntryResponse: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalPriceDataRequest This is a message from the Client to the Server for requesting historical
// price data.
//
// This request can be on the same or a separate network socket connection
// compared to the streaming market data. This is going to be specified by
// the Server.
func (s *Stub) OnHistoricalPriceDataRequest(msg HistoricalPriceDataRequest) error {
	log.Info("OnHistoricalPriceDataRequest: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalPriceDataResponseHeader When a historical price data request is not rejected, this message header
// will begin the historical price data response from the Server. There will
// be one HistoricalPriceDataResponseHeader message sent ahead of the HistoricalPriceDataRecordResponse
// / HistoricalPriceDataTickRecordResponse messages. If the NoRecordsToReturn
// field is nonzero, then there are no further records that will be sent
// by the Server in response to the request by the Client.
//
// This message is never compressed.
func (s *Stub) OnHistoricalPriceDataResponseHeader(msg HistoricalPriceDataResponseHeader) error {
	log.Info("OnHistoricalPriceDataResponseHeader: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalPriceDataReject When the Server rejects a historical price data request from the Client,
// a HistoricalPriceDataReject message will be sent.
//
// This message is never compressed.
func (s *Stub) OnHistoricalPriceDataReject(msg HistoricalPriceDataReject) error {
	log.Info("OnHistoricalPriceDataReject: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalPriceDataRecordResponse The HistoricalPriceDataTickRecordResponse message is used when the RecordInterval
// field in a historical data request message is set to a value greater than
// INTERVAL_TICK. For example, if the RecordInterval is INTERVAL_1_MINUTE,
// then a message of this type will contain data for a 1 minute timeframe
// with a start time specified by the StartDateTime field.
//
// Even when RecordInterval is INTERVAL_TICK, the HistoricalPriceDataTickRecordResponse
// message can still be used instead of HistoricalPriceDataTickRecordResponse.
// message can still be used instead of HistoricalPriceDataTickRecordResponse.
//
// This message can be part of a compressed series of messages of this same
// type, if the Client requested compression be used.
func (s *Stub) OnHistoricalPriceDataRecordResponse(msg HistoricalPriceDataRecordResponse) error {
	log.Info("OnHistoricalPriceDataRecordResponse: %s", message.JsonString(msg))
	return nil
}

// OnHistoricalPriceDataTickRecordResponse This is the response message when the RecordInterval field in a historical
// data request message is set to INTERVAL_TICK.
//
// If the Server does not support 1 Tick historical data or does not have
// 1 Tick historical data for the specified time period, it can respond with
// HistoricalPriceDataRecordResponse messages instead. The Server must only
// respond with messages of one type in response to a particular historical
// price data request.
//
// This message can be part of a compressed series of messages of this same
// type, if the Client requested compression be used.
func (s *Stub) OnHistoricalPriceDataTickRecordResponse(msg HistoricalPriceDataTickRecordResponse) error {
	log.Info("OnHistoricalPriceDataTickRecordResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalPriceDataResponseTrailer(msg HistoricalPriceDataResponseTrailer) error {
	log.Info("OnHistoricalPriceDataResponseTrailer: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalMarketDepthDataRequest(msg HistoricalMarketDepthDataRequest) error {
	log.Info("OnHistoricalMarketDepthDataRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalMarketDepthDataResponseHeader(msg HistoricalMarketDepthDataResponseHeader) error {
	log.Info("OnHistoricalMarketDepthDataResponseHeader: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalMarketDepthDataReject(msg HistoricalMarketDepthDataReject) error {
	log.Info("OnHistoricalMarketDepthDataReject: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalMarketDepthDataRecordResponse(msg HistoricalMarketDepthDataRecordResponse) error {
	log.Info("OnHistoricalMarketDepthDataRecordResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalTradesRequest(msg HistoricalTradesRequest) error {
	log.Info("OnHistoricalTradesRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalTradesReject(msg HistoricalTradesReject) error {
	log.Info("OnHistoricalTradesReject: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnHistoricalTradesResponse(msg HistoricalTradesResponse) error {
	log.Info("OnHistoricalTradesResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnReplayChartData(msg ReplayChartData) error {
	log.Info("OnReplayChartData: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnReplayChartDataPerformAction(msg ReplayChartDataPerformAction) error {
	log.Info("OnReplayChartDataPerformAction: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnReplayChartDataStatus(msg ReplayChartDataStatus) error {
	log.Info("OnReplayChartDataStatus: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnRequestNumCurrentClientConnections(msg RequestNumCurrentClientConnections) error {
	log.Info("OnRequestNumCurrentClientConnections: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnNumCurrentClientConnectionsResponse(msg NumCurrentClientConnectionsResponse) error {
	log.Info("OnNumCurrentClientConnectionsResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnClientDeviceUpdate(msg ClientDeviceUpdate) error {
	log.Info("OnClientDeviceUpdate: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnInterprocessSynchronizationRemoteState(msg InterprocessSynchronizationRemoteState) error {
	log.Info("OnInterprocessSynchronizationRemoteState: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnInterprocessSynchronizationSnapshotRequest(msg InterprocessSynchronizationSnapshotRequest) error {
	log.Info("OnInterprocessSynchronizationSnapshotRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnInterprocessSynchronizationTradeActivityRequest(msg InterprocessSynchronizationTradeActivityRequest) error {
	log.Info("OnInterprocessSynchronizationTradeActivityRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnWriteIntradayDataFileSessionValue(msg WriteIntradayDataFileSessionValue) error {
	log.Info("OnWriteIntradayDataFileSessionValue: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnSCConfigurationSynchronization(msg SCConfigurationSynchronization) error {
	log.Info("OnSCConfigurationSynchronization: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnDownloadHistoricalOrderFillAndAccountBalanceData(msg DownloadHistoricalOrderFillAndAccountBalanceData) error {
	log.Info("OnDownloadHistoricalOrderFillAndAccountBalanceData: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeOrder(msg TradeOrder) error {
	log.Info("OnTradeOrder: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnIndividualTradePosition(msg IndividualTradePosition) error {
	log.Info("OnIndividualTradePosition: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradePositionConsolidated(msg TradePositionConsolidated) error {
	log.Info("OnTradePositionConsolidated: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeActivityData(msg TradeActivityData) error {
	log.Info("OnTradeActivityData: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataRequest(msg TradeAccountDataRequest) error {
	log.Info("OnTradeAccountDataRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataResponse(msg TradeAccountDataResponse) error {
	log.Info("OnTradeAccountDataResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataUpdate(msg TradeAccountDataUpdate) error {
	log.Info("OnTradeAccountDataUpdate: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataDelete(msg TradeAccountDataDelete) error {
	log.Info("OnTradeAccountDataDelete: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataSymbolLimitsResponse(msg TradeAccountDataSymbolLimitsResponse) error {
	log.Info("OnTradeAccountDataSymbolLimitsResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataSymbolLimitsUpdate(msg TradeAccountDataSymbolLimitsUpdate) error {
	log.Info("OnTradeAccountDataSymbolLimitsUpdate: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataSymbolCommissionResponse(msg TradeAccountDataSymbolCommissionResponse) error {
	log.Info("OnTradeAccountDataSymbolCommissionResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataSymbolCommissionUpdate(msg TradeAccountDataSymbolCommissionUpdate) error {
	log.Info("OnTradeAccountDataSymbolCommissionUpdate: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataAuthorizedUsernameResponse(msg TradeAccountDataAuthorizedUsernameResponse) error {
	log.Info("OnTradeAccountDataAuthorizedUsernameResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataAuthorizedUsernameAdd(msg TradeAccountDataAuthorizedUsernameAdd) error {
	log.Info("OnTradeAccountDataAuthorizedUsernameAdd: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataAuthorizedUsernameRemove(msg TradeAccountDataAuthorizedUsernameRemove) error {
	log.Info("OnTradeAccountDataAuthorizedUsernameRemove: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataUsernameToShareWithResponse(msg TradeAccountDataUsernameToShareWithResponse) error {
	log.Info("OnTradeAccountDataUsernameToShareWithResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataUsernameToShareWithAdd(msg TradeAccountDataUsernameToShareWithAdd) error {
	log.Info("OnTradeAccountDataUsernameToShareWithAdd: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataUsernameToShareWithRemove(msg TradeAccountDataUsernameToShareWithRemove) error {
	log.Info("OnTradeAccountDataUsernameToShareWithRemove: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataResponseTrailer(msg TradeAccountDataResponseTrailer) error {
	log.Info("OnTradeAccountDataResponseTrailer: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnTradeAccountDataUpdateOperationComplete(msg TradeAccountDataUpdateOperationComplete) error {
	log.Info("OnTradeAccountDataUpdateOperationComplete: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnProcessedFillIdentifier(msg ProcessedFillIdentifier) error {
	log.Info("OnProcessedFillIdentifier: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnFlattenPositionsForTradeAccount(msg FlattenPositionsForTradeAccount) error {
	log.Info("OnFlattenPositionsForTradeAccount: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnUserInformation(msg UserInformation) error {
	log.Info("OnUserInformation: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarginDataRequest(msg MarginDataRequest) error {
	log.Info("OnMarginDataRequest: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnMarginDataResponse(msg MarginDataResponse) error {
	log.Info("OnMarginDataResponse: %s", message.JsonString(msg))
	return nil
}

func (s *Stub) OnUnknown(b []byte, t uint16) error {
	log.Info("OnUnknown: size:%s type:%d", len(b), t)
	return nil
}

func (s *Stub) OnError(b []byte, t uint16, err error) {
	log.Info("OnError: size:%s type:%d error:%s", len(b), t, err.Error())
}

func Handle(b []byte, h Handler) error {
	if len(b) < 6 {
		return message.ErrShortBuffer
	}
	p := message.PointerOf(b)
	if int(p.AsUint16LE()) != len(b) {
		return message.ErrFraming
	}
	t := p.Uint16LE(2)
	switch t {
	case 6:
		if len(b) > 16 {
			m, e := ParseEncodingRequestExtended(b)
			if e != nil {
				h.OnError(b, t, e)
				return e
			}
			return h.OnEncodingRequestExtended(m)
		}
		m, e := ParseEncodingRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnEncodingRequest(m)
	case 7:
		m, e := ParseEncodingResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnEncodingResponse(m)
	case 1:
		m, e := ParseLogonRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnLogonRequest(m)
	case 2:
		m, e := ParseLogonResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnLogonResponse(m)
	case 5:
		m, e := ParseLogoff(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnLogoff(m)
	case 3:
		if len(b) > 16 {
			m, e := ParseHeartbeatExtended(b)
			if e != nil {
				h.OnError(b, t, e)
				return e
			}
			return h.OnHeartbeatExtended(m)
		}
		m, e := ParseHeartbeat(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHeartbeat(m)
	case 100:
		m, e := ParseMarketDataFeedStatus(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataFeedStatus(m)
	case 116:
		m, e := ParseMarketDataFeedSymbolStatus(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataFeedSymbolStatus(m)
	case 138:
		m, e := ParseTradingSymbolStatus(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradingSymbolStatus(m)
	case 101:
		m, e := ParseMarketDataRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataRequest(m)
	case 102:
		m, e := ParseMarketDepthRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDepthRequest(m)
	case 103:
		m, e := ParseMarketDataReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataReject(m)
	case 104:
		m, e := ParseMarketDataSnapshot(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataSnapshot(m)
	case 122:
		m, e := ParseMarketDepthSnapshotLevel(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDepthSnapshotLevel(m)
	case 145:
		m, e := ParseMarketDepthSnapshotLevelFloat(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDepthSnapshotLevelFloat(m)
	case 106:
		m, e := ParseMarketDepthUpdateLevel(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDepthUpdateLevel(m)
	case 140:
		m, e := ParseMarketDepthUpdateLevelFloatWithMilliseconds(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDepthUpdateLevelFloatWithMilliseconds(m)
	case 141:
		m, e := ParseMarketDepthUpdateLevelNoTimestamp(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDepthUpdateLevelNoTimestamp(m)
	case 142:
		m, e := ParseMarketDataUpdateTradeNoTimestamp(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateTradeNoTimestamp(m)
	case 119:
		m, e := ParseMarketDataUpdateSessionSettlement(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateSessionSettlement(m)
	case 120:
		m, e := ParseMarketDataUpdateSessionOpen(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateSessionOpen(m)
	case 135:
		m, e := ParseMarketDataUpdateSessionNumTrades(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateSessionNumTrades(m)
	case 136:
		m, e := ParseMarketDataUpdateTradingSessionDate(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateTradingSessionDate(m)
	case 121:
		m, e := ParseMarketDepthReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDepthReject(m)
	case 107:
		m, e := ParseMarketDataUpdateTrade(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateTrade(m)
	case 137:
		m, e := ParseMarketDataUpdateTradeWithUnbundledIndicator(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateTradeWithUnbundledIndicator(m)
	case 146:
		m, e := ParseMarketDataUpdateTradeWithUnbundledIndicator2(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateTradeWithUnbundledIndicator2(m)
	case 108:
		m, e := ParseMarketDataUpdateBidAsk(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateBidAsk(m)
	case 117:
		m, e := ParseMarketDataUpdateBidAskCompact(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateBidAskCompact(m)
	case 144:
		m, e := ParseMarketDataUpdateBidAskFloatWithMicroseconds(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateBidAskFloatWithMicroseconds(m)
	case 143:
		m, e := ParseMarketDataUpdateBidAskNoTimeStamp(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateBidAskNoTimeStamp(m)
	case 112:
		m, e := ParseMarketDataUpdateTradeCompact(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateTradeCompact(m)
	case 113:
		m, e := ParseMarketDataUpdateSessionVolume(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateSessionVolume(m)
	case 124:
		m, e := ParseMarketDataUpdateOpenInterest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateOpenInterest(m)
	case 114:
		m, e := ParseMarketDataUpdateSessionHigh(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateSessionHigh(m)
	case 115:
		m, e := ParseMarketDataUpdateSessionLow(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateSessionLow(m)
	case 134:
		m, e := ParseMarketDataUpdateLastTradeSnapshot(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketDataUpdateLastTradeSnapshot(m)
	case 150:
		m, e := ParseMarketOrdersRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketOrdersRequest(m)
	case 151:
		m, e := ParseMarketOrdersReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketOrdersReject(m)
	case 152:
		m, e := ParseMarketOrdersAdd(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketOrdersAdd(m)
	case 153:
		m, e := ParseMarketOrdersModify(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketOrdersModify(m)
	case 154:
		m, e := ParseMarketOrdersRemove(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketOrdersRemove(m)
	case 155:
		m, e := ParseMarketOrdersSnapshotMessageBoundary(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarketOrdersSnapshotMessageBoundary(m)
	case 208:
		m, e := ParseSubmitNewSingleOrder(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSubmitNewSingleOrder(m)
	case 209:
		m, e := ParseSubmitFlattenPositionOrder(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSubmitFlattenPositionOrder(m)
	case 204:
		m, e := ParseCancelReplaceOrder(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnCancelReplaceOrder(m)
	case 203:
		m, e := ParseCancelOrder(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnCancelOrder(m)
	case 201:
		m, e := ParseSubmitNewOCOOrder(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSubmitNewOCOOrder(m)
	case 300:
		m, e := ParseOpenOrdersRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnOpenOrdersRequest(m)
	case 303:
		m, e := ParseHistoricalOrderFillsRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalOrderFillsRequest(m)
	case 308:
		m, e := ParseHistoricalOrderFillsReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalOrderFillsReject(m)
	case 305:
		m, e := ParseCurrentPositionsRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnCurrentPositionsRequest(m)
	case 307:
		m, e := ParseCurrentPositionsReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnCurrentPositionsReject(m)
	case 301:
		m, e := ParseOrderUpdate(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnOrderUpdate(m)
	case 302:
		m, e := ParseOpenOrdersReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnOpenOrdersReject(m)
	case 304:
		m, e := ParseHistoricalOrderFillResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalOrderFillResponse(m)
	case 306:
		m, e := ParsePositionUpdate(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnPositionUpdate(m)
	case 309:
		m, e := ParseAddCorrectingOrderFill(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnAddCorrectingOrderFill(m)
	case 310:
		m, e := ParseCorrectingOrderFillResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnCorrectingOrderFillResponse(m)
	case 400:
		m, e := ParseTradeAccountsRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountsRequest(m)
	case 401:
		m, e := ParseTradeAccountResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountResponse(m)
	case 500:
		m, e := ParseExchangeListRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnExchangeListRequest(m)
	case 501:
		m, e := ParseExchangeListResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnExchangeListResponse(m)
	case 502:
		m, e := ParseSymbolsForExchangeRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSymbolsForExchangeRequest(m)
	case 503:
		m, e := ParseUnderlyingSymbolsForExchangeRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnUnderlyingSymbolsForExchangeRequest(m)
	case 504:
		m, e := ParseSymbolsForUnderlyingRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSymbolsForUnderlyingRequest(m)
	case 508:
		m, e := ParseSymbolSearchRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSymbolSearchRequest(m)
	case 506:
		m, e := ParseSecurityDefinitionForSymbolRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSecurityDefinitionForSymbolRequest(m)
	case 507:
		m, e := ParseSecurityDefinitionResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSecurityDefinitionResponse(m)
	case 509:
		m, e := ParseSecurityDefinitionReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSecurityDefinitionReject(m)
	case 601:
		m, e := ParseAccountBalanceRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnAccountBalanceRequest(m)
	case 602:
		m, e := ParseAccountBalanceReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnAccountBalanceReject(m)
	case 600:
		m, e := ParseAccountBalanceUpdate(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnAccountBalanceUpdate(m)
	case 607:
		m, e := ParseAccountBalanceAdjustment(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnAccountBalanceAdjustment(m)
	case 608:
		m, e := ParseAccountBalanceAdjustmentReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnAccountBalanceAdjustmentReject(m)
	case 609:
		m, e := ParseAccountBalanceAdjustmentComplete(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnAccountBalanceAdjustmentComplete(m)
	case 603:
		m, e := ParseHistoricalAccountBalancesRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalAccountBalancesRequest(m)
	case 604:
		m, e := ParseHistoricalAccountBalancesReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalAccountBalancesReject(m)
	case 606:
		m, e := ParseHistoricalAccountBalanceResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalAccountBalanceResponse(m)
	case 700:
		m, e := ParseUserMessage(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnUserMessage(m)
	case 701:
		m, e := ParseGeneralLogMessage(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnGeneralLogMessage(m)
	case 702:
		m, e := ParseAlertMessage(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnAlertMessage(m)
	case 703:
		m, e := ParseJournalEntryAdd(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnJournalEntryAdd(m)
	case 704:
		m, e := ParseJournalEntriesRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnJournalEntriesRequest(m)
	case 705:
		m, e := ParseJournalEntriesReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnJournalEntriesReject(m)
	case 706:
		m, e := ParseJournalEntryResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnJournalEntryResponse(m)
	case 800:
		m, e := ParseHistoricalPriceDataRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalPriceDataRequest(m)
	case 801:
		m, e := ParseHistoricalPriceDataResponseHeader(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalPriceDataResponseHeader(m)
	case 802:
		m, e := ParseHistoricalPriceDataReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalPriceDataReject(m)
	case 803:
		m, e := ParseHistoricalPriceDataRecordResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalPriceDataRecordResponse(m)
	case 804:
		m, e := ParseHistoricalPriceDataTickRecordResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalPriceDataTickRecordResponse(m)
	case 807:
		m, e := ParseHistoricalPriceDataResponseTrailer(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalPriceDataResponseTrailer(m)
	case 900:
		m, e := ParseHistoricalMarketDepthDataRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalMarketDepthDataRequest(m)
	case 901:
		m, e := ParseHistoricalMarketDepthDataResponseHeader(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalMarketDepthDataResponseHeader(m)
	case 902:
		m, e := ParseHistoricalMarketDepthDataReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalMarketDepthDataReject(m)
	case 903:
		m, e := ParseHistoricalMarketDepthDataRecordResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalMarketDepthDataRecordResponse(m)
	case 10100:
		m, e := ParseHistoricalTradesRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalTradesRequest(m)
	case 10101:
		m, e := ParseHistoricalTradesReject(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalTradesReject(m)
	case 10102:
		m, e := ParseHistoricalTradesResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnHistoricalTradesResponse(m)
	case 10104:
		m, e := ParseReplayChartData(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnReplayChartData(m)
	case 10105:
		m, e := ParseReplayChartDataPerformAction(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnReplayChartDataPerformAction(m)
	case 10106:
		m, e := ParseReplayChartDataStatus(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnReplayChartDataStatus(m)
	case 10107:
		m, e := ParseRequestNumCurrentClientConnections(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnRequestNumCurrentClientConnections(m)
	case 10108:
		m, e := ParseNumCurrentClientConnectionsResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnNumCurrentClientConnectionsResponse(m)
	case 10139:
		m, e := ParseClientDeviceUpdate(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnClientDeviceUpdate(m)
	case 10134:
		m, e := ParseInterprocessSynchronizationRemoteState(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnInterprocessSynchronizationRemoteState(m)
	case 10133:
		m, e := ParseInterprocessSynchronizationSnapshotRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnInterprocessSynchronizationSnapshotRequest(m)
	case 10137:
		m, e := ParseInterprocessSynchronizationTradeActivityRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnInterprocessSynchronizationTradeActivityRequest(m)
	case 10140:
		m, e := ParseWriteIntradayDataFileSessionValue(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnWriteIntradayDataFileSessionValue(m)
	case 10109:
		m, e := ParseSCConfigurationSynchronization(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnSCConfigurationSynchronization(m)
	case 10138:
		m, e := ParseDownloadHistoricalOrderFillAndAccountBalanceData(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnDownloadHistoricalOrderFillAndAccountBalanceData(m)
	case 10110:
		m, e := ParseTradeOrder(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeOrder(m)
	case 10112:
		m, e := ParseIndividualTradePosition(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnIndividualTradePosition(m)
	case 10113:
		m, e := ParseTradePositionConsolidated(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradePositionConsolidated(m)
	case 10114:
		m, e := ParseTradeActivityData(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeActivityData(m)
	case 10115:
		m, e := ParseTradeAccountDataRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataRequest(m)
	case 10116:
		m, e := ParseTradeAccountDataResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataResponse(m)
	case 10117:
		m, e := ParseTradeAccountDataUpdate(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataUpdate(m)
	case 10118:
		m, e := ParseTradeAccountDataDelete(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataDelete(m)
	case 10121:
		m, e := ParseTradeAccountDataSymbolLimitsResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataSymbolLimitsResponse(m)
	case 10122:
		m, e := ParseTradeAccountDataSymbolLimitsUpdate(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataSymbolLimitsUpdate(m)
	case 10119:
		m, e := ParseTradeAccountDataSymbolCommissionResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataSymbolCommissionResponse(m)
	case 10120:
		m, e := ParseTradeAccountDataSymbolCommissionUpdate(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataSymbolCommissionUpdate(m)
	case 10124:
		m, e := ParseTradeAccountDataAuthorizedUsernameResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataAuthorizedUsernameResponse(m)
	case 10125:
		m, e := ParseTradeAccountDataAuthorizedUsernameAdd(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataAuthorizedUsernameAdd(m)
	case 10126:
		m, e := ParseTradeAccountDataAuthorizedUsernameRemove(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataAuthorizedUsernameRemove(m)
	case 10127:
		m, e := ParseTradeAccountDataUsernameToShareWithResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataUsernameToShareWithResponse(m)
	case 10128:
		m, e := ParseTradeAccountDataUsernameToShareWithAdd(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataUsernameToShareWithAdd(m)
	case 10129:
		m, e := ParseTradeAccountDataUsernameToShareWithRemove(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataUsernameToShareWithRemove(m)
	case 10130:
		m, e := ParseTradeAccountDataResponseTrailer(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataResponseTrailer(m)
	case 10131:
		m, e := ParseTradeAccountDataUpdateOperationComplete(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnTradeAccountDataUpdateOperationComplete(m)
	case 10132:
		m, e := ParseProcessedFillIdentifier(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnProcessedFillIdentifier(m)
	case 210:
		m, e := ParseFlattenPositionsForTradeAccount(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnFlattenPositionsForTradeAccount(m)
	case 10136:
		m, e := ParseUserInformation(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnUserInformation(m)
	case 10141:
		m, e := ParseMarginDataRequest(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarginDataRequest(m)
	case 10142:
		m, e := ParseMarginDataResponse(b)
		if e != nil {
			h.OnError(b, t, e)
			return e
		}
		return h.OnMarginDataResponse(m)
	default:
		return h.OnUnknown(b, t)
	}
}
