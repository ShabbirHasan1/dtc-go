// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-31 22:08:18.145964 +0800 WITA m=+0.011497918

package v8

import (
	"github.com/moontrade/dtc-go/message"
	"github.com/moontrade/dtc-go/message/json"
	"io"
)

const SecurityDefinitionResponseSize = 152

const SecurityDefinitionResponseFixedSize = 432

//     Size                          uint16                  = SecurityDefinitionResponseSize  (152)
//     Type                          uint16                  = SECURITY_DEFINITION_RESPONSE  (507)
//     BaseSize                      uint16                  = SecurityDefinitionResponseSize  (152)
//     RequestID                     int32                   = 0
//     Symbol                        string                  = ""
//     Exchange                      string                  = ""
//     SecurityType                  SecurityTypeEnum        = SECURITY_TYPE_UNSET  (0)
//     Description                   string                  = ""
//     MinPriceIncrement             float32                 = 0.000000
//     PriceDisplayFormat            PriceDisplayFormatEnum  = PRICE_DISPLAY_FORMAT_DECIMAL_0  (0)
//     CurrencyValuePerIncrement     float32                 = 0.000000
//     IsFinalMessage                bool                    = false
//     FloatToIntPriceMultiplier     float32                 = 1.000000
//     IntToFloatPriceDivisor        float32                 = 1.000000
//     UnderlyingSymbol              string                  = ""
//     UpdatesBidAskOnly             uint8                   = 0
//     StrikePrice                   float32                 = 0.000000
//     PutOrCall                     PutCallEnum             = PC_UNSET  (0)
//     ShortInterest                 uint32                  = 0
//     SecurityExpirationDate        DateTime4Byte           = 0
//     BuyRolloverInterest           float32                 = 0.000000
//     SellRolloverInterest          float32                 = 0.000000
//     EarningsPerShare              float32                 = 0.000000
//     SharesOutstanding             uint32                  = 0
//     IntToFloatQuantityDivisor     float32                 = 0.000000
//     HasMarketDepthData            uint8                   = 0
//     DisplayPriceMultiplier        float32                 = 1.000000
//     ExchangeSymbol                string                  = ""
//     InitialMarginRequirement      float32                 = 0.000000
//     MaintenanceMarginRequirement  float32                 = 0.000000
//     Currency                      string                  = ""
//     ContractSize                  float32                 = 0.000000
//     OpenInterest                  uint32                  = 0
//     RolloverDate                  DateTime4Byte           = 0
//     IsDelayed                     bool                    = false
//     SecurityIdentifier            int64                   = 0
//     ProductIdentifier             string                  = ""
var _SecurityDefinitionResponseDefault = []byte{152, 0, 251, 1, 152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

//     Size                          uint16                  = SecurityDefinitionResponseFixedSize  (432)
//     Type                          uint16                  = SECURITY_DEFINITION_RESPONSE  (507)
//     RequestID                     int32                   = 0
//     Symbol                        string[64]              = ""
//     Exchange                      string[16]              = ""
//     SecurityType                  SecurityTypeEnum        = SECURITY_TYPE_UNSET  (0)
//     Description                   string[64]              = ""
//     MinPriceIncrement             float32                 = 0.000000
//     PriceDisplayFormat            PriceDisplayFormatEnum  = PRICE_DISPLAY_FORMAT_UNSET  (-1)
//     CurrencyValuePerIncrement     float32                 = 0.000000
//     IsFinalMessage                bool                    = false
//     FloatToIntPriceMultiplier     float32                 = 1.000000
//     IntToFloatPriceDivisor        float32                 = 1.000000
//     UnderlyingSymbol              string[32]              = ""
//     UpdatesBidAskOnly             uint8                   = 0
//     StrikePrice                   float32                 = 0.000000
//     PutOrCall                     PutCallEnum             = PC_UNSET  (0)
//     ShortInterest                 uint32                  = 0
//     SecurityExpirationDate        DateTime4Byte           = 0
//     BuyRolloverInterest           float32                 = 0.000000
//     SellRolloverInterest          float32                 = 0.000000
//     EarningsPerShare              float32                 = 0.000000
//     SharesOutstanding             uint32                  = 0
//     IntToFloatQuantityDivisor     float32                 = 0.000000
//     HasMarketDepthData            uint8                   = 0
//     DisplayPriceMultiplier        float32                 = 1.000000
//     ExchangeSymbol                string[64]              = ""
//     InitialMarginRequirement      float32                 = 0.000000
//     MaintenanceMarginRequirement  float32                 = 0.000000
//     Currency                      string[8]               = ""
//     ContractSize                  float32                 = 0.000000
//     OpenInterest                  uint32                  = 0
//     RolloverDate                  DateTime4Byte           = 0
//     IsDelayed                     bool                    = false
//     SecurityIdentifier            int64                   = 0
//     ProductIdentifier             string[64]              = ""
var _SecurityDefinitionResponseFixedDefault = []byte{176, 1, 251, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

// SecurityDefinitionResponse This is a response from the Server in response to a SymbolsForExchangeRequest,
// UNDERLYING_SymbolsForExchangeRequest, SymbolsForUnderlyingRequest, SecurityDefinitionForSymbolRequest,
// SymbolSearchRequest message.
//
// If there are no symbols to return in response to a request, the Server
// needs to send through one of these messages with the RequestID set to
// the same RequestID value that the request message set it to, and IsFinalMessage
// = 1. Leave all other member fields in the default state and the Client
// will recognize there are no symbols.
//
// The Client must always send a SecurityDefinitionForSymbolRequest message
// to the Server to obtain the IntegerToFloatPriceDivisor and FloatToIntPriceMultiplier
// values in the Security Definition Response message when the Server uses
// the integer market data and order messages.
type SecurityDefinitionResponse struct {
	p message.VLS
}

// SecurityDefinitionResponseFixed This is a response from the Server in response to a SymbolsForExchangeRequest,
// UNDERLYING_SymbolsForExchangeRequest, SymbolsForUnderlyingRequest, SecurityDefinitionForSymbolRequest,
// SymbolSearchRequest message.
//
// If there are no symbols to return in response to a request, the Server
// needs to send through one of these messages with the RequestID set to
// the same RequestID value that the request message set it to, and IsFinalMessage
// = 1. Leave all other member fields in the default state and the Client
// will recognize there are no symbols.
//
// The Client must always send a SecurityDefinitionForSymbolRequest message
// to the Server to obtain the IntegerToFloatPriceDivisor and FloatToIntPriceMultiplier
// values in the Security Definition Response message when the Server uses
// the integer market data and order messages.
type SecurityDefinitionResponseFixed struct {
	p message.Fixed
}

func NewSecurityDefinitionResponseFrom(b []byte) SecurityDefinitionResponse {
	return SecurityDefinitionResponse{p: message.NewVLS(b)}
}

func WrapSecurityDefinitionResponse(b []byte) SecurityDefinitionResponse {
	return SecurityDefinitionResponse{p: message.WrapVLS(b)}
}

func NewSecurityDefinitionResponse() *SecurityDefinitionResponse {
	return &SecurityDefinitionResponse{p: message.NewVLS(_SecurityDefinitionResponseDefault)}
}

func ParseSecurityDefinitionResponse(b []byte) (SecurityDefinitionResponse, error) {
	if len(b) < 6 {
		return SecurityDefinitionResponse{}, message.ErrShortBuffer
	}
	m := WrapSecurityDefinitionResponse(b)
	if int(m.p.AsUint16LE()) != len(b) {
		return SecurityDefinitionResponse{}, message.ErrOverflow
	}
	baseSize := int(m.p.Uint16LE(4))
	if baseSize > len(b) {
		return SecurityDefinitionResponse{}, message.ErrBaseSizeOverflow
	}
	if baseSize < 152 {
		newSize := len(b) + (152 - baseSize)
		if newSize > message.MaxSize {
			return SecurityDefinitionResponse{}, message.ErrOverflow
		}
		clone := SecurityDefinitionResponse{message.WrapVLSUnsafe(message.Alloc(uintptr(newSize)), len(b))}
		clone.p.SetBytes(0, b[0:baseSize])
		clone.p.SetBytes(baseSize, _SecurityDefinitionResponseDefault[baseSize:])
		if len(b) > baseSize {
			shift := uint16(152 - baseSize)
			var offset uint16
			offset = clone.p.Uint16LE(12)
			if offset > 0 {
				clone.p.SetUint16LE(12, offset+shift)
			}
			offset = clone.p.Uint16LE(16)
			if offset > 0 {
				clone.p.SetUint16LE(16, offset+shift)
			}
			offset = clone.p.Uint16LE(24)
			if offset > 0 {
				clone.p.SetUint16LE(24, offset+shift)
			}
			offset = clone.p.Uint16LE(52)
			if offset > 0 {
				clone.p.SetUint16LE(52, offset+shift)
			}
			offset = clone.p.Uint16LE(104)
			if offset > 0 {
				clone.p.SetUint16LE(104, offset+shift)
			}
			offset = clone.p.Uint16LE(116)
			if offset > 0 {
				clone.p.SetUint16LE(116, offset+shift)
			}
			offset = clone.p.Uint16LE(144)
			if offset > 0 {
				clone.p.SetUint16LE(144, offset+shift)
			}
		}
		return clone, nil
	}
	return m, nil
}

func NewSecurityDefinitionResponseFixedFrom(b []byte) SecurityDefinitionResponseFixed {
	return SecurityDefinitionResponseFixed{p: message.NewFixed(b)}
}

func WrapSecurityDefinitionResponseFixed(b []byte) SecurityDefinitionResponseFixed {
	return SecurityDefinitionResponseFixed{p: message.WrapFixed(b)}
}

func NewSecurityDefinitionResponseFixed() *SecurityDefinitionResponseFixed {
	return &SecurityDefinitionResponseFixed{p: message.NewFixed(_SecurityDefinitionResponseFixedDefault)}
}

func ParseSecurityDefinitionResponseFixed(b []byte) (SecurityDefinitionResponseFixed, error) {
	if len(b) < 4 {
		return SecurityDefinitionResponseFixed{}, message.ErrShortBuffer
	}
	m := WrapSecurityDefinitionResponseFixed(b)
	if int(m.p.AsUint16LE()) != len(b) {
		return SecurityDefinitionResponseFixed{}, message.ErrOverflow
	}
	size := int(m.p.AsUint16LE())
	if size > len(b) {
		return SecurityDefinitionResponseFixed{}, message.ErrBaseSizeOverflow
	}
	if size < 432 {
		clone := *NewSecurityDefinitionResponseFixed()
		clone.p.SetBytes(0, b[0:size])
		clone.p.SetBytes(size, _SecurityDefinitionResponseFixedDefault[size:])
		return clone, nil
	}
	return m, nil
}

// Size The standard message size field. Automatically set by constructor.
func (m SecurityDefinitionResponse) Size() uint16 {
	return m.p.Uint16LE(0)
}

// Type The standard message type field. Automatically set by constructor.
func (m SecurityDefinitionResponse) Type() uint16 {
	return m.p.Uint16LE(2)
}

// BaseSize
func (m SecurityDefinitionResponse) BaseSize() uint16 {
	return m.p.Uint16LE(4)
}

// RequestID This is the same RequestID that this message is in response to and was
// given in the original Security Definition request message.
func (m SecurityDefinitionResponse) RequestID() int32 {
	return m.p.Int32LE(8)
}

// Symbol This is the Symbol the Security Definition is for.
//
// When the Server responds with a single SecurityDefinitionResponse message
// and there are no security definitions to return for the original request,
// this will be empty.
//
// This field should be empty when this Security Definition message is in
// response to UnderlyingSymbolsForExchangeRequest.
func (m SecurityDefinitionResponse) Symbol() string {
	return m.p.StringVLS(12)
}

// Exchange This is the Exchange for the Symbol. This field is optional.
func (m SecurityDefinitionResponse) Exchange() string {
	return m.p.StringVLS(16)
}

// SecurityType The Security Type for the symbol.
func (m SecurityDefinitionResponse) SecurityType() SecurityTypeEnum {
	return SecurityTypeEnum(m.p.Int32LE(20))
}

// Description The text description for the Symbol.
func (m SecurityDefinitionResponse) Description() string {
	return m.p.StringVLS(24)
}

// MinPriceIncrement The minimum amount that prices can change by for the Symbol and minimum
// amount that prices are quoted in.
func (m SecurityDefinitionResponse) MinPriceIncrement() float32 {
	return m.p.Float32LE(28)
}

// PriceDisplayFormat This field specifies the price formatting for display purposes.
func (m SecurityDefinitionResponse) PriceDisplayFormat() PriceDisplayFormatEnum {
	return PriceDisplayFormatEnum(m.p.Int32LE(32))
}

// CurrencyValuePerIncrement This field is the currency value per MinPriceIncrement in the Symbols
// currency.
func (m SecurityDefinitionResponse) CurrencyValuePerIncrement() float32 {
	return m.p.Float32LE(36)
}

// IsFinalMessage Set to a integer value of 1 to indicate this is the final message in batch
// of Security Definition Response messages.
func (m SecurityDefinitionResponse) IsFinalMessage() bool {
	return m.p.Bool(40)
}

// FloatToIntPriceMultiplier With the integer order entry messages discontinued as of August 2020,
// this field is no longer relevant.
func (m SecurityDefinitionResponse) FloatToIntPriceMultiplier() float32 {
	return m.p.Float32LE(44)
}

// IntToFloatPriceDivisor
func (m SecurityDefinitionResponse) IntToFloatPriceDivisor() float32 {
	return m.p.Float32LE(48)
}

// UnderlyingSymbol This is the underlying symbol for the Symbol field if the Symbol has an
// underlying symbol.
//
// The Server must set this when the SecurityDefinitionResponse message in
// response to UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest.
// response to UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest.
//
// This is typically used with futures. A futures symbol for a specific contract
// year and month will have an underlying symbol equivalent to the Symbol
// without the year and month characters.
func (m SecurityDefinitionResponse) UnderlyingSymbol() string {
	return m.p.StringVLS(52)
}

// UpdatesBidAskOnly This is set to 1 when the Symbol does not provide MarketDataUpdateTrade
// messages and only provides MarketDataUpdateBidAsk messages when there
// is market activity for the Symbol.
//
// Otherwise, when this is set to 0, MarketDataUpdateTrade messages will
// be received after subscribing to market data, when there is trading activity.
// be received after subscribing to market data, when there is trading activity.
func (m SecurityDefinitionResponse) UpdatesBidAskOnly() uint8 {
	return m.p.Uint8(56)
}

// StrikePrice The strike price when the Security Type is an option type.
func (m SecurityDefinitionResponse) StrikePrice() float32 {
	return m.p.Float32LE(60)
}

// PutOrCall When the Security Type is an option, this indicates if it is a put or
// call.
func (m SecurityDefinitionResponse) PutOrCall() PutCallEnum {
	return PutCallEnum(m.p.Uint8(64))
}

// ShortInterest The short interest when the Security Type is a stock.
func (m SecurityDefinitionResponse) ShortInterest() uint32 {
	return m.p.Uint32LE(68)
}

// SecurityExpirationDate The expiration date for the Symbol for symbols which have an expiration
// date.
func (m SecurityDefinitionResponse) SecurityExpirationDate() DateTime4Byte {
	return DateTime4Byte(m.p.Uint32LE(72))
}

// BuyRolloverInterest The daily interest amount which is deducted for a Buy position. This only
// applies for Forex trading. It is in the quote currency of the symbol.
func (m SecurityDefinitionResponse) BuyRolloverInterest() float32 {
	return m.p.Float32LE(76)
}

// SellRolloverInterest The daily interest amount which is deducted for a Sell position. This
// only applies for Forex trading. It is in the quote currency of the symbol.
// only applies for Forex trading. It is in the quote currency of the symbol.
func (m SecurityDefinitionResponse) SellRolloverInterest() float32 {
	return m.p.Float32LE(80)
}

// EarningsPerShare The earnings per share as a currency value when the Security Type is a
// stock.
func (m SecurityDefinitionResponse) EarningsPerShare() float32 {
	return m.p.Float32LE(84)
}

// SharesOutstanding This is the number of shares outstanding for stocks.
func (m SecurityDefinitionResponse) SharesOutstanding() uint32 {
	return m.p.Uint32LE(88)
}

// IntToFloatQuantityDivisor With the integer order entry and market data messages discontinued as
// of August 2020, this field is no longer relevant.
func (m SecurityDefinitionResponse) IntToFloatQuantityDivisor() float32 {
	return m.p.Float32LE(92)
}

// HasMarketDepthData When HasMarketDepthData is set to 1, it indicates the Symbol has market
// depth data available for it. When this is set to 0, market depth data
// is not supported for the Symbol.
func (m SecurityDefinitionResponse) HasMarketDepthData() uint8 {
	return m.p.Uint8(96)
}

// DisplayPriceMultiplier This is an optional field for the Server to set.
//
// The default for this is 1.0.
//
// This sets the multiplier to use in the case where the Client should multiply
// the values in market data messages by some number other than 1.0 before
// displaying them to the user.
//
// It is recommended that a Server does not use this and instead transmit
// to the Client values as the actual floating-point values.
//
// This should not be confused with the integer market data messages and
// the IntToFloatPriceDivisor field used with those messages. DisplayPriceMultiplier
// is for when the Server transmits market data values using floating-point
// types and where those values may have a fractional component, but where
// it is necessary to still multiply the original value by this multiplier
// to get the final value to display to the user.
//
// When this is set to a value other than 1.0, then the MinPriceIncrement
// and the PriceDisplayFormat fields are relative to the market data values
// after the DisplayPriceMultiplier is applied.
func (m SecurityDefinitionResponse) DisplayPriceMultiplier() float32 {
	return m.p.Float32LE(100)
}

// ExchangeSymbol This is an optional field. This is the exchange symbol which corresponds
// with the Symbol field.
//
// This field should be empty when this Security Definition message is in
// response to UNDERLYING_SymbolsForExchangeRequest.
func (m SecurityDefinitionResponse) ExchangeSymbol() string {
	return m.p.StringVLS(104)
}

// InitialMarginRequirement This field applies to the Futures Security Type.
//
// This is the initial margin requirement as specified by the exchange, if
// available.
func (m SecurityDefinitionResponse) InitialMarginRequirement() float32 {
	return m.p.Float32LE(108)
}

// MaintenanceMarginRequirement This field applies to the Futures Security Type.
//
// This is the maintenance margin requirement as specified by the exchange,
// if available.
func (m SecurityDefinitionResponse) MaintenanceMarginRequirement() float32 {
	return m.p.Float32LE(112)
}

// Currency This is the currency that the Symbol trades in or is priced in.
func (m SecurityDefinitionResponse) Currency() string {
	return m.p.StringVLS(116)
}

// ContractSize In the case of when a Symbol is a contract type, this variable indicates
// the size of the contract.
//
// This is going to be an exchange specific specification.
func (m SecurityDefinitionResponse) ContractSize() float32 {
	return m.p.Float32LE(120)
}

// OpenInterest In the case of when a Symbol is a contract type, this field is the number
// of outstanding contracts.
func (m SecurityDefinitionResponse) OpenInterest() uint32 {
	return m.p.Uint32LE(124)
}

// RolloverDate This field applies to the Futures Security Type.
//
// This is the rollover date for the symbol according to the typical time
// where trading transitions from one contract month to the next.
func (m SecurityDefinitionResponse) RolloverDate() DateTime4Byte {
	return DateTime4Byte(m.p.Uint32LE(128))
}

// IsDelayed This field will be 1 if the market data for the Symbol is intentionally
// delayed by a certain amount of time. Otherwise, this will be 0.
func (m SecurityDefinitionResponse) IsDelayed() bool {
	return m.p.Bool(132)
}

// SecurityIdentifier
func (m SecurityDefinitionResponse) SecurityIdentifier() int64 {
	return m.p.Int64LE(136)
}

// ProductIdentifier
func (m SecurityDefinitionResponse) ProductIdentifier() string {
	return m.p.StringVLS(144)
}

// Size The standard message size field. Automatically set by constructor.
func (m SecurityDefinitionResponseFixed) Size() uint16 {
	return m.p.Uint16LE(0)
}

// Type The standard message type field. Automatically set by constructor.
func (m SecurityDefinitionResponseFixed) Type() uint16 {
	return m.p.Uint16LE(2)
}

// RequestID This is the same RequestID that this message is in response to and was
// given in the original Security Definition request message.
func (m SecurityDefinitionResponseFixed) RequestID() int32 {
	return m.p.Int32LE(4)
}

// Symbol This is the Symbol the Security Definition is for.
//
// When the Server responds with a single SecurityDefinitionResponse message
// and there are no security definitions to return for the original request,
// this will be empty.
//
// This field should be empty when this Security Definition message is in
// response to UnderlyingSymbolsForExchangeRequest.
func (m SecurityDefinitionResponseFixed) Symbol() string {
	return m.p.StringFixed(8, 64)
}

// Exchange This is the Exchange for the Symbol. This field is optional.
func (m SecurityDefinitionResponseFixed) Exchange() string {
	return m.p.StringFixed(72, 16)
}

// SecurityType The Security Type for the symbol.
func (m SecurityDefinitionResponseFixed) SecurityType() SecurityTypeEnum {
	return SecurityTypeEnum(m.p.Int32LE(88))
}

// Description The text description for the Symbol.
func (m SecurityDefinitionResponseFixed) Description() string {
	return m.p.StringFixed(92, 64)
}

// MinPriceIncrement The minimum amount that prices can change by for the Symbol and minimum
// amount that prices are quoted in.
func (m SecurityDefinitionResponseFixed) MinPriceIncrement() float32 {
	return m.p.Float32LE(156)
}

// PriceDisplayFormat This field specifies the price formatting for display purposes.
func (m SecurityDefinitionResponseFixed) PriceDisplayFormat() PriceDisplayFormatEnum {
	return PriceDisplayFormatEnum(m.p.Int32LE(160))
}

// CurrencyValuePerIncrement This field is the currency value per MinPriceIncrement in the Symbols
// currency.
func (m SecurityDefinitionResponseFixed) CurrencyValuePerIncrement() float32 {
	return m.p.Float32LE(164)
}

// IsFinalMessage Set to a integer value of 1 to indicate this is the final message in batch
// of Security Definition Response messages.
func (m SecurityDefinitionResponseFixed) IsFinalMessage() bool {
	return m.p.Bool(168)
}

// FloatToIntPriceMultiplier With the integer order entry messages discontinued as of August 2020,
// this field is no longer relevant.
func (m SecurityDefinitionResponseFixed) FloatToIntPriceMultiplier() float32 {
	return m.p.Float32LE(172)
}

// IntToFloatPriceDivisor
func (m SecurityDefinitionResponseFixed) IntToFloatPriceDivisor() float32 {
	return m.p.Float32LE(176)
}

// UnderlyingSymbol This is the underlying symbol for the Symbol field if the Symbol has an
// underlying symbol.
//
// The Server must set this when the SecurityDefinitionResponse message in
// response to UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest.
// response to UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest.
//
// This is typically used with futures. A futures symbol for a specific contract
// year and month will have an underlying symbol equivalent to the Symbol
// without the year and month characters.
func (m SecurityDefinitionResponseFixed) UnderlyingSymbol() string {
	return m.p.StringFixed(180, 32)
}

// UpdatesBidAskOnly This is set to 1 when the Symbol does not provide MarketDataUpdateTrade
// messages and only provides MarketDataUpdateBidAsk messages when there
// is market activity for the Symbol.
//
// Otherwise, when this is set to 0, MarketDataUpdateTrade messages will
// be received after subscribing to market data, when there is trading activity.
// be received after subscribing to market data, when there is trading activity.
func (m SecurityDefinitionResponseFixed) UpdatesBidAskOnly() uint8 {
	return m.p.Uint8(212)
}

// StrikePrice The strike price when the Security Type is an option type.
func (m SecurityDefinitionResponseFixed) StrikePrice() float32 {
	return m.p.Float32LE(216)
}

// PutOrCall When the Security Type is an option, this indicates if it is a put or
// call.
func (m SecurityDefinitionResponseFixed) PutOrCall() PutCallEnum {
	return PutCallEnum(m.p.Uint8(220))
}

// ShortInterest The short interest when the Security Type is a stock.
func (m SecurityDefinitionResponseFixed) ShortInterest() uint32 {
	return m.p.Uint32LE(224)
}

// SecurityExpirationDate The expiration date for the Symbol for symbols which have an expiration
// date.
func (m SecurityDefinitionResponseFixed) SecurityExpirationDate() DateTime4Byte {
	return DateTime4Byte(m.p.Uint32LE(228))
}

// BuyRolloverInterest The daily interest amount which is deducted for a Buy position. This only
// applies for Forex trading. It is in the quote currency of the symbol.
func (m SecurityDefinitionResponseFixed) BuyRolloverInterest() float32 {
	return m.p.Float32LE(232)
}

// SellRolloverInterest The daily interest amount which is deducted for a Sell position. This
// only applies for Forex trading. It is in the quote currency of the symbol.
// only applies for Forex trading. It is in the quote currency of the symbol.
func (m SecurityDefinitionResponseFixed) SellRolloverInterest() float32 {
	return m.p.Float32LE(236)
}

// EarningsPerShare The earnings per share as a currency value when the Security Type is a
// stock.
func (m SecurityDefinitionResponseFixed) EarningsPerShare() float32 {
	return m.p.Float32LE(240)
}

// SharesOutstanding This is the number of shares outstanding for stocks.
func (m SecurityDefinitionResponseFixed) SharesOutstanding() uint32 {
	return m.p.Uint32LE(244)
}

// IntToFloatQuantityDivisor With the integer order entry and market data messages discontinued as
// of August 2020, this field is no longer relevant.
func (m SecurityDefinitionResponseFixed) IntToFloatQuantityDivisor() float32 {
	return m.p.Float32LE(248)
}

// HasMarketDepthData When HasMarketDepthData is set to 1, it indicates the Symbol has market
// depth data available for it. When this is set to 0, market depth data
// is not supported for the Symbol.
func (m SecurityDefinitionResponseFixed) HasMarketDepthData() uint8 {
	return m.p.Uint8(252)
}

// DisplayPriceMultiplier This is an optional field for the Server to set.
//
// The default for this is 1.0.
//
// This sets the multiplier to use in the case where the Client should multiply
// the values in market data messages by some number other than 1.0 before
// displaying them to the user.
//
// It is recommended that a Server does not use this and instead transmit
// to the Client values as the actual floating-point values.
//
// This should not be confused with the integer market data messages and
// the IntToFloatPriceDivisor field used with those messages. DisplayPriceMultiplier
// is for when the Server transmits market data values using floating-point
// types and where those values may have a fractional component, but where
// it is necessary to still multiply the original value by this multiplier
// to get the final value to display to the user.
//
// When this is set to a value other than 1.0, then the MinPriceIncrement
// and the PriceDisplayFormat fields are relative to the market data values
// after the DisplayPriceMultiplier is applied.
func (m SecurityDefinitionResponseFixed) DisplayPriceMultiplier() float32 {
	return m.p.Float32LE(256)
}

// ExchangeSymbol This is an optional field. This is the exchange symbol which corresponds
// with the Symbol field.
//
// This field should be empty when this Security Definition message is in
// response to UNDERLYING_SymbolsForExchangeRequest.
func (m SecurityDefinitionResponseFixed) ExchangeSymbol() string {
	return m.p.StringFixed(260, 64)
}

// InitialMarginRequirement This field applies to the Futures Security Type.
//
// This is the initial margin requirement as specified by the exchange, if
// available.
func (m SecurityDefinitionResponseFixed) InitialMarginRequirement() float32 {
	return m.p.Float32LE(324)
}

// MaintenanceMarginRequirement This field applies to the Futures Security Type.
//
// This is the maintenance margin requirement as specified by the exchange,
// if available.
func (m SecurityDefinitionResponseFixed) MaintenanceMarginRequirement() float32 {
	return m.p.Float32LE(328)
}

// Currency This is the currency that the Symbol trades in or is priced in.
func (m SecurityDefinitionResponseFixed) Currency() string {
	return m.p.StringFixed(332, 8)
}

// ContractSize In the case of when a Symbol is a contract type, this variable indicates
// the size of the contract.
//
// This is going to be an exchange specific specification.
func (m SecurityDefinitionResponseFixed) ContractSize() float32 {
	return m.p.Float32LE(340)
}

// OpenInterest In the case of when a Symbol is a contract type, this field is the number
// of outstanding contracts.
func (m SecurityDefinitionResponseFixed) OpenInterest() uint32 {
	return m.p.Uint32LE(344)
}

// RolloverDate This field applies to the Futures Security Type.
//
// This is the rollover date for the symbol according to the typical time
// where trading transitions from one contract month to the next.
func (m SecurityDefinitionResponseFixed) RolloverDate() DateTime4Byte {
	return DateTime4Byte(m.p.Uint32LE(348))
}

// IsDelayed This field will be 1 if the market data for the Symbol is intentionally
// delayed by a certain amount of time. Otherwise, this will be 0.
func (m SecurityDefinitionResponseFixed) IsDelayed() bool {
	return m.p.Bool(352)
}

// SecurityIdentifier
func (m SecurityDefinitionResponseFixed) SecurityIdentifier() int64 {
	return m.p.Int64LE(360)
}

// ProductIdentifier
func (m SecurityDefinitionResponseFixed) ProductIdentifier() string {
	return m.p.StringFixed(368, 64)
}

// SetRequestID This is the same RequestID that this message is in response to and was
// given in the original Security Definition request message.
func (m *SecurityDefinitionResponse) SetRequestID(value int32) *SecurityDefinitionResponse {
	m.p.SetInt32LE(8, value)
	return m
}

// SetSymbol This is the Symbol the Security Definition is for.
//
// When the Server responds with a single SecurityDefinitionResponse message
// and there are no security definitions to return for the original request,
// this will be empty.
//
// This field should be empty when this Security Definition message is in
// response to UnderlyingSymbolsForExchangeRequest.
func (m *SecurityDefinitionResponse) SetSymbol(value string) *SecurityDefinitionResponse {
	m.p.SetStringVLS(12, value)
	return m
}

// SetExchange This is the Exchange for the Symbol. This field is optional.
func (m *SecurityDefinitionResponse) SetExchange(value string) *SecurityDefinitionResponse {
	m.p.SetStringVLS(16, value)
	return m
}

// SetSecurityType The Security Type for the symbol.
func (m *SecurityDefinitionResponse) SetSecurityType(value SecurityTypeEnum) *SecurityDefinitionResponse {
	m.p.SetInt32LE(20, int32(value))
	return m
}

// SetDescription The text description for the Symbol.
func (m *SecurityDefinitionResponse) SetDescription(value string) *SecurityDefinitionResponse {
	m.p.SetStringVLS(24, value)
	return m
}

// SetMinPriceIncrement The minimum amount that prices can change by for the Symbol and minimum
// amount that prices are quoted in.
func (m *SecurityDefinitionResponse) SetMinPriceIncrement(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(28, value)
	return m
}

// SetPriceDisplayFormat This field specifies the price formatting for display purposes.
func (m *SecurityDefinitionResponse) SetPriceDisplayFormat(value PriceDisplayFormatEnum) *SecurityDefinitionResponse {
	m.p.SetInt32LE(32, int32(value))
	return m
}

// SetCurrencyValuePerIncrement This field is the currency value per MinPriceIncrement in the Symbols
// currency.
func (m *SecurityDefinitionResponse) SetCurrencyValuePerIncrement(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(36, value)
	return m
}

// SetIsFinalMessage Set to a integer value of 1 to indicate this is the final message in batch
// of Security Definition Response messages.
func (m *SecurityDefinitionResponse) SetIsFinalMessage(value bool) *SecurityDefinitionResponse {
	m.p.SetBool(40, value)
	return m
}

// SetFloatToIntPriceMultiplier With the integer order entry messages discontinued as of August 2020,
// this field is no longer relevant.
func (m *SecurityDefinitionResponse) SetFloatToIntPriceMultiplier(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(44, value)
	return m
}

// SetIntToFloatPriceDivisor
func (m *SecurityDefinitionResponse) SetIntToFloatPriceDivisor(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(48, value)
	return m
}

// SetUnderlyingSymbol This is the underlying symbol for the Symbol field if the Symbol has an
// underlying symbol.
//
// The Server must set this when the SecurityDefinitionResponse message in
// response to UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest.
// response to UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest.
//
// This is typically used with futures. A futures symbol for a specific contract
// year and month will have an underlying symbol equivalent to the Symbol
// without the year and month characters.
func (m *SecurityDefinitionResponse) SetUnderlyingSymbol(value string) *SecurityDefinitionResponse {
	m.p.SetStringVLS(52, value)
	return m
}

// SetUpdatesBidAskOnly This is set to 1 when the Symbol does not provide MarketDataUpdateTrade
// messages and only provides MarketDataUpdateBidAsk messages when there
// is market activity for the Symbol.
//
// Otherwise, when this is set to 0, MarketDataUpdateTrade messages will
// be received after subscribing to market data, when there is trading activity.
// be received after subscribing to market data, when there is trading activity.
func (m *SecurityDefinitionResponse) SetUpdatesBidAskOnly(value uint8) *SecurityDefinitionResponse {
	m.p.SetUint8(56, value)
	return m
}

// SetStrikePrice The strike price when the Security Type is an option type.
func (m *SecurityDefinitionResponse) SetStrikePrice(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(60, value)
	return m
}

// SetPutOrCall When the Security Type is an option, this indicates if it is a put or
// call.
func (m *SecurityDefinitionResponse) SetPutOrCall(value PutCallEnum) *SecurityDefinitionResponse {
	m.p.SetUint8(64, uint8(value))
	return m
}

// SetShortInterest The short interest when the Security Type is a stock.
func (m *SecurityDefinitionResponse) SetShortInterest(value uint32) *SecurityDefinitionResponse {
	m.p.SetUint32LE(68, value)
	return m
}

// SetSecurityExpirationDate The expiration date for the Symbol for symbols which have an expiration
// date.
func (m *SecurityDefinitionResponse) SetSecurityExpirationDate(value DateTime4Byte) *SecurityDefinitionResponse {
	m.p.SetUint32LE(72, uint32(value))
	return m
}

// SetBuyRolloverInterest The daily interest amount which is deducted for a Buy position. This only
// applies for Forex trading. It is in the quote currency of the symbol.
func (m *SecurityDefinitionResponse) SetBuyRolloverInterest(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(76, value)
	return m
}

// SetSellRolloverInterest The daily interest amount which is deducted for a Sell position. This
// only applies for Forex trading. It is in the quote currency of the symbol.
// only applies for Forex trading. It is in the quote currency of the symbol.
func (m *SecurityDefinitionResponse) SetSellRolloverInterest(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(80, value)
	return m
}

// SetEarningsPerShare The earnings per share as a currency value when the Security Type is a
// stock.
func (m *SecurityDefinitionResponse) SetEarningsPerShare(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(84, value)
	return m
}

// SetSharesOutstanding This is the number of shares outstanding for stocks.
func (m *SecurityDefinitionResponse) SetSharesOutstanding(value uint32) *SecurityDefinitionResponse {
	m.p.SetUint32LE(88, value)
	return m
}

// SetIntToFloatQuantityDivisor With the integer order entry and market data messages discontinued as
// of August 2020, this field is no longer relevant.
func (m *SecurityDefinitionResponse) SetIntToFloatQuantityDivisor(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(92, value)
	return m
}

// SetHasMarketDepthData When HasMarketDepthData is set to 1, it indicates the Symbol has market
// depth data available for it. When this is set to 0, market depth data
// is not supported for the Symbol.
func (m *SecurityDefinitionResponse) SetHasMarketDepthData(value uint8) *SecurityDefinitionResponse {
	m.p.SetUint8(96, value)
	return m
}

// SetDisplayPriceMultiplier This is an optional field for the Server to set.
//
// The default for this is 1.0.
//
// This sets the multiplier to use in the case where the Client should multiply
// the values in market data messages by some number other than 1.0 before
// displaying them to the user.
//
// It is recommended that a Server does not use this and instead transmit
// to the Client values as the actual floating-point values.
//
// This should not be confused with the integer market data messages and
// the IntToFloatPriceDivisor field used with those messages. DisplayPriceMultiplier
// is for when the Server transmits market data values using floating-point
// types and where those values may have a fractional component, but where
// it is necessary to still multiply the original value by this multiplier
// to get the final value to display to the user.
//
// When this is set to a value other than 1.0, then the MinPriceIncrement
// and the PriceDisplayFormat fields are relative to the market data values
// after the DisplayPriceMultiplier is applied.
func (m *SecurityDefinitionResponse) SetDisplayPriceMultiplier(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(100, value)
	return m
}

// SetExchangeSymbol This is an optional field. This is the exchange symbol which corresponds
// with the Symbol field.
//
// This field should be empty when this Security Definition message is in
// response to UNDERLYING_SymbolsForExchangeRequest.
func (m *SecurityDefinitionResponse) SetExchangeSymbol(value string) *SecurityDefinitionResponse {
	m.p.SetStringVLS(104, value)
	return m
}

// SetInitialMarginRequirement This field applies to the Futures Security Type.
//
// This is the initial margin requirement as specified by the exchange, if
// available.
func (m *SecurityDefinitionResponse) SetInitialMarginRequirement(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(108, value)
	return m
}

// SetMaintenanceMarginRequirement This field applies to the Futures Security Type.
//
// This is the maintenance margin requirement as specified by the exchange,
// if available.
func (m *SecurityDefinitionResponse) SetMaintenanceMarginRequirement(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(112, value)
	return m
}

// SetCurrency This is the currency that the Symbol trades in or is priced in.
func (m *SecurityDefinitionResponse) SetCurrency(value string) *SecurityDefinitionResponse {
	m.p.SetStringVLS(116, value)
	return m
}

// SetContractSize In the case of when a Symbol is a contract type, this variable indicates
// the size of the contract.
//
// This is going to be an exchange specific specification.
func (m *SecurityDefinitionResponse) SetContractSize(value float32) *SecurityDefinitionResponse {
	m.p.SetFloat32LE(120, value)
	return m
}

// SetOpenInterest In the case of when a Symbol is a contract type, this field is the number
// of outstanding contracts.
func (m *SecurityDefinitionResponse) SetOpenInterest(value uint32) *SecurityDefinitionResponse {
	m.p.SetUint32LE(124, value)
	return m
}

// SetRolloverDate This field applies to the Futures Security Type.
//
// This is the rollover date for the symbol according to the typical time
// where trading transitions from one contract month to the next.
func (m *SecurityDefinitionResponse) SetRolloverDate(value DateTime4Byte) *SecurityDefinitionResponse {
	m.p.SetUint32LE(128, uint32(value))
	return m
}

// SetIsDelayed This field will be 1 if the market data for the Symbol is intentionally
// delayed by a certain amount of time. Otherwise, this will be 0.
func (m *SecurityDefinitionResponse) SetIsDelayed(value bool) *SecurityDefinitionResponse {
	m.p.SetBool(132, value)
	return m
}

// SetSecurityIdentifier
func (m *SecurityDefinitionResponse) SetSecurityIdentifier(value int64) *SecurityDefinitionResponse {
	m.p.SetInt64LE(136, value)
	return m
}

// SetProductIdentifier
func (m *SecurityDefinitionResponse) SetProductIdentifier(value string) *SecurityDefinitionResponse {
	m.p.SetStringVLS(144, value)
	return m
}

// SetRequestID This is the same RequestID that this message is in response to and was
// given in the original Security Definition request message.
func (m *SecurityDefinitionResponseFixed) SetRequestID(value int32) *SecurityDefinitionResponseFixed {
	m.p.SetInt32LE(4, value)
	return m
}

// SetSymbol This is the Symbol the Security Definition is for.
//
// When the Server responds with a single SecurityDefinitionResponse message
// and there are no security definitions to return for the original request,
// this will be empty.
//
// This field should be empty when this Security Definition message is in
// response to UnderlyingSymbolsForExchangeRequest.
func (m *SecurityDefinitionResponseFixed) SetSymbol(value string) *SecurityDefinitionResponseFixed {
	m.p.SetStringFixed(8, 64, value)
	return m
}

// SetExchange This is the Exchange for the Symbol. This field is optional.
func (m *SecurityDefinitionResponseFixed) SetExchange(value string) *SecurityDefinitionResponseFixed {
	m.p.SetStringFixed(72, 16, value)
	return m
}

// SetSecurityType The Security Type for the symbol.
func (m *SecurityDefinitionResponseFixed) SetSecurityType(value SecurityTypeEnum) *SecurityDefinitionResponseFixed {
	m.p.SetInt32LE(88, int32(value))
	return m
}

// SetDescription The text description for the Symbol.
func (m *SecurityDefinitionResponseFixed) SetDescription(value string) *SecurityDefinitionResponseFixed {
	m.p.SetStringFixed(92, 64, value)
	return m
}

// SetMinPriceIncrement The minimum amount that prices can change by for the Symbol and minimum
// amount that prices are quoted in.
func (m *SecurityDefinitionResponseFixed) SetMinPriceIncrement(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(156, value)
	return m
}

// SetPriceDisplayFormat This field specifies the price formatting for display purposes.
func (m *SecurityDefinitionResponseFixed) SetPriceDisplayFormat(value PriceDisplayFormatEnum) *SecurityDefinitionResponseFixed {
	m.p.SetInt32LE(160, int32(value))
	return m
}

// SetCurrencyValuePerIncrement This field is the currency value per MinPriceIncrement in the Symbols
// currency.
func (m *SecurityDefinitionResponseFixed) SetCurrencyValuePerIncrement(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(164, value)
	return m
}

// SetIsFinalMessage Set to a integer value of 1 to indicate this is the final message in batch
// of Security Definition Response messages.
func (m *SecurityDefinitionResponseFixed) SetIsFinalMessage(value bool) *SecurityDefinitionResponseFixed {
	m.p.SetBool(168, value)
	return m
}

// SetFloatToIntPriceMultiplier With the integer order entry messages discontinued as of August 2020,
// this field is no longer relevant.
func (m *SecurityDefinitionResponseFixed) SetFloatToIntPriceMultiplier(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(172, value)
	return m
}

// SetIntToFloatPriceDivisor
func (m *SecurityDefinitionResponseFixed) SetIntToFloatPriceDivisor(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(176, value)
	return m
}

// SetUnderlyingSymbol This is the underlying symbol for the Symbol field if the Symbol has an
// underlying symbol.
//
// The Server must set this when the SecurityDefinitionResponse message in
// response to UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest.
// response to UnderlyingSymbolsForExchangeRequest, SymbolsForUnderlyingRequest.
//
// This is typically used with futures. A futures symbol for a specific contract
// year and month will have an underlying symbol equivalent to the Symbol
// without the year and month characters.
func (m *SecurityDefinitionResponseFixed) SetUnderlyingSymbol(value string) *SecurityDefinitionResponseFixed {
	m.p.SetStringFixed(180, 32, value)
	return m
}

// SetUpdatesBidAskOnly This is set to 1 when the Symbol does not provide MarketDataUpdateTrade
// messages and only provides MarketDataUpdateBidAsk messages when there
// is market activity for the Symbol.
//
// Otherwise, when this is set to 0, MarketDataUpdateTrade messages will
// be received after subscribing to market data, when there is trading activity.
// be received after subscribing to market data, when there is trading activity.
func (m *SecurityDefinitionResponseFixed) SetUpdatesBidAskOnly(value uint8) *SecurityDefinitionResponseFixed {
	m.p.SetUint8(212, value)
	return m
}

// SetStrikePrice The strike price when the Security Type is an option type.
func (m *SecurityDefinitionResponseFixed) SetStrikePrice(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(216, value)
	return m
}

// SetPutOrCall When the Security Type is an option, this indicates if it is a put or
// call.
func (m *SecurityDefinitionResponseFixed) SetPutOrCall(value PutCallEnum) *SecurityDefinitionResponseFixed {
	m.p.SetUint8(220, uint8(value))
	return m
}

// SetShortInterest The short interest when the Security Type is a stock.
func (m *SecurityDefinitionResponseFixed) SetShortInterest(value uint32) *SecurityDefinitionResponseFixed {
	m.p.SetUint32LE(224, value)
	return m
}

// SetSecurityExpirationDate The expiration date for the Symbol for symbols which have an expiration
// date.
func (m *SecurityDefinitionResponseFixed) SetSecurityExpirationDate(value DateTime4Byte) *SecurityDefinitionResponseFixed {
	m.p.SetUint32LE(228, uint32(value))
	return m
}

// SetBuyRolloverInterest The daily interest amount which is deducted for a Buy position. This only
// applies for Forex trading. It is in the quote currency of the symbol.
func (m *SecurityDefinitionResponseFixed) SetBuyRolloverInterest(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(232, value)
	return m
}

// SetSellRolloverInterest The daily interest amount which is deducted for a Sell position. This
// only applies for Forex trading. It is in the quote currency of the symbol.
// only applies for Forex trading. It is in the quote currency of the symbol.
func (m *SecurityDefinitionResponseFixed) SetSellRolloverInterest(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(236, value)
	return m
}

// SetEarningsPerShare The earnings per share as a currency value when the Security Type is a
// stock.
func (m *SecurityDefinitionResponseFixed) SetEarningsPerShare(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(240, value)
	return m
}

// SetSharesOutstanding This is the number of shares outstanding for stocks.
func (m *SecurityDefinitionResponseFixed) SetSharesOutstanding(value uint32) *SecurityDefinitionResponseFixed {
	m.p.SetUint32LE(244, value)
	return m
}

// SetIntToFloatQuantityDivisor With the integer order entry and market data messages discontinued as
// of August 2020, this field is no longer relevant.
func (m *SecurityDefinitionResponseFixed) SetIntToFloatQuantityDivisor(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(248, value)
	return m
}

// SetHasMarketDepthData When HasMarketDepthData is set to 1, it indicates the Symbol has market
// depth data available for it. When this is set to 0, market depth data
// is not supported for the Symbol.
func (m *SecurityDefinitionResponseFixed) SetHasMarketDepthData(value uint8) *SecurityDefinitionResponseFixed {
	m.p.SetUint8(252, value)
	return m
}

// SetDisplayPriceMultiplier This is an optional field for the Server to set.
//
// The default for this is 1.0.
//
// This sets the multiplier to use in the case where the Client should multiply
// the values in market data messages by some number other than 1.0 before
// displaying them to the user.
//
// It is recommended that a Server does not use this and instead transmit
// to the Client values as the actual floating-point values.
//
// This should not be confused with the integer market data messages and
// the IntToFloatPriceDivisor field used with those messages. DisplayPriceMultiplier
// is for when the Server transmits market data values using floating-point
// types and where those values may have a fractional component, but where
// it is necessary to still multiply the original value by this multiplier
// to get the final value to display to the user.
//
// When this is set to a value other than 1.0, then the MinPriceIncrement
// and the PriceDisplayFormat fields are relative to the market data values
// after the DisplayPriceMultiplier is applied.
func (m *SecurityDefinitionResponseFixed) SetDisplayPriceMultiplier(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(256, value)
	return m
}

// SetExchangeSymbol This is an optional field. This is the exchange symbol which corresponds
// with the Symbol field.
//
// This field should be empty when this Security Definition message is in
// response to UNDERLYING_SymbolsForExchangeRequest.
func (m *SecurityDefinitionResponseFixed) SetExchangeSymbol(value string) *SecurityDefinitionResponseFixed {
	m.p.SetStringFixed(260, 64, value)
	return m
}

// SetInitialMarginRequirement This field applies to the Futures Security Type.
//
// This is the initial margin requirement as specified by the exchange, if
// available.
func (m *SecurityDefinitionResponseFixed) SetInitialMarginRequirement(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(324, value)
	return m
}

// SetMaintenanceMarginRequirement This field applies to the Futures Security Type.
//
// This is the maintenance margin requirement as specified by the exchange,
// if available.
func (m *SecurityDefinitionResponseFixed) SetMaintenanceMarginRequirement(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(328, value)
	return m
}

// SetCurrency This is the currency that the Symbol trades in or is priced in.
func (m *SecurityDefinitionResponseFixed) SetCurrency(value string) *SecurityDefinitionResponseFixed {
	m.p.SetStringFixed(332, 8, value)
	return m
}

// SetContractSize In the case of when a Symbol is a contract type, this variable indicates
// the size of the contract.
//
// This is going to be an exchange specific specification.
func (m *SecurityDefinitionResponseFixed) SetContractSize(value float32) *SecurityDefinitionResponseFixed {
	m.p.SetFloat32LE(340, value)
	return m
}

// SetOpenInterest In the case of when a Symbol is a contract type, this field is the number
// of outstanding contracts.
func (m *SecurityDefinitionResponseFixed) SetOpenInterest(value uint32) *SecurityDefinitionResponseFixed {
	m.p.SetUint32LE(344, value)
	return m
}

// SetRolloverDate This field applies to the Futures Security Type.
//
// This is the rollover date for the symbol according to the typical time
// where trading transitions from one contract month to the next.
func (m *SecurityDefinitionResponseFixed) SetRolloverDate(value DateTime4Byte) *SecurityDefinitionResponseFixed {
	m.p.SetUint32LE(348, uint32(value))
	return m
}

// SetIsDelayed This field will be 1 if the market data for the Symbol is intentionally
// delayed by a certain amount of time. Otherwise, this will be 0.
func (m *SecurityDefinitionResponseFixed) SetIsDelayed(value bool) *SecurityDefinitionResponseFixed {
	m.p.SetBool(352, value)
	return m
}

// SetSecurityIdentifier
func (m *SecurityDefinitionResponseFixed) SetSecurityIdentifier(value int64) *SecurityDefinitionResponseFixed {
	m.p.SetInt64LE(360, value)
	return m
}

// SetProductIdentifier
func (m *SecurityDefinitionResponseFixed) SetProductIdentifier(value string) *SecurityDefinitionResponseFixed {
	m.p.SetStringFixed(368, 64, value)
	return m
}

func (m *SecurityDefinitionResponse) WriteTo(w io.Writer) (int64, error) {
	s := int(m.Size())
	n, err := w.Write(m.p.AsBytes(s))
	return int64(n), err
}

func (m *SecurityDefinitionResponse) MarshalBinary() ([]byte, error) {
	return m.p.AsBytes(int(m.Size())), nil
}

func (m *SecurityDefinitionResponse) Clone() *SecurityDefinitionResponse {
	return &SecurityDefinitionResponse{message.WrapVLSPointer(m.p.Clone(uintptr(m.Size())), int(m.Size()))}
}

func (m *SecurityDefinitionResponseFixed) WriteTo(w io.Writer) (int64, error) {
	s := int(m.Size())
	n, err := w.Write(m.p.AsBytes(s))
	return int64(n), err
}

func (m *SecurityDefinitionResponseFixed) MarshalBinary() ([]byte, error) {
	return m.p.AsBytes(int(m.Size())), nil
}

func (m *SecurityDefinitionResponseFixed) Clone() *SecurityDefinitionResponseFixed {
	return &SecurityDefinitionResponseFixed{message.WrapFixedPointer(m.p.Clone(uintptr(m.Size())))}
}

// Copy
func (m SecurityDefinitionResponse) Copy(to SecurityDefinitionResponse) {
	to.SetRequestID(m.RequestID())
	to.SetSymbol(m.Symbol())
	to.SetExchange(m.Exchange())
	to.SetSecurityType(m.SecurityType())
	to.SetDescription(m.Description())
	to.SetMinPriceIncrement(m.MinPriceIncrement())
	to.SetPriceDisplayFormat(m.PriceDisplayFormat())
	to.SetCurrencyValuePerIncrement(m.CurrencyValuePerIncrement())
	to.SetIsFinalMessage(m.IsFinalMessage())
	to.SetFloatToIntPriceMultiplier(m.FloatToIntPriceMultiplier())
	to.SetIntToFloatPriceDivisor(m.IntToFloatPriceDivisor())
	to.SetUnderlyingSymbol(m.UnderlyingSymbol())
	to.SetUpdatesBidAskOnly(m.UpdatesBidAskOnly())
	to.SetStrikePrice(m.StrikePrice())
	to.SetPutOrCall(m.PutOrCall())
	to.SetShortInterest(m.ShortInterest())
	to.SetSecurityExpirationDate(m.SecurityExpirationDate())
	to.SetBuyRolloverInterest(m.BuyRolloverInterest())
	to.SetSellRolloverInterest(m.SellRolloverInterest())
	to.SetEarningsPerShare(m.EarningsPerShare())
	to.SetSharesOutstanding(m.SharesOutstanding())
	to.SetIntToFloatQuantityDivisor(m.IntToFloatQuantityDivisor())
	to.SetHasMarketDepthData(m.HasMarketDepthData())
	to.SetDisplayPriceMultiplier(m.DisplayPriceMultiplier())
	to.SetExchangeSymbol(m.ExchangeSymbol())
	to.SetInitialMarginRequirement(m.InitialMarginRequirement())
	to.SetMaintenanceMarginRequirement(m.MaintenanceMarginRequirement())
	to.SetCurrency(m.Currency())
	to.SetContractSize(m.ContractSize())
	to.SetOpenInterest(m.OpenInterest())
	to.SetRolloverDate(m.RolloverDate())
	to.SetIsDelayed(m.IsDelayed())
	to.SetSecurityIdentifier(m.SecurityIdentifier())
	to.SetProductIdentifier(m.ProductIdentifier())
}

// CopyTo
func (m SecurityDefinitionResponse) CopyTo(to SecurityDefinitionResponseFixed) {
	to.SetRequestID(m.RequestID())
	to.SetSymbol(m.Symbol())
	to.SetExchange(m.Exchange())
	to.SetSecurityType(m.SecurityType())
	to.SetDescription(m.Description())
	to.SetMinPriceIncrement(m.MinPriceIncrement())
	to.SetPriceDisplayFormat(m.PriceDisplayFormat())
	to.SetCurrencyValuePerIncrement(m.CurrencyValuePerIncrement())
	to.SetIsFinalMessage(m.IsFinalMessage())
	to.SetFloatToIntPriceMultiplier(m.FloatToIntPriceMultiplier())
	to.SetIntToFloatPriceDivisor(m.IntToFloatPriceDivisor())
	to.SetUnderlyingSymbol(m.UnderlyingSymbol())
	to.SetUpdatesBidAskOnly(m.UpdatesBidAskOnly())
	to.SetStrikePrice(m.StrikePrice())
	to.SetPutOrCall(m.PutOrCall())
	to.SetShortInterest(m.ShortInterest())
	to.SetSecurityExpirationDate(m.SecurityExpirationDate())
	to.SetBuyRolloverInterest(m.BuyRolloverInterest())
	to.SetSellRolloverInterest(m.SellRolloverInterest())
	to.SetEarningsPerShare(m.EarningsPerShare())
	to.SetSharesOutstanding(m.SharesOutstanding())
	to.SetIntToFloatQuantityDivisor(m.IntToFloatQuantityDivisor())
	to.SetHasMarketDepthData(m.HasMarketDepthData())
	to.SetDisplayPriceMultiplier(m.DisplayPriceMultiplier())
	to.SetExchangeSymbol(m.ExchangeSymbol())
	to.SetInitialMarginRequirement(m.InitialMarginRequirement())
	to.SetMaintenanceMarginRequirement(m.MaintenanceMarginRequirement())
	to.SetCurrency(m.Currency())
	to.SetContractSize(m.ContractSize())
	to.SetOpenInterest(m.OpenInterest())
	to.SetRolloverDate(m.RolloverDate())
	to.SetIsDelayed(m.IsDelayed())
	to.SetSecurityIdentifier(m.SecurityIdentifier())
	to.SetProductIdentifier(m.ProductIdentifier())
}

// Copy
func (m SecurityDefinitionResponseFixed) Copy(to SecurityDefinitionResponseFixed) {
	to.SetRequestID(m.RequestID())
	to.SetSymbol(m.Symbol())
	to.SetExchange(m.Exchange())
	to.SetSecurityType(m.SecurityType())
	to.SetDescription(m.Description())
	to.SetMinPriceIncrement(m.MinPriceIncrement())
	to.SetPriceDisplayFormat(m.PriceDisplayFormat())
	to.SetCurrencyValuePerIncrement(m.CurrencyValuePerIncrement())
	to.SetIsFinalMessage(m.IsFinalMessage())
	to.SetFloatToIntPriceMultiplier(m.FloatToIntPriceMultiplier())
	to.SetIntToFloatPriceDivisor(m.IntToFloatPriceDivisor())
	to.SetUnderlyingSymbol(m.UnderlyingSymbol())
	to.SetUpdatesBidAskOnly(m.UpdatesBidAskOnly())
	to.SetStrikePrice(m.StrikePrice())
	to.SetPutOrCall(m.PutOrCall())
	to.SetShortInterest(m.ShortInterest())
	to.SetSecurityExpirationDate(m.SecurityExpirationDate())
	to.SetBuyRolloverInterest(m.BuyRolloverInterest())
	to.SetSellRolloverInterest(m.SellRolloverInterest())
	to.SetEarningsPerShare(m.EarningsPerShare())
	to.SetSharesOutstanding(m.SharesOutstanding())
	to.SetIntToFloatQuantityDivisor(m.IntToFloatQuantityDivisor())
	to.SetHasMarketDepthData(m.HasMarketDepthData())
	to.SetDisplayPriceMultiplier(m.DisplayPriceMultiplier())
	to.SetExchangeSymbol(m.ExchangeSymbol())
	to.SetInitialMarginRequirement(m.InitialMarginRequirement())
	to.SetMaintenanceMarginRequirement(m.MaintenanceMarginRequirement())
	to.SetCurrency(m.Currency())
	to.SetContractSize(m.ContractSize())
	to.SetOpenInterest(m.OpenInterest())
	to.SetRolloverDate(m.RolloverDate())
	to.SetIsDelayed(m.IsDelayed())
	to.SetSecurityIdentifier(m.SecurityIdentifier())
	to.SetProductIdentifier(m.ProductIdentifier())
}

// CopyTo
func (m SecurityDefinitionResponseFixed) CopyTo(to SecurityDefinitionResponse) {
	to.SetRequestID(m.RequestID())
	to.SetSymbol(m.Symbol())
	to.SetExchange(m.Exchange())
	to.SetSecurityType(m.SecurityType())
	to.SetDescription(m.Description())
	to.SetMinPriceIncrement(m.MinPriceIncrement())
	to.SetPriceDisplayFormat(m.PriceDisplayFormat())
	to.SetCurrencyValuePerIncrement(m.CurrencyValuePerIncrement())
	to.SetIsFinalMessage(m.IsFinalMessage())
	to.SetFloatToIntPriceMultiplier(m.FloatToIntPriceMultiplier())
	to.SetIntToFloatPriceDivisor(m.IntToFloatPriceDivisor())
	to.SetUnderlyingSymbol(m.UnderlyingSymbol())
	to.SetUpdatesBidAskOnly(m.UpdatesBidAskOnly())
	to.SetStrikePrice(m.StrikePrice())
	to.SetPutOrCall(m.PutOrCall())
	to.SetShortInterest(m.ShortInterest())
	to.SetSecurityExpirationDate(m.SecurityExpirationDate())
	to.SetBuyRolloverInterest(m.BuyRolloverInterest())
	to.SetSellRolloverInterest(m.SellRolloverInterest())
	to.SetEarningsPerShare(m.EarningsPerShare())
	to.SetSharesOutstanding(m.SharesOutstanding())
	to.SetIntToFloatQuantityDivisor(m.IntToFloatQuantityDivisor())
	to.SetHasMarketDepthData(m.HasMarketDepthData())
	to.SetDisplayPriceMultiplier(m.DisplayPriceMultiplier())
	to.SetExchangeSymbol(m.ExchangeSymbol())
	to.SetInitialMarginRequirement(m.InitialMarginRequirement())
	to.SetMaintenanceMarginRequirement(m.MaintenanceMarginRequirement())
	to.SetCurrency(m.Currency())
	to.SetContractSize(m.ContractSize())
	to.SetOpenInterest(m.OpenInterest())
	to.SetRolloverDate(m.RolloverDate())
	to.SetIsDelayed(m.IsDelayed())
	to.SetSecurityIdentifier(m.SecurityIdentifier())
	to.SetProductIdentifier(m.ProductIdentifier())
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Marshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *SecurityDefinitionResponse) MarshalJSON() ([]byte, error) {
	return m.MarshalJSONTo(nil)
}

func (m *SecurityDefinitionResponse) MarshalJSONTo(b []byte) ([]byte, error) {
	w := json.NewWriter(b, 507)
	w.Int32Field("RequestID", m.RequestID())
	w.StringField("Symbol", m.Symbol())
	w.StringField("Exchange", m.Exchange())
	w.Int32Field("SecurityType", int32(m.SecurityType()))
	w.StringField("Description", m.Description())
	w.Float32Field("MinPriceIncrement", m.MinPriceIncrement())
	w.Int32Field("PriceDisplayFormat", int32(m.PriceDisplayFormat()))
	w.Float32Field("CurrencyValuePerIncrement", m.CurrencyValuePerIncrement())
	w.BoolField("IsFinalMessage", m.IsFinalMessage())
	w.Float32Field("FloatToIntPriceMultiplier", m.FloatToIntPriceMultiplier())
	w.Float32Field("IntToFloatPriceDivisor", m.IntToFloatPriceDivisor())
	w.StringField("UnderlyingSymbol", m.UnderlyingSymbol())
	w.Uint8Field("UpdatesBidAskOnly", m.UpdatesBidAskOnly())
	w.Float32Field("StrikePrice", m.StrikePrice())
	w.Uint8Field("PutOrCall", uint8(m.PutOrCall()))
	w.Uint32Field("ShortInterest", m.ShortInterest())
	w.Uint32Field("SecurityExpirationDate", uint32(m.SecurityExpirationDate()))
	w.Float32Field("BuyRolloverInterest", m.BuyRolloverInterest())
	w.Float32Field("SellRolloverInterest", m.SellRolloverInterest())
	w.Float32Field("EarningsPerShare", m.EarningsPerShare())
	w.Uint32Field("SharesOutstanding", m.SharesOutstanding())
	w.Float32Field("IntToFloatQuantityDivisor", m.IntToFloatQuantityDivisor())
	w.Uint8Field("HasMarketDepthData", m.HasMarketDepthData())
	w.Float32Field("DisplayPriceMultiplier", m.DisplayPriceMultiplier())
	w.StringField("ExchangeSymbol", m.ExchangeSymbol())
	w.Float32Field("InitialMarginRequirement", m.InitialMarginRequirement())
	w.Float32Field("MaintenanceMarginRequirement", m.MaintenanceMarginRequirement())
	w.StringField("Currency", m.Currency())
	w.Float32Field("ContractSize", m.ContractSize())
	w.Uint32Field("OpenInterest", m.OpenInterest())
	w.Uint32Field("RolloverDate", uint32(m.RolloverDate()))
	w.BoolField("IsDelayed", m.IsDelayed())
	w.Int64Field("SecurityIdentifier", m.SecurityIdentifier())
	w.StringField("ProductIdentifier", m.ProductIdentifier())
	return w.Finish(), nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Unmarshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *SecurityDefinitionResponse) UnmarshalJSON(b []byte) error {
	r, err := json.OpenReader(b)
	if err != nil {
		return err
	}
	return m.UnmarshalJSONFromReader(&r)
}

func (m *SecurityDefinitionResponse) UnmarshalJSONFromReader(r *json.Reader) error {
	if r.Type != 507 {
		return message.ErrWrongType
	}
	in := &r.Lexer
LOOP:
	for !in.IsDelim('}') {
		key, err := r.FieldName()
		if err != nil {
			return err
		}
		switch key {
		case "RequestID":
			m.SetRequestID(r.Int32())
		case "Symbol":
			m.SetSymbol(r.String())
		case "Exchange":
			m.SetExchange(r.String())
		case "SecurityType":
			m.SetSecurityType(SecurityTypeEnum(r.Int32()))
		case "Description":
			m.SetDescription(r.String())
		case "MinPriceIncrement":
			m.SetMinPriceIncrement(r.Float32())
		case "PriceDisplayFormat":
			m.SetPriceDisplayFormat(PriceDisplayFormatEnum(r.Int32()))
		case "CurrencyValuePerIncrement":
			m.SetCurrencyValuePerIncrement(r.Float32())
		case "IsFinalMessage":
			m.SetIsFinalMessage(r.Bool())
		case "FloatToIntPriceMultiplier":
			m.SetFloatToIntPriceMultiplier(r.Float32())
		case "IntToFloatPriceDivisor":
			m.SetIntToFloatPriceDivisor(r.Float32())
		case "UnderlyingSymbol":
			m.SetUnderlyingSymbol(r.String())
		case "UpdatesBidAskOnly":
			m.SetUpdatesBidAskOnly(r.Uint8())
		case "StrikePrice":
			m.SetStrikePrice(r.Float32())
		case "PutOrCall":
			m.SetPutOrCall(PutCallEnum(r.Uint8()))
		case "ShortInterest":
			m.SetShortInterest(r.Uint32())
		case "SecurityExpirationDate":
			m.SetSecurityExpirationDate(DateTime4Byte(r.Uint32()))
		case "BuyRolloverInterest":
			m.SetBuyRolloverInterest(r.Float32())
		case "SellRolloverInterest":
			m.SetSellRolloverInterest(r.Float32())
		case "EarningsPerShare":
			m.SetEarningsPerShare(r.Float32())
		case "SharesOutstanding":
			m.SetSharesOutstanding(r.Uint32())
		case "IntToFloatQuantityDivisor":
			m.SetIntToFloatQuantityDivisor(r.Float32())
		case "HasMarketDepthData":
			m.SetHasMarketDepthData(r.Uint8())
		case "DisplayPriceMultiplier":
			m.SetDisplayPriceMultiplier(r.Float32())
		case "ExchangeSymbol":
			m.SetExchangeSymbol(r.String())
		case "InitialMarginRequirement":
			m.SetInitialMarginRequirement(r.Float32())
		case "MaintenanceMarginRequirement":
			m.SetMaintenanceMarginRequirement(r.Float32())
		case "Currency":
			m.SetCurrency(r.String())
		case "ContractSize":
			m.SetContractSize(r.Float32())
		case "OpenInterest":
			m.SetOpenInterest(r.Uint32())
		case "RolloverDate":
			m.SetRolloverDate(DateTime4Byte(r.Uint32()))
		case "IsDelayed":
			m.SetIsDelayed(r.Bool())
		case "SecurityIdentifier":
			m.SetSecurityIdentifier(r.Int64())
		case "ProductIdentifier":
			m.SetProductIdentifier(r.String())
		case "f", "F":
			return message.ErrJSONCompactDetected
		case "":
			break LOOP
		default:
			in.SkipRecursive()
		}
		if r.IsError() {
			return r.Error()
		}
		in.WantComma()
	}
	return nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Marshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *SecurityDefinitionResponseFixed) MarshalJSON() ([]byte, error) {
	return m.MarshalJSONTo(nil)
}

func (m *SecurityDefinitionResponseFixed) MarshalJSONTo(b []byte) ([]byte, error) {
	w := json.NewWriter(b, 507)
	w.Int32Field("RequestID", m.RequestID())
	w.StringField("Symbol", m.Symbol())
	w.StringField("Exchange", m.Exchange())
	w.Int32Field("SecurityType", int32(m.SecurityType()))
	w.StringField("Description", m.Description())
	w.Float32Field("MinPriceIncrement", m.MinPriceIncrement())
	w.Int32Field("PriceDisplayFormat", int32(m.PriceDisplayFormat()))
	w.Float32Field("CurrencyValuePerIncrement", m.CurrencyValuePerIncrement())
	w.BoolField("IsFinalMessage", m.IsFinalMessage())
	w.Float32Field("FloatToIntPriceMultiplier", m.FloatToIntPriceMultiplier())
	w.Float32Field("IntToFloatPriceDivisor", m.IntToFloatPriceDivisor())
	w.StringField("UnderlyingSymbol", m.UnderlyingSymbol())
	w.Uint8Field("UpdatesBidAskOnly", m.UpdatesBidAskOnly())
	w.Float32Field("StrikePrice", m.StrikePrice())
	w.Uint8Field("PutOrCall", uint8(m.PutOrCall()))
	w.Uint32Field("ShortInterest", m.ShortInterest())
	w.Uint32Field("SecurityExpirationDate", uint32(m.SecurityExpirationDate()))
	w.Float32Field("BuyRolloverInterest", m.BuyRolloverInterest())
	w.Float32Field("SellRolloverInterest", m.SellRolloverInterest())
	w.Float32Field("EarningsPerShare", m.EarningsPerShare())
	w.Uint32Field("SharesOutstanding", m.SharesOutstanding())
	w.Float32Field("IntToFloatQuantityDivisor", m.IntToFloatQuantityDivisor())
	w.Uint8Field("HasMarketDepthData", m.HasMarketDepthData())
	w.Float32Field("DisplayPriceMultiplier", m.DisplayPriceMultiplier())
	w.StringField("ExchangeSymbol", m.ExchangeSymbol())
	w.Float32Field("InitialMarginRequirement", m.InitialMarginRequirement())
	w.Float32Field("MaintenanceMarginRequirement", m.MaintenanceMarginRequirement())
	w.StringField("Currency", m.Currency())
	w.Float32Field("ContractSize", m.ContractSize())
	w.Uint32Field("OpenInterest", m.OpenInterest())
	w.Uint32Field("RolloverDate", uint32(m.RolloverDate()))
	w.BoolField("IsDelayed", m.IsDelayed())
	w.Int64Field("SecurityIdentifier", m.SecurityIdentifier())
	w.StringField("ProductIdentifier", m.ProductIdentifier())
	return w.Finish(), nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Unmarshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *SecurityDefinitionResponseFixed) UnmarshalJSON(b []byte) error {
	r, err := json.OpenReader(b)
	if err != nil {
		return err
	}
	return m.UnmarshalJSONFromReader(&r)
}

func (m *SecurityDefinitionResponseFixed) UnmarshalJSONFromReader(r *json.Reader) error {
	if r.Type != 507 {
		return message.ErrWrongType
	}
	in := &r.Lexer
LOOP:
	for !in.IsDelim('}') {
		key, err := r.FieldName()
		if err != nil {
			return err
		}
		switch key {
		case "RequestID":
			m.SetRequestID(r.Int32())
		case "Symbol":
			m.SetSymbol(r.String())
		case "Exchange":
			m.SetExchange(r.String())
		case "SecurityType":
			m.SetSecurityType(SecurityTypeEnum(r.Int32()))
		case "Description":
			m.SetDescription(r.String())
		case "MinPriceIncrement":
			m.SetMinPriceIncrement(r.Float32())
		case "PriceDisplayFormat":
			m.SetPriceDisplayFormat(PriceDisplayFormatEnum(r.Int32()))
		case "CurrencyValuePerIncrement":
			m.SetCurrencyValuePerIncrement(r.Float32())
		case "IsFinalMessage":
			m.SetIsFinalMessage(r.Bool())
		case "FloatToIntPriceMultiplier":
			m.SetFloatToIntPriceMultiplier(r.Float32())
		case "IntToFloatPriceDivisor":
			m.SetIntToFloatPriceDivisor(r.Float32())
		case "UnderlyingSymbol":
			m.SetUnderlyingSymbol(r.String())
		case "UpdatesBidAskOnly":
			m.SetUpdatesBidAskOnly(r.Uint8())
		case "StrikePrice":
			m.SetStrikePrice(r.Float32())
		case "PutOrCall":
			m.SetPutOrCall(PutCallEnum(r.Uint8()))
		case "ShortInterest":
			m.SetShortInterest(r.Uint32())
		case "SecurityExpirationDate":
			m.SetSecurityExpirationDate(DateTime4Byte(r.Uint32()))
		case "BuyRolloverInterest":
			m.SetBuyRolloverInterest(r.Float32())
		case "SellRolloverInterest":
			m.SetSellRolloverInterest(r.Float32())
		case "EarningsPerShare":
			m.SetEarningsPerShare(r.Float32())
		case "SharesOutstanding":
			m.SetSharesOutstanding(r.Uint32())
		case "IntToFloatQuantityDivisor":
			m.SetIntToFloatQuantityDivisor(r.Float32())
		case "HasMarketDepthData":
			m.SetHasMarketDepthData(r.Uint8())
		case "DisplayPriceMultiplier":
			m.SetDisplayPriceMultiplier(r.Float32())
		case "ExchangeSymbol":
			m.SetExchangeSymbol(r.String())
		case "InitialMarginRequirement":
			m.SetInitialMarginRequirement(r.Float32())
		case "MaintenanceMarginRequirement":
			m.SetMaintenanceMarginRequirement(r.Float32())
		case "Currency":
			m.SetCurrency(r.String())
		case "ContractSize":
			m.SetContractSize(r.Float32())
		case "OpenInterest":
			m.SetOpenInterest(r.Uint32())
		case "RolloverDate":
			m.SetRolloverDate(DateTime4Byte(r.Uint32()))
		case "IsDelayed":
			m.SetIsDelayed(r.Bool())
		case "SecurityIdentifier":
			m.SetSecurityIdentifier(r.Int64())
		case "ProductIdentifier":
			m.SetProductIdentifier(r.String())
		case "f", "F":
			return message.ErrJSONCompactDetected
		case "":
			break LOOP
		default:
			in.SkipRecursive()
		}
		if r.IsError() {
			return r.Error()
		}
		in.WantComma()
	}
	return nil
}
