// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-31 22:08:18.145964 +0800 WITA m=+0.011497918

package v8

import (
	"github.com/moontrade/dtc-go/message"
	"github.com/moontrade/dtc-go/message/json"
	"io"
)

const LogonResponseSize = 52

const LogonResponseFixedSize = 256

//     Size                                           uint16           = LogonResponseSize  (52)
//     Type                                           uint16           = LOGON_RESPONSE  (2)
//     BaseSize                                       uint16           = LogonResponseSize  (52)
//     ProtocolVersion                                int32            = CURRENT_VERSION  (8)
//     Result                                         LogonStatusEnum  = LOGON_SUCCESS  (0)
//     ResultText                                     string           = ""
//     ReconnectAddress                               string           = ""
//     Integer_1                                      int32            = 0
//     ServerName                                     string           = ""
//     MarketDepthUpdatesBestBidAndAsk                uint8            = 0
//     TradingIsSupported                             bool             = false
//     OCOOrdersSupported                             bool             = false
//     OrderCancelReplaceSupported                    bool             = true
//     SymbolExchangeDelimiter                        string           = ""
//     SecurityDefinitionsSupported                   bool             = false
//     HistoricalPriceDataSupported                   bool             = false
//     ResubscribeWhenMarketDataFeedAvailable         uint8            = 0
//     MarketDepthIsSupported                         bool             = true
//     OneHistoricalPriceDataRequestPerConnection     uint8            = 0
//     BracketOrdersSupported                         bool             = false
//     Unused_1                                       uint8            = 0
//     UsesMultiplePositionsPerSymbolAndTradeAccount  uint8            = 0
//     MarketDataSupported                            bool             = false
var _LogonResponseDefault = []byte{52, 0, 2, 0, 52, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}

//     Size                                           uint16           = LogonResponseFixedSize  (256)
//     Type                                           uint16           = LOGON_RESPONSE  (2)
//     ProtocolVersion                                int32            = CURRENT_VERSION  (8)
//     Result                                         LogonStatusEnum  = LOGON_SUCCESS  (0)
//     ResultText                                     string[96]       = ""
//     ReconnectAddress                               string[64]       = ""
//     Integer_1                                      int32            = 0
//     ServerName                                     string[60]       = ""
//     MarketDepthUpdatesBestBidAndAsk                uint8            = 0
//     TradingIsSupported                             bool             = false
//     OCOOrdersSupported                             bool             = false
//     OrderCancelReplaceSupported                    bool             = true
//     SymbolExchangeDelimiter                        string[4]        = ""
//     SecurityDefinitionsSupported                   bool             = false
//     HistoricalPriceDataSupported                   bool             = false
//     ResubscribeWhenMarketDataFeedAvailable         uint8            = 0
//     MarketDepthIsSupported                         bool             = true
//     OneHistoricalPriceDataRequestPerConnection     uint8            = 0
//     BracketOrdersSupported                         bool             = false
//     Unused_1                                       uint8            = 0
//     UsesMultiplePositionsPerSymbolAndTradeAccount  uint8            = 0
//     MarketDataSupported                            bool             = true
var _LogonResponseFixedDefault = []byte{0, 1, 2, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0}

// LogonResponse This is a response message indicating either success or an error logging
// on to the Server.
type LogonResponse struct {
	p message.VLS
}

// LogonResponseFixed This is a response message indicating either success or an error logging
// on to the Server.
type LogonResponseFixed struct {
	p message.Fixed
}

func NewLogonResponseFrom(b []byte) LogonResponse {
	return LogonResponse{p: message.NewVLS(b)}
}

func WrapLogonResponse(b []byte) LogonResponse {
	return LogonResponse{p: message.WrapVLS(b)}
}

func NewLogonResponse() *LogonResponse {
	return &LogonResponse{p: message.NewVLS(_LogonResponseDefault)}
}

func ParseLogonResponse(b []byte) (LogonResponse, error) {
	if len(b) < 6 {
		return LogonResponse{}, message.ErrShortBuffer
	}
	m := WrapLogonResponse(b)
	if int(m.p.AsUint16LE()) != len(b) {
		return LogonResponse{}, message.ErrOverflow
	}
	baseSize := int(m.p.Uint16LE(4))
	if baseSize > len(b) {
		return LogonResponse{}, message.ErrBaseSizeOverflow
	}
	if baseSize < 52 {
		newSize := len(b) + (52 - baseSize)
		if newSize > message.MaxSize {
			return LogonResponse{}, message.ErrOverflow
		}
		clone := LogonResponse{message.WrapVLSUnsafe(message.Alloc(uintptr(newSize)), len(b))}
		clone.p.SetBytes(0, b[0:baseSize])
		clone.p.SetBytes(baseSize, _LogonResponseDefault[baseSize:])
		if len(b) > baseSize {
			shift := uint16(52 - baseSize)
			var offset uint16
			offset = clone.p.Uint16LE(16)
			if offset > 0 {
				clone.p.SetUint16LE(16, offset+shift)
			}
			offset = clone.p.Uint16LE(20)
			if offset > 0 {
				clone.p.SetUint16LE(20, offset+shift)
			}
			offset = clone.p.Uint16LE(28)
			if offset > 0 {
				clone.p.SetUint16LE(28, offset+shift)
			}
			offset = clone.p.Uint16LE(36)
			if offset > 0 {
				clone.p.SetUint16LE(36, offset+shift)
			}
		}
		return clone, nil
	}
	return m, nil
}

func NewLogonResponseFixedFrom(b []byte) LogonResponseFixed {
	return LogonResponseFixed{p: message.NewFixed(b)}
}

func WrapLogonResponseFixed(b []byte) LogonResponseFixed {
	return LogonResponseFixed{p: message.WrapFixed(b)}
}

func NewLogonResponseFixed() *LogonResponseFixed {
	return &LogonResponseFixed{p: message.NewFixed(_LogonResponseFixedDefault)}
}

func ParseLogonResponseFixed(b []byte) (LogonResponseFixed, error) {
	if len(b) < 4 {
		return LogonResponseFixed{}, message.ErrShortBuffer
	}
	m := WrapLogonResponseFixed(b)
	if int(m.p.AsUint16LE()) != len(b) {
		return LogonResponseFixed{}, message.ErrOverflow
	}
	size := int(m.p.AsUint16LE())
	if size > len(b) {
		return LogonResponseFixed{}, message.ErrBaseSizeOverflow
	}
	if size < 256 {
		clone := *NewLogonResponseFixed()
		clone.p.SetBytes(0, b[0:size])
		clone.p.SetBytes(size, _LogonResponseFixedDefault[size:])
		return clone, nil
	}
	return m, nil
}

// Size The standard message size field. Automatically set by constructor.
func (m LogonResponse) Size() uint16 {
	return m.p.Uint16LE(0)
}

// Type The standard message type field. Automatically set by constructor.
//
// To determine the field number for JSON, refer to this message type constant
// in the DTCProtocol.h file.
func (m LogonResponse) Type() uint16 {
	return m.p.Uint16LE(2)
}

// BaseSize
func (m LogonResponse) BaseSize() uint16 {
	return m.p.Uint16LE(4)
}

// ProtocolVersion This is automatically set by the constructor.
func (m LogonResponse) ProtocolVersion() int32 {
	return m.p.Int32LE(8)
}

// Result This can be set to one of the following constants:
//
// LOGON_SUCCESS
// LOGON_ERROR
// LOGON_ERROR_NO_RECONNECT
// LOGON_RECONNECT_NEW_ADDRESS
// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
// and the Client should not try to reconnect.
//
// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
// the Client to reconnect to the Server at a different address. The new
// address is specified through the ReconnectAddress field. This supports
// dynamic connections to a server farm.
func (m LogonResponse) Result() LogonStatusEnum {
	return LogonStatusEnum(m.p.Int32LE(12))
}

// ResultText Optional freeform text to provide information related to a successful
// or unsuccessful logon. The Client will display this text to the user.
func (m LogonResponse) ResultText() string {
	return m.p.StringVLS(16)
}

// ReconnectAddress Server address/IP number and optional port number to reconnect to. Format:
// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
func (m LogonResponse) ReconnectAddress() string {
	return m.p.StringVLS(20)
}

// Integer_1 Optional. General-purpose integer for the Server to communicate to the
// Client an integer value on logon.
func (m LogonResponse) Integer_1() int32 {
	return m.p.Int32LE(24)
}

// ServerName Optional free-form text for the Server to fill out.
//
// It is recommended that the Server fill this in with descriptive text identifying
// itself to the Client.
//
// The length of this text string is 60 characters when fixed length strings
// are used.
func (m LogonResponse) ServerName() string {
	return m.p.StringVLS(28)
}

// MarketDepthUpdatesBestBidAndAsk Set this to 1 to indicate that the Server will only be sending market
// depth updates and not best bid and ask updates. The Client will use depth
// at level 1 to update the best bid and ask prices.
//
// Some Clients will maintain separate best bid and ask prices from market
// depth data.
func (m LogonResponse) MarketDepthUpdatesBestBidAndAsk() uint8 {
	return m.p.Uint8(32)
}

// TradingIsSupported Set this to 1 to indicate the Server supports trading. Otherwise, the
// Client will not send through any trading messages.
func (m LogonResponse) TradingIsSupported() bool {
	return m.p.Bool(33)
}

// OCOOrdersSupported Set this to 1 to indicate the Server supports OCO orders.
func (m LogonResponse) OCOOrdersSupported() bool {
	return m.p.Bool(34)
}

// OrderCancelReplaceSupported Set this to 0 if Server does not support the CancelReplaceOrder message.
// Set this to 0 if Server does not support the CancelReplaceOrder message.
func (m LogonResponse) OrderCancelReplaceSupported() bool {
	return m.p.Bool(35)
}

// SymbolExchangeDelimiter Some Clients will usually consider the Symbol and Exchange fields as a
// single text string. If the Server will be using the Exchange field in
// DTC messages that have a Symbol and Exchange fields, it must specify the
// SymbolExchangeDelimiter field to provide a standard delimiter for the
// Client to use to combine the Symbol and the Exchange into a single text
// string.
//
// It is recommended to use a "-" or ".". Examples of how the Client will
// then combine the Symbol and exchange.
//
// Symbol-Exchange
// Symbol.Exchange
// If this field is unset, then this is an indication to the Client that
// the Exchange field in DTC Protocol messages are not used.
//
// Even if the symbols supported by a Server have an Exchange text string,
// does not mean the Server has to use the Exchange field in DTC messages.
// The Server can combine the Symbol and the Exchange in Security Definition
// responses into the Symbol field only.
//
// When a Client sees that the SymbolExchangeDelimiter field is set, then
// it can use this delimiter to combine the Symbol and Exchange into a single
// text string. When the Client is setting the Symbol and Exchange in DTC
// messages, it needs to separate out the Symbol and Exchange from the larger
// text string and set those fields separately.
func (m LogonResponse) SymbolExchangeDelimiter() string {
	return m.p.StringVLS(36)
}

// SecurityDefinitionsSupported Set to 1 if the Server supports Security Definition messages.
func (m LogonResponse) SecurityDefinitionsSupported() bool {
	return m.p.Bool(40)
}

// HistoricalPriceDataSupported Set this to 1 if the Server supports the HistoricalPriceDataRequest message.
// Set this to 1 if the Server supports the HistoricalPriceDataRequest message.
func (m LogonResponse) HistoricalPriceDataSupported() bool {
	return m.p.Bool(41)
}

// ResubscribeWhenMarketDataFeedAvailable Set this to 1, so that when the Client receives a MarketDataFeedStatus
// indicating the market data feed is restored, it will resubscribe to market
// data and market depth for all of the symbols it was previously tracking.
// data and market depth for all of the symbols it was previously tracking.
func (m LogonResponse) ResubscribeWhenMarketDataFeedAvailable() uint8 {
	return m.p.Uint8(42)
}

// MarketDepthIsSupported Set this to 1, if the Server supports the MarketDepthRequest message.
//
// The default is 0.
func (m LogonResponse) MarketDepthIsSupported() bool {
	return m.p.Bool(43)
}

// OneHistoricalPriceDataRequestPerConnection The server can optionally set the OneHistoricalPriceDataRequestPerConnection
// field to 1 in the LogonResponse message to indicate that it only will
// accept one historical price data request per network connection.
//
// After the first request is served or rejected, the network connection
// will be gracefully closed at the appropriate time by the Server. This
// method simplifies the serving of historical price data on the Server side
// and the implementation on the Client side when data compression is used.
// and the implementation on the Client side when data compression is used.
func (m LogonResponse) OneHistoricalPriceDataRequestPerConnection() uint8 {
	return m.p.Uint8(44)
}

// BracketOrdersSupported Set this to 1 to indicate the Server supports bracket orders.
func (m LogonResponse) BracketOrdersSupported() bool {
	return m.p.Bool(45)
}

// Unused_1
func (m LogonResponse) Unused_1() uint8 {
	return m.p.Uint8(46)
}

// UsesMultiplePositionsPerSymbolAndTradeAccount If the Server can report more than one Trade Position for a specific Symbol
// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
// to 1.
//
// When the server has set to 1, it must always set PositionIdentifier in
// the PositionUpdate message to the identifier of the Trade Position.
//
// When the Client checks that this is set to 1, then it knows that it can
// expect there potentially can be more than one Trade Position for a specific
// Symbol and Trade Account being reported by the PositionUpdate messages.
// The Client can then handle this appropriately.
func (m LogonResponse) UsesMultiplePositionsPerSymbolAndTradeAccount() uint8 {
	return m.p.Uint8(47)
}

// MarketDataSupported Set this to 1, if the Server supports the MarketDataRequest message.
//
// The default is 1.
func (m LogonResponse) MarketDataSupported() bool {
	return m.p.Bool(48)
}

// Size The standard message size field. Automatically set by constructor.
func (m LogonResponseFixed) Size() uint16 {
	return m.p.Uint16LE(0)
}

// Type The standard message type field. Automatically set by constructor.
//
// To determine the field number for JSON, refer to this message type constant
// in the DTCProtocol.h file.
func (m LogonResponseFixed) Type() uint16 {
	return m.p.Uint16LE(2)
}

// ProtocolVersion This is automatically set by the constructor.
func (m LogonResponseFixed) ProtocolVersion() int32 {
	return m.p.Int32LE(4)
}

// Result This can be set to one of the following constants:
//
// LOGON_SUCCESS
// LOGON_ERROR
// LOGON_ERROR_NO_RECONNECT
// LOGON_RECONNECT_NEW_ADDRESS
// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
// and the Client should not try to reconnect.
//
// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
// the Client to reconnect to the Server at a different address. The new
// address is specified through the ReconnectAddress field. This supports
// dynamic connections to a server farm.
func (m LogonResponseFixed) Result() LogonStatusEnum {
	return LogonStatusEnum(m.p.Int32LE(8))
}

// ResultText Optional freeform text to provide information related to a successful
// or unsuccessful logon. The Client will display this text to the user.
func (m LogonResponseFixed) ResultText() string {
	return m.p.StringFixed(12, 96)
}

// ReconnectAddress Server address/IP number and optional port number to reconnect to. Format:
// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
func (m LogonResponseFixed) ReconnectAddress() string {
	return m.p.StringFixed(108, 64)
}

// Integer_1 Optional. General-purpose integer for the Server to communicate to the
// Client an integer value on logon.
func (m LogonResponseFixed) Integer_1() int32 {
	return m.p.Int32LE(172)
}

// ServerName Optional free-form text for the Server to fill out.
//
// It is recommended that the Server fill this in with descriptive text identifying
// itself to the Client.
//
// The length of this text string is 60 characters when fixed length strings
// are used.
func (m LogonResponseFixed) ServerName() string {
	return m.p.StringFixed(176, 60)
}

// MarketDepthUpdatesBestBidAndAsk Set this to 1 to indicate that the Server will only be sending market
// depth updates and not best bid and ask updates. The Client will use depth
// at level 1 to update the best bid and ask prices.
//
// Some Clients will maintain separate best bid and ask prices from market
// depth data.
func (m LogonResponseFixed) MarketDepthUpdatesBestBidAndAsk() uint8 {
	return m.p.Uint8(236)
}

// TradingIsSupported Set this to 1 to indicate the Server supports trading. Otherwise, the
// Client will not send through any trading messages.
func (m LogonResponseFixed) TradingIsSupported() bool {
	return m.p.Bool(237)
}

// OCOOrdersSupported Set this to 1 to indicate the Server supports OCO orders.
func (m LogonResponseFixed) OCOOrdersSupported() bool {
	return m.p.Bool(238)
}

// OrderCancelReplaceSupported Set this to 0 if Server does not support the CancelReplaceOrder message.
// Set this to 0 if Server does not support the CancelReplaceOrder message.
func (m LogonResponseFixed) OrderCancelReplaceSupported() bool {
	return m.p.Bool(239)
}

// SymbolExchangeDelimiter Some Clients will usually consider the Symbol and Exchange fields as a
// single text string. If the Server will be using the Exchange field in
// DTC messages that have a Symbol and Exchange fields, it must specify the
// SymbolExchangeDelimiter field to provide a standard delimiter for the
// Client to use to combine the Symbol and the Exchange into a single text
// string.
//
// It is recommended to use a "-" or ".". Examples of how the Client will
// then combine the Symbol and exchange.
//
// Symbol-Exchange
// Symbol.Exchange
// If this field is unset, then this is an indication to the Client that
// the Exchange field in DTC Protocol messages are not used.
//
// Even if the symbols supported by a Server have an Exchange text string,
// does not mean the Server has to use the Exchange field in DTC messages.
// The Server can combine the Symbol and the Exchange in Security Definition
// responses into the Symbol field only.
//
// When a Client sees that the SymbolExchangeDelimiter field is set, then
// it can use this delimiter to combine the Symbol and Exchange into a single
// text string. When the Client is setting the Symbol and Exchange in DTC
// messages, it needs to separate out the Symbol and Exchange from the larger
// text string and set those fields separately.
func (m LogonResponseFixed) SymbolExchangeDelimiter() string {
	return m.p.StringFixed(240, 4)
}

// SecurityDefinitionsSupported Set to 1 if the Server supports Security Definition messages.
func (m LogonResponseFixed) SecurityDefinitionsSupported() bool {
	return m.p.Bool(244)
}

// HistoricalPriceDataSupported Set this to 1 if the Server supports the HistoricalPriceDataRequest message.
// Set this to 1 if the Server supports the HistoricalPriceDataRequest message.
func (m LogonResponseFixed) HistoricalPriceDataSupported() bool {
	return m.p.Bool(245)
}

// ResubscribeWhenMarketDataFeedAvailable Set this to 1, so that when the Client receives a MarketDataFeedStatus
// indicating the market data feed is restored, it will resubscribe to market
// data and market depth for all of the symbols it was previously tracking.
// data and market depth for all of the symbols it was previously tracking.
func (m LogonResponseFixed) ResubscribeWhenMarketDataFeedAvailable() uint8 {
	return m.p.Uint8(246)
}

// MarketDepthIsSupported Set this to 1, if the Server supports the MarketDepthRequest message.
//
// The default is 0.
func (m LogonResponseFixed) MarketDepthIsSupported() bool {
	return m.p.Bool(247)
}

// OneHistoricalPriceDataRequestPerConnection The server can optionally set the OneHistoricalPriceDataRequestPerConnection
// field to 1 in the LogonResponse message to indicate that it only will
// accept one historical price data request per network connection.
//
// After the first request is served or rejected, the network connection
// will be gracefully closed at the appropriate time by the Server. This
// method simplifies the serving of historical price data on the Server side
// and the implementation on the Client side when data compression is used.
// and the implementation on the Client side when data compression is used.
func (m LogonResponseFixed) OneHistoricalPriceDataRequestPerConnection() uint8 {
	return m.p.Uint8(248)
}

// BracketOrdersSupported Set this to 1 to indicate the Server supports bracket orders.
func (m LogonResponseFixed) BracketOrdersSupported() bool {
	return m.p.Bool(249)
}

// Unused_1
func (m LogonResponseFixed) Unused_1() uint8 {
	return m.p.Uint8(250)
}

// UsesMultiplePositionsPerSymbolAndTradeAccount If the Server can report more than one Trade Position for a specific Symbol
// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
// to 1.
//
// When the server has set to 1, it must always set PositionIdentifier in
// the PositionUpdate message to the identifier of the Trade Position.
//
// When the Client checks that this is set to 1, then it knows that it can
// expect there potentially can be more than one Trade Position for a specific
// Symbol and Trade Account being reported by the PositionUpdate messages.
// The Client can then handle this appropriately.
func (m LogonResponseFixed) UsesMultiplePositionsPerSymbolAndTradeAccount() uint8 {
	return m.p.Uint8(251)
}

// MarketDataSupported Set this to 1, if the Server supports the MarketDataRequest message.
//
// The default is 1.
func (m LogonResponseFixed) MarketDataSupported() bool {
	return m.p.Bool(252)
}

// SetProtocolVersion This is automatically set by the constructor.
func (m *LogonResponse) SetProtocolVersion(value int32) *LogonResponse {
	m.p.SetInt32LE(8, value)
	return m
}

// SetResult This can be set to one of the following constants:
//
// LOGON_SUCCESS
// LOGON_ERROR
// LOGON_ERROR_NO_RECONNECT
// LOGON_RECONNECT_NEW_ADDRESS
// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
// and the Client should not try to reconnect.
//
// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
// the Client to reconnect to the Server at a different address. The new
// address is specified through the ReconnectAddress field. This supports
// dynamic connections to a server farm.
func (m *LogonResponse) SetResult(value LogonStatusEnum) *LogonResponse {
	m.p.SetInt32LE(12, int32(value))
	return m
}

// SetResultText Optional freeform text to provide information related to a successful
// or unsuccessful logon. The Client will display this text to the user.
func (m *LogonResponse) SetResultText(value string) *LogonResponse {
	m.p.SetStringVLS(16, value)
	return m
}

// SetReconnectAddress Server address/IP number and optional port number to reconnect to. Format:
// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
func (m *LogonResponse) SetReconnectAddress(value string) *LogonResponse {
	m.p.SetStringVLS(20, value)
	return m
}

// SetInteger_1 Optional. General-purpose integer for the Server to communicate to the
// Client an integer value on logon.
func (m *LogonResponse) SetInteger_1(value int32) *LogonResponse {
	m.p.SetInt32LE(24, value)
	return m
}

// SetServerName Optional free-form text for the Server to fill out.
//
// It is recommended that the Server fill this in with descriptive text identifying
// itself to the Client.
//
// The length of this text string is 60 characters when fixed length strings
// are used.
func (m *LogonResponse) SetServerName(value string) *LogonResponse {
	m.p.SetStringVLS(28, value)
	return m
}

// SetMarketDepthUpdatesBestBidAndAsk Set this to 1 to indicate that the Server will only be sending market
// depth updates and not best bid and ask updates. The Client will use depth
// at level 1 to update the best bid and ask prices.
//
// Some Clients will maintain separate best bid and ask prices from market
// depth data.
func (m *LogonResponse) SetMarketDepthUpdatesBestBidAndAsk(value uint8) *LogonResponse {
	m.p.SetUint8(32, value)
	return m
}

// SetTradingIsSupported Set this to 1 to indicate the Server supports trading. Otherwise, the
// Client will not send through any trading messages.
func (m *LogonResponse) SetTradingIsSupported(value bool) *LogonResponse {
	m.p.SetBool(33, value)
	return m
}

// SetOCOOrdersSupported Set this to 1 to indicate the Server supports OCO orders.
func (m *LogonResponse) SetOCOOrdersSupported(value bool) *LogonResponse {
	m.p.SetBool(34, value)
	return m
}

// SetOrderCancelReplaceSupported Set this to 0 if Server does not support the CancelReplaceOrder message.
// Set this to 0 if Server does not support the CancelReplaceOrder message.
func (m *LogonResponse) SetOrderCancelReplaceSupported(value bool) *LogonResponse {
	m.p.SetBool(35, value)
	return m
}

// SetSymbolExchangeDelimiter Some Clients will usually consider the Symbol and Exchange fields as a
// single text string. If the Server will be using the Exchange field in
// DTC messages that have a Symbol and Exchange fields, it must specify the
// SymbolExchangeDelimiter field to provide a standard delimiter for the
// Client to use to combine the Symbol and the Exchange into a single text
// string.
//
// It is recommended to use a "-" or ".". Examples of how the Client will
// then combine the Symbol and exchange.
//
// Symbol-Exchange
// Symbol.Exchange
// If this field is unset, then this is an indication to the Client that
// the Exchange field in DTC Protocol messages are not used.
//
// Even if the symbols supported by a Server have an Exchange text string,
// does not mean the Server has to use the Exchange field in DTC messages.
// The Server can combine the Symbol and the Exchange in Security Definition
// responses into the Symbol field only.
//
// When a Client sees that the SymbolExchangeDelimiter field is set, then
// it can use this delimiter to combine the Symbol and Exchange into a single
// text string. When the Client is setting the Symbol and Exchange in DTC
// messages, it needs to separate out the Symbol and Exchange from the larger
// text string and set those fields separately.
func (m *LogonResponse) SetSymbolExchangeDelimiter(value string) *LogonResponse {
	m.p.SetStringVLS(36, value)
	return m
}

// SetSecurityDefinitionsSupported Set to 1 if the Server supports Security Definition messages.
func (m *LogonResponse) SetSecurityDefinitionsSupported(value bool) *LogonResponse {
	m.p.SetBool(40, value)
	return m
}

// SetHistoricalPriceDataSupported Set this to 1 if the Server supports the HistoricalPriceDataRequest message.
// Set this to 1 if the Server supports the HistoricalPriceDataRequest message.
func (m *LogonResponse) SetHistoricalPriceDataSupported(value bool) *LogonResponse {
	m.p.SetBool(41, value)
	return m
}

// SetResubscribeWhenMarketDataFeedAvailable Set this to 1, so that when the Client receives a MarketDataFeedStatus
// indicating the market data feed is restored, it will resubscribe to market
// data and market depth for all of the symbols it was previously tracking.
// data and market depth for all of the symbols it was previously tracking.
func (m *LogonResponse) SetResubscribeWhenMarketDataFeedAvailable(value uint8) *LogonResponse {
	m.p.SetUint8(42, value)
	return m
}

// SetMarketDepthIsSupported Set this to 1, if the Server supports the MarketDepthRequest message.
//
// The default is 0.
func (m *LogonResponse) SetMarketDepthIsSupported(value bool) *LogonResponse {
	m.p.SetBool(43, value)
	return m
}

// SetOneHistoricalPriceDataRequestPerConnection The server can optionally set the OneHistoricalPriceDataRequestPerConnection
// field to 1 in the LogonResponse message to indicate that it only will
// accept one historical price data request per network connection.
//
// After the first request is served or rejected, the network connection
// will be gracefully closed at the appropriate time by the Server. This
// method simplifies the serving of historical price data on the Server side
// and the implementation on the Client side when data compression is used.
// and the implementation on the Client side when data compression is used.
func (m *LogonResponse) SetOneHistoricalPriceDataRequestPerConnection(value uint8) *LogonResponse {
	m.p.SetUint8(44, value)
	return m
}

// SetBracketOrdersSupported Set this to 1 to indicate the Server supports bracket orders.
func (m *LogonResponse) SetBracketOrdersSupported(value bool) *LogonResponse {
	m.p.SetBool(45, value)
	return m
}

// SetUnused_1
func (m *LogonResponse) SetUnused_1(value uint8) *LogonResponse {
	m.p.SetUint8(46, value)
	return m
}

// SetUsesMultiplePositionsPerSymbolAndTradeAccount If the Server can report more than one Trade Position for a specific Symbol
// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
// to 1.
//
// When the server has set to 1, it must always set PositionIdentifier in
// the PositionUpdate message to the identifier of the Trade Position.
//
// When the Client checks that this is set to 1, then it knows that it can
// expect there potentially can be more than one Trade Position for a specific
// Symbol and Trade Account being reported by the PositionUpdate messages.
// The Client can then handle this appropriately.
func (m *LogonResponse) SetUsesMultiplePositionsPerSymbolAndTradeAccount(value uint8) *LogonResponse {
	m.p.SetUint8(47, value)
	return m
}

// SetMarketDataSupported Set this to 1, if the Server supports the MarketDataRequest message.
//
// The default is 1.
func (m *LogonResponse) SetMarketDataSupported(value bool) *LogonResponse {
	m.p.SetBool(48, value)
	return m
}

// SetProtocolVersion This is automatically set by the constructor.
func (m *LogonResponseFixed) SetProtocolVersion(value int32) *LogonResponseFixed {
	m.p.SetInt32LE(4, value)
	return m
}

// SetResult This can be set to one of the following constants:
//
// LOGON_SUCCESS
// LOGON_ERROR
// LOGON_ERROR_NO_RECONNECT
// LOGON_RECONNECT_NEW_ADDRESS
// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
// and the Client should not try to reconnect.
//
// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
// the Client to reconnect to the Server at a different address. The new
// address is specified through the ReconnectAddress field. This supports
// dynamic connections to a server farm.
func (m *LogonResponseFixed) SetResult(value LogonStatusEnum) *LogonResponseFixed {
	m.p.SetInt32LE(8, int32(value))
	return m
}

// SetResultText Optional freeform text to provide information related to a successful
// or unsuccessful logon. The Client will display this text to the user.
func (m *LogonResponseFixed) SetResultText(value string) *LogonResponseFixed {
	m.p.SetStringFixed(12, 96, value)
	return m
}

// SetReconnectAddress Server address/IP number and optional port number to reconnect to. Format:
// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
func (m *LogonResponseFixed) SetReconnectAddress(value string) *LogonResponseFixed {
	m.p.SetStringFixed(108, 64, value)
	return m
}

// SetInteger_1 Optional. General-purpose integer for the Server to communicate to the
// Client an integer value on logon.
func (m *LogonResponseFixed) SetInteger_1(value int32) *LogonResponseFixed {
	m.p.SetInt32LE(172, value)
	return m
}

// SetServerName Optional free-form text for the Server to fill out.
//
// It is recommended that the Server fill this in with descriptive text identifying
// itself to the Client.
//
// The length of this text string is 60 characters when fixed length strings
// are used.
func (m *LogonResponseFixed) SetServerName(value string) *LogonResponseFixed {
	m.p.SetStringFixed(176, 60, value)
	return m
}

// SetMarketDepthUpdatesBestBidAndAsk Set this to 1 to indicate that the Server will only be sending market
// depth updates and not best bid and ask updates. The Client will use depth
// at level 1 to update the best bid and ask prices.
//
// Some Clients will maintain separate best bid and ask prices from market
// depth data.
func (m *LogonResponseFixed) SetMarketDepthUpdatesBestBidAndAsk(value uint8) *LogonResponseFixed {
	m.p.SetUint8(236, value)
	return m
}

// SetTradingIsSupported Set this to 1 to indicate the Server supports trading. Otherwise, the
// Client will not send through any trading messages.
func (m *LogonResponseFixed) SetTradingIsSupported(value bool) *LogonResponseFixed {
	m.p.SetBool(237, value)
	return m
}

// SetOCOOrdersSupported Set this to 1 to indicate the Server supports OCO orders.
func (m *LogonResponseFixed) SetOCOOrdersSupported(value bool) *LogonResponseFixed {
	m.p.SetBool(238, value)
	return m
}

// SetOrderCancelReplaceSupported Set this to 0 if Server does not support the CancelReplaceOrder message.
// Set this to 0 if Server does not support the CancelReplaceOrder message.
func (m *LogonResponseFixed) SetOrderCancelReplaceSupported(value bool) *LogonResponseFixed {
	m.p.SetBool(239, value)
	return m
}

// SetSymbolExchangeDelimiter Some Clients will usually consider the Symbol and Exchange fields as a
// single text string. If the Server will be using the Exchange field in
// DTC messages that have a Symbol and Exchange fields, it must specify the
// SymbolExchangeDelimiter field to provide a standard delimiter for the
// Client to use to combine the Symbol and the Exchange into a single text
// string.
//
// It is recommended to use a "-" or ".". Examples of how the Client will
// then combine the Symbol and exchange.
//
// Symbol-Exchange
// Symbol.Exchange
// If this field is unset, then this is an indication to the Client that
// the Exchange field in DTC Protocol messages are not used.
//
// Even if the symbols supported by a Server have an Exchange text string,
// does not mean the Server has to use the Exchange field in DTC messages.
// The Server can combine the Symbol and the Exchange in Security Definition
// responses into the Symbol field only.
//
// When a Client sees that the SymbolExchangeDelimiter field is set, then
// it can use this delimiter to combine the Symbol and Exchange into a single
// text string. When the Client is setting the Symbol and Exchange in DTC
// messages, it needs to separate out the Symbol and Exchange from the larger
// text string and set those fields separately.
func (m *LogonResponseFixed) SetSymbolExchangeDelimiter(value string) *LogonResponseFixed {
	m.p.SetStringFixed(240, 4, value)
	return m
}

// SetSecurityDefinitionsSupported Set to 1 if the Server supports Security Definition messages.
func (m *LogonResponseFixed) SetSecurityDefinitionsSupported(value bool) *LogonResponseFixed {
	m.p.SetBool(244, value)
	return m
}

// SetHistoricalPriceDataSupported Set this to 1 if the Server supports the HistoricalPriceDataRequest message.
// Set this to 1 if the Server supports the HistoricalPriceDataRequest message.
func (m *LogonResponseFixed) SetHistoricalPriceDataSupported(value bool) *LogonResponseFixed {
	m.p.SetBool(245, value)
	return m
}

// SetResubscribeWhenMarketDataFeedAvailable Set this to 1, so that when the Client receives a MarketDataFeedStatus
// indicating the market data feed is restored, it will resubscribe to market
// data and market depth for all of the symbols it was previously tracking.
// data and market depth for all of the symbols it was previously tracking.
func (m *LogonResponseFixed) SetResubscribeWhenMarketDataFeedAvailable(value uint8) *LogonResponseFixed {
	m.p.SetUint8(246, value)
	return m
}

// SetMarketDepthIsSupported Set this to 1, if the Server supports the MarketDepthRequest message.
//
// The default is 0.
func (m *LogonResponseFixed) SetMarketDepthIsSupported(value bool) *LogonResponseFixed {
	m.p.SetBool(247, value)
	return m
}

// SetOneHistoricalPriceDataRequestPerConnection The server can optionally set the OneHistoricalPriceDataRequestPerConnection
// field to 1 in the LogonResponse message to indicate that it only will
// accept one historical price data request per network connection.
//
// After the first request is served or rejected, the network connection
// will be gracefully closed at the appropriate time by the Server. This
// method simplifies the serving of historical price data on the Server side
// and the implementation on the Client side when data compression is used.
// and the implementation on the Client side when data compression is used.
func (m *LogonResponseFixed) SetOneHistoricalPriceDataRequestPerConnection(value uint8) *LogonResponseFixed {
	m.p.SetUint8(248, value)
	return m
}

// SetBracketOrdersSupported Set this to 1 to indicate the Server supports bracket orders.
func (m *LogonResponseFixed) SetBracketOrdersSupported(value bool) *LogonResponseFixed {
	m.p.SetBool(249, value)
	return m
}

// SetUnused_1
func (m *LogonResponseFixed) SetUnused_1(value uint8) *LogonResponseFixed {
	m.p.SetUint8(250, value)
	return m
}

// SetUsesMultiplePositionsPerSymbolAndTradeAccount If the Server can report more than one Trade Position for a specific Symbol
// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
// to 1.
//
// When the server has set to 1, it must always set PositionIdentifier in
// the PositionUpdate message to the identifier of the Trade Position.
//
// When the Client checks that this is set to 1, then it knows that it can
// expect there potentially can be more than one Trade Position for a specific
// Symbol and Trade Account being reported by the PositionUpdate messages.
// The Client can then handle this appropriately.
func (m *LogonResponseFixed) SetUsesMultiplePositionsPerSymbolAndTradeAccount(value uint8) *LogonResponseFixed {
	m.p.SetUint8(251, value)
	return m
}

// SetMarketDataSupported Set this to 1, if the Server supports the MarketDataRequest message.
//
// The default is 1.
func (m *LogonResponseFixed) SetMarketDataSupported(value bool) *LogonResponseFixed {
	m.p.SetBool(252, value)
	return m
}

func (m *LogonResponse) WriteTo(w io.Writer) (int64, error) {
	s := int(m.Size())
	n, err := w.Write(m.p.AsBytes(s))
	return int64(n), err
}

func (m *LogonResponse) MarshalBinary() ([]byte, error) {
	return m.p.AsBytes(int(m.Size())), nil
}

func (m *LogonResponse) Clone() *LogonResponse {
	return &LogonResponse{message.WrapVLSPointer(m.p.Clone(uintptr(m.Size())), int(m.Size()))}
}

func (m *LogonResponseFixed) WriteTo(w io.Writer) (int64, error) {
	s := int(m.Size())
	n, err := w.Write(m.p.AsBytes(s))
	return int64(n), err
}

func (m *LogonResponseFixed) MarshalBinary() ([]byte, error) {
	return m.p.AsBytes(int(m.Size())), nil
}

func (m *LogonResponseFixed) Clone() *LogonResponseFixed {
	return &LogonResponseFixed{message.WrapFixedPointer(m.p.Clone(uintptr(m.Size())))}
}

// Copy
func (m LogonResponse) Copy(to LogonResponse) {
	to.SetProtocolVersion(m.ProtocolVersion())
	to.SetResult(m.Result())
	to.SetResultText(m.ResultText())
	to.SetReconnectAddress(m.ReconnectAddress())
	to.SetInteger_1(m.Integer_1())
	to.SetServerName(m.ServerName())
	to.SetMarketDepthUpdatesBestBidAndAsk(m.MarketDepthUpdatesBestBidAndAsk())
	to.SetTradingIsSupported(m.TradingIsSupported())
	to.SetOCOOrdersSupported(m.OCOOrdersSupported())
	to.SetOrderCancelReplaceSupported(m.OrderCancelReplaceSupported())
	to.SetSymbolExchangeDelimiter(m.SymbolExchangeDelimiter())
	to.SetSecurityDefinitionsSupported(m.SecurityDefinitionsSupported())
	to.SetHistoricalPriceDataSupported(m.HistoricalPriceDataSupported())
	to.SetResubscribeWhenMarketDataFeedAvailable(m.ResubscribeWhenMarketDataFeedAvailable())
	to.SetMarketDepthIsSupported(m.MarketDepthIsSupported())
	to.SetOneHistoricalPriceDataRequestPerConnection(m.OneHistoricalPriceDataRequestPerConnection())
	to.SetBracketOrdersSupported(m.BracketOrdersSupported())
	to.SetUnused_1(m.Unused_1())
	to.SetUsesMultiplePositionsPerSymbolAndTradeAccount(m.UsesMultiplePositionsPerSymbolAndTradeAccount())
	to.SetMarketDataSupported(m.MarketDataSupported())
}

// CopyTo
func (m LogonResponse) CopyTo(to LogonResponseFixed) {
	to.SetProtocolVersion(m.ProtocolVersion())
	to.SetResult(m.Result())
	to.SetResultText(m.ResultText())
	to.SetReconnectAddress(m.ReconnectAddress())
	to.SetInteger_1(m.Integer_1())
	to.SetServerName(m.ServerName())
	to.SetMarketDepthUpdatesBestBidAndAsk(m.MarketDepthUpdatesBestBidAndAsk())
	to.SetTradingIsSupported(m.TradingIsSupported())
	to.SetOCOOrdersSupported(m.OCOOrdersSupported())
	to.SetOrderCancelReplaceSupported(m.OrderCancelReplaceSupported())
	to.SetSymbolExchangeDelimiter(m.SymbolExchangeDelimiter())
	to.SetSecurityDefinitionsSupported(m.SecurityDefinitionsSupported())
	to.SetHistoricalPriceDataSupported(m.HistoricalPriceDataSupported())
	to.SetResubscribeWhenMarketDataFeedAvailable(m.ResubscribeWhenMarketDataFeedAvailable())
	to.SetMarketDepthIsSupported(m.MarketDepthIsSupported())
	to.SetOneHistoricalPriceDataRequestPerConnection(m.OneHistoricalPriceDataRequestPerConnection())
	to.SetBracketOrdersSupported(m.BracketOrdersSupported())
	to.SetUnused_1(m.Unused_1())
	to.SetUsesMultiplePositionsPerSymbolAndTradeAccount(m.UsesMultiplePositionsPerSymbolAndTradeAccount())
	to.SetMarketDataSupported(m.MarketDataSupported())
}

// Copy
func (m LogonResponseFixed) Copy(to LogonResponseFixed) {
	to.SetProtocolVersion(m.ProtocolVersion())
	to.SetResult(m.Result())
	to.SetResultText(m.ResultText())
	to.SetReconnectAddress(m.ReconnectAddress())
	to.SetInteger_1(m.Integer_1())
	to.SetServerName(m.ServerName())
	to.SetMarketDepthUpdatesBestBidAndAsk(m.MarketDepthUpdatesBestBidAndAsk())
	to.SetTradingIsSupported(m.TradingIsSupported())
	to.SetOCOOrdersSupported(m.OCOOrdersSupported())
	to.SetOrderCancelReplaceSupported(m.OrderCancelReplaceSupported())
	to.SetSymbolExchangeDelimiter(m.SymbolExchangeDelimiter())
	to.SetSecurityDefinitionsSupported(m.SecurityDefinitionsSupported())
	to.SetHistoricalPriceDataSupported(m.HistoricalPriceDataSupported())
	to.SetResubscribeWhenMarketDataFeedAvailable(m.ResubscribeWhenMarketDataFeedAvailable())
	to.SetMarketDepthIsSupported(m.MarketDepthIsSupported())
	to.SetOneHistoricalPriceDataRequestPerConnection(m.OneHistoricalPriceDataRequestPerConnection())
	to.SetBracketOrdersSupported(m.BracketOrdersSupported())
	to.SetUnused_1(m.Unused_1())
	to.SetUsesMultiplePositionsPerSymbolAndTradeAccount(m.UsesMultiplePositionsPerSymbolAndTradeAccount())
	to.SetMarketDataSupported(m.MarketDataSupported())
}

// CopyTo
func (m LogonResponseFixed) CopyTo(to LogonResponse) {
	to.SetProtocolVersion(m.ProtocolVersion())
	to.SetResult(m.Result())
	to.SetResultText(m.ResultText())
	to.SetReconnectAddress(m.ReconnectAddress())
	to.SetInteger_1(m.Integer_1())
	to.SetServerName(m.ServerName())
	to.SetMarketDepthUpdatesBestBidAndAsk(m.MarketDepthUpdatesBestBidAndAsk())
	to.SetTradingIsSupported(m.TradingIsSupported())
	to.SetOCOOrdersSupported(m.OCOOrdersSupported())
	to.SetOrderCancelReplaceSupported(m.OrderCancelReplaceSupported())
	to.SetSymbolExchangeDelimiter(m.SymbolExchangeDelimiter())
	to.SetSecurityDefinitionsSupported(m.SecurityDefinitionsSupported())
	to.SetHistoricalPriceDataSupported(m.HistoricalPriceDataSupported())
	to.SetResubscribeWhenMarketDataFeedAvailable(m.ResubscribeWhenMarketDataFeedAvailable())
	to.SetMarketDepthIsSupported(m.MarketDepthIsSupported())
	to.SetOneHistoricalPriceDataRequestPerConnection(m.OneHistoricalPriceDataRequestPerConnection())
	to.SetBracketOrdersSupported(m.BracketOrdersSupported())
	to.SetUnused_1(m.Unused_1())
	to.SetUsesMultiplePositionsPerSymbolAndTradeAccount(m.UsesMultiplePositionsPerSymbolAndTradeAccount())
	to.SetMarketDataSupported(m.MarketDataSupported())
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Marshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *LogonResponse) MarshalJSON() ([]byte, error) {
	return m.MarshalJSONTo(nil)
}

func (m *LogonResponse) MarshalJSONTo(b []byte) ([]byte, error) {
	w := json.NewWriter(b, 2)
	w.Int32Field("ProtocolVersion", m.ProtocolVersion())
	w.Int32Field("Result", int32(m.Result()))
	w.StringField("ResultText", m.ResultText())
	w.StringField("ReconnectAddress", m.ReconnectAddress())
	w.Int32Field("Integer_1", m.Integer_1())
	w.StringField("ServerName", m.ServerName())
	w.Uint8Field("MarketDepthUpdatesBestBidAndAsk", m.MarketDepthUpdatesBestBidAndAsk())
	w.BoolField("TradingIsSupported", m.TradingIsSupported())
	w.BoolField("OCOOrdersSupported", m.OCOOrdersSupported())
	w.BoolField("OrderCancelReplaceSupported", m.OrderCancelReplaceSupported())
	w.StringField("SymbolExchangeDelimiter", m.SymbolExchangeDelimiter())
	w.BoolField("SecurityDefinitionsSupported", m.SecurityDefinitionsSupported())
	w.BoolField("HistoricalPriceDataSupported", m.HistoricalPriceDataSupported())
	w.Uint8Field("ResubscribeWhenMarketDataFeedAvailable", m.ResubscribeWhenMarketDataFeedAvailable())
	w.BoolField("MarketDepthIsSupported", m.MarketDepthIsSupported())
	w.Uint8Field("OneHistoricalPriceDataRequestPerConnection", m.OneHistoricalPriceDataRequestPerConnection())
	w.BoolField("BracketOrdersSupported", m.BracketOrdersSupported())
	w.Uint8Field("Unused_1", m.Unused_1())
	w.Uint8Field("UsesMultiplePositionsPerSymbolAndTradeAccount", m.UsesMultiplePositionsPerSymbolAndTradeAccount())
	w.BoolField("MarketDataSupported", m.MarketDataSupported())
	return w.Finish(), nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Unmarshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *LogonResponse) UnmarshalJSON(b []byte) error {
	r, err := json.OpenReader(b)
	if err != nil {
		return err
	}
	return m.UnmarshalJSONFromReader(&r)
}

func (m *LogonResponse) UnmarshalJSONFromReader(r *json.Reader) error {
	if r.Type != 2 {
		return message.ErrWrongType
	}
	in := &r.Lexer
LOOP:
	for !in.IsDelim('}') {
		key, err := r.FieldName()
		if err != nil {
			return err
		}
		switch key {
		case "ProtocolVersion":
			m.SetProtocolVersion(r.Int32())
		case "Result":
			m.SetResult(LogonStatusEnum(r.Int32()))
		case "ResultText":
			m.SetResultText(r.String())
		case "ReconnectAddress":
			m.SetReconnectAddress(r.String())
		case "Integer_1":
			m.SetInteger_1(r.Int32())
		case "ServerName":
			m.SetServerName(r.String())
		case "MarketDepthUpdatesBestBidAndAsk":
			m.SetMarketDepthUpdatesBestBidAndAsk(r.Uint8())
		case "TradingIsSupported":
			m.SetTradingIsSupported(r.Bool())
		case "OCOOrdersSupported":
			m.SetOCOOrdersSupported(r.Bool())
		case "OrderCancelReplaceSupported":
			m.SetOrderCancelReplaceSupported(r.Bool())
		case "SymbolExchangeDelimiter":
			m.SetSymbolExchangeDelimiter(r.String())
		case "SecurityDefinitionsSupported":
			m.SetSecurityDefinitionsSupported(r.Bool())
		case "HistoricalPriceDataSupported":
			m.SetHistoricalPriceDataSupported(r.Bool())
		case "ResubscribeWhenMarketDataFeedAvailable":
			m.SetResubscribeWhenMarketDataFeedAvailable(r.Uint8())
		case "MarketDepthIsSupported":
			m.SetMarketDepthIsSupported(r.Bool())
		case "OneHistoricalPriceDataRequestPerConnection":
			m.SetOneHistoricalPriceDataRequestPerConnection(r.Uint8())
		case "BracketOrdersSupported":
			m.SetBracketOrdersSupported(r.Bool())
		case "Unused_1":
			m.SetUnused_1(r.Uint8())
		case "UsesMultiplePositionsPerSymbolAndTradeAccount":
			m.SetUsesMultiplePositionsPerSymbolAndTradeAccount(r.Uint8())
		case "MarketDataSupported":
			m.SetMarketDataSupported(r.Bool())
		case "f", "F":
			return message.ErrJSONCompactDetected
		case "":
			break LOOP
		default:
			in.SkipRecursive()
		}
		if r.IsError() {
			return r.Error()
		}
		in.WantComma()
	}
	return nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Marshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *LogonResponseFixed) MarshalJSON() ([]byte, error) {
	return m.MarshalJSONTo(nil)
}

func (m *LogonResponseFixed) MarshalJSONTo(b []byte) ([]byte, error) {
	w := json.NewWriter(b, 2)
	w.Int32Field("ProtocolVersion", m.ProtocolVersion())
	w.Int32Field("Result", int32(m.Result()))
	w.StringField("ResultText", m.ResultText())
	w.StringField("ReconnectAddress", m.ReconnectAddress())
	w.Int32Field("Integer_1", m.Integer_1())
	w.StringField("ServerName", m.ServerName())
	w.Uint8Field("MarketDepthUpdatesBestBidAndAsk", m.MarketDepthUpdatesBestBidAndAsk())
	w.BoolField("TradingIsSupported", m.TradingIsSupported())
	w.BoolField("OCOOrdersSupported", m.OCOOrdersSupported())
	w.BoolField("OrderCancelReplaceSupported", m.OrderCancelReplaceSupported())
	w.StringField("SymbolExchangeDelimiter", m.SymbolExchangeDelimiter())
	w.BoolField("SecurityDefinitionsSupported", m.SecurityDefinitionsSupported())
	w.BoolField("HistoricalPriceDataSupported", m.HistoricalPriceDataSupported())
	w.Uint8Field("ResubscribeWhenMarketDataFeedAvailable", m.ResubscribeWhenMarketDataFeedAvailable())
	w.BoolField("MarketDepthIsSupported", m.MarketDepthIsSupported())
	w.Uint8Field("OneHistoricalPriceDataRequestPerConnection", m.OneHistoricalPriceDataRequestPerConnection())
	w.BoolField("BracketOrdersSupported", m.BracketOrdersSupported())
	w.Uint8Field("Unused_1", m.Unused_1())
	w.Uint8Field("UsesMultiplePositionsPerSymbolAndTradeAccount", m.UsesMultiplePositionsPerSymbolAndTradeAccount())
	w.BoolField("MarketDataSupported", m.MarketDataSupported())
	return w.Finish(), nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Unmarshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *LogonResponseFixed) UnmarshalJSON(b []byte) error {
	r, err := json.OpenReader(b)
	if err != nil {
		return err
	}
	return m.UnmarshalJSONFromReader(&r)
}

func (m *LogonResponseFixed) UnmarshalJSONFromReader(r *json.Reader) error {
	if r.Type != 2 {
		return message.ErrWrongType
	}
	in := &r.Lexer
LOOP:
	for !in.IsDelim('}') {
		key, err := r.FieldName()
		if err != nil {
			return err
		}
		switch key {
		case "ProtocolVersion":
			m.SetProtocolVersion(r.Int32())
		case "Result":
			m.SetResult(LogonStatusEnum(r.Int32()))
		case "ResultText":
			m.SetResultText(r.String())
		case "ReconnectAddress":
			m.SetReconnectAddress(r.String())
		case "Integer_1":
			m.SetInteger_1(r.Int32())
		case "ServerName":
			m.SetServerName(r.String())
		case "MarketDepthUpdatesBestBidAndAsk":
			m.SetMarketDepthUpdatesBestBidAndAsk(r.Uint8())
		case "TradingIsSupported":
			m.SetTradingIsSupported(r.Bool())
		case "OCOOrdersSupported":
			m.SetOCOOrdersSupported(r.Bool())
		case "OrderCancelReplaceSupported":
			m.SetOrderCancelReplaceSupported(r.Bool())
		case "SymbolExchangeDelimiter":
			m.SetSymbolExchangeDelimiter(r.String())
		case "SecurityDefinitionsSupported":
			m.SetSecurityDefinitionsSupported(r.Bool())
		case "HistoricalPriceDataSupported":
			m.SetHistoricalPriceDataSupported(r.Bool())
		case "ResubscribeWhenMarketDataFeedAvailable":
			m.SetResubscribeWhenMarketDataFeedAvailable(r.Uint8())
		case "MarketDepthIsSupported":
			m.SetMarketDepthIsSupported(r.Bool())
		case "OneHistoricalPriceDataRequestPerConnection":
			m.SetOneHistoricalPriceDataRequestPerConnection(r.Uint8())
		case "BracketOrdersSupported":
			m.SetBracketOrdersSupported(r.Bool())
		case "Unused_1":
			m.SetUnused_1(r.Uint8())
		case "UsesMultiplePositionsPerSymbolAndTradeAccount":
			m.SetUsesMultiplePositionsPerSymbolAndTradeAccount(r.Uint8())
		case "MarketDataSupported":
			m.SetMarketDataSupported(r.Bool())
		case "f", "F":
			return message.ErrJSONCompactDetected
		case "":
			break LOOP
		default:
			in.SkipRecursive()
		}
		if r.IsError() {
			return r.Error()
		}
		in.WantComma()
	}
	return nil
}
