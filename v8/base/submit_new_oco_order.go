// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-31 22:08:18.145964 +0800 WITA m=+0.011497918

package v8

import (
	"github.com/moontrade/dtc-go/message"
	"github.com/moontrade/dtc-go/message/json"
	"io"
)

const SubmitNewOCOOrderSize = 176

const SubmitNewOCOOrderFixedSize = 448

//     Size                            uint16                   = SubmitNewOCOOrderSize  (176)
//     Type                            uint16                   = SUBMIT_NEW_OCO_ORDER  (201)
//     BaseSize                        uint16                   = SubmitNewOCOOrderSize  (176)
//     Symbol                          string                   = ""
//     Exchange                        string                   = ""
//     ClientOrderID_1                 string                   = ""
//     OrderType_1                     OrderTypeEnum            = ORDER_TYPE_UNSET  (0)
//     BuySell_1                       BuySellEnum              = BUY_SELL_UNSET  (0)
//     Price1_1                        float64                  = 0.000000
//     Price2_1                        float64                  = 0.000000
//     Quantity_1                      float64                  = 0.000000
//     ClientOrderID_2                 string                   = ""
//     OrderType_2                     OrderTypeEnum            = ORDER_TYPE_UNSET  (0)
//     BuySell_2                       BuySellEnum              = BUY_SELL_UNSET  (0)
//     Price1_2                        float64                  = 0.000000
//     Price2_2                        float64                  = 0.000000
//     Quantity_2                      float64                  = 0.000000
//     TimeInForce                     TimeInForceEnum          = TIF_UNSET  (0)
//     GoodTillDateTime                DateTime                 = 0
//     TradeAccount                    string                   = ""
//     IsAutomatedOrder                bool                     = false
//     ParentTriggerClientOrderID      string                   = ""
//     FreeFormText                    string                   = ""
//     OpenOrClose                     OpenCloseTradeEnum       = TRADE_UNSET  (0)
//     PartialFillHandling             PartialFillHandlingEnum  = PARTIAL_FILL_UNSET  (0)
//     UseOffsets                      bool                     = false
//     OffsetFromParent1               float64                  = 0.000000
//     OffsetFromParent2               float64                  = 0.000000
//     MaintainSamePricesOnParentFill  uint8                    = 0
//     Price1_1AsString                string                   = ""
//     Price2_1AsString                string                   = ""
//     Price1_2AsString                string                   = ""
//     Price2_2AsString                string                   = ""
var _SubmitNewOCOOrderDefault = []byte{176, 0, 201, 0, 176, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

//     Size                            uint16                   = SubmitNewOCOOrderFixedSize  (448)
//     Type                            uint16                   = SUBMIT_NEW_OCO_ORDER  (201)
//     Symbol                          string[64]               = ""
//     Exchange                        string[16]               = ""
//     ClientOrderID_1                 string[32]               = ""
//     OrderType_1                     OrderTypeEnum            = ORDER_TYPE_UNSET  (0)
//     BuySell_1                       BuySellEnum              = BUY_SELL_UNSET  (0)
//     Price1_1                        float64                  = 0.000000
//     Price2_1                        float64                  = 0.000000
//     Quantity_1                      float64                  = 0.000000
//     ClientOrderID_2                 string[32]               = ""
//     OrderType_2                     OrderTypeEnum            = ORDER_TYPE_UNSET  (0)
//     BuySell_2                       BuySellEnum              = BUY_SELL_UNSET  (0)
//     Price1_2                        float64                  = 0.000000
//     Price2_2                        float64                  = 0.000000
//     Quantity_2                      float64                  = 0.000000
//     TimeInForce                     TimeInForceEnum          = TIF_UNSET  (0)
//     GoodTillDateTime                DateTime                 = 0
//     TradeAccount                    string[32]               = ""
//     IsAutomatedOrder                bool                     = false
//     ParentTriggerClientOrderID      string[32]               = ""
//     FreeFormText                    string[48]               = ""
//     OpenOrClose                     OpenCloseTradeEnum       = TRADE_UNSET  (0)
//     PartialFillHandling             PartialFillHandlingEnum  = PARTIAL_FILL_UNSET  (0)
//     UseOffsets                      bool                     = false
//     OffsetFromParent1               float64                  = 0.000000
//     OffsetFromParent2               float64                  = 0.000000
//     MaintainSamePricesOnParentFill  uint8                    = 0
//     Price1_1AsString                string[16]               = ""
//     Price2_1AsString                string[16]               = ""
//     Price1_2AsString                string[16]               = ""
//     Price2_2AsString                string[16]               = ""
var _SubmitNewOCOOrderFixedDefault = []byte{192, 1, 201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

// SubmitNewOCOOrder This is a message from the Client to the Server for submitting an order
// cancels order (OCO) pair into the market. What this means is when one
// of the orders is filled or canceled, the other order will be canceled.
// If one order partially fills, the other order will be reduced in quantity
// by the fill amount of the order that partially filled.
//
// A service provider must implement OCO orders on the server so that they
// can independently be modified (Cancel/Replace) and canceled independently
// using each order's distinct ServerOrderID. Although, if one of the orders
// is canceled by the Client, the other order will be canceled as well unless
// they have a parent order, as specified through the ParentTriggerClientOrderID
// field, in which case the other order should remain open.
//
// If the OCO order pair is rejected, this must be communicated through two
// separate OrderUpdate messages, 1 for each order, with the OrderUpdateReason
// set to NEW_ORDER_REJECTED.
type SubmitNewOCOOrder struct {
	p message.VLS
}

// SubmitNewOCOOrderFixed This is a message from the Client to the Server for submitting an order
// cancels order (OCO) pair into the market. What this means is when one
// of the orders is filled or canceled, the other order will be canceled.
// If one order partially fills, the other order will be reduced in quantity
// by the fill amount of the order that partially filled.
//
// A service provider must implement OCO orders on the server so that they
// can independently be modified (Cancel/Replace) and canceled independently
// using each order's distinct ServerOrderID. Although, if one of the orders
// is canceled by the Client, the other order will be canceled as well unless
// they have a parent order, as specified through the ParentTriggerClientOrderID
// field, in which case the other order should remain open.
//
// If the OCO order pair is rejected, this must be communicated through two
// separate OrderUpdate messages, 1 for each order, with the OrderUpdateReason
// set to NEW_ORDER_REJECTED.
type SubmitNewOCOOrderFixed struct {
	p message.Fixed
}

func NewSubmitNewOCOOrderFrom(b []byte) SubmitNewOCOOrder {
	return SubmitNewOCOOrder{p: message.NewVLS(b)}
}

func WrapSubmitNewOCOOrder(b []byte) SubmitNewOCOOrder {
	return SubmitNewOCOOrder{p: message.WrapVLS(b)}
}

func NewSubmitNewOCOOrder() *SubmitNewOCOOrder {
	return &SubmitNewOCOOrder{p: message.NewVLS(_SubmitNewOCOOrderDefault)}
}

func ParseSubmitNewOCOOrder(b []byte) (SubmitNewOCOOrder, error) {
	if len(b) < 6 {
		return SubmitNewOCOOrder{}, message.ErrShortBuffer
	}
	m := WrapSubmitNewOCOOrder(b)
	if int(m.p.AsUint16LE()) != len(b) {
		return SubmitNewOCOOrder{}, message.ErrOverflow
	}
	baseSize := int(m.p.Uint16LE(4))
	if baseSize > len(b) {
		return SubmitNewOCOOrder{}, message.ErrBaseSizeOverflow
	}
	if baseSize < 176 {
		newSize := len(b) + (176 - baseSize)
		if newSize > message.MaxSize {
			return SubmitNewOCOOrder{}, message.ErrOverflow
		}
		clone := SubmitNewOCOOrder{message.WrapVLSUnsafe(message.Alloc(uintptr(newSize)), len(b))}
		clone.p.SetBytes(0, b[0:baseSize])
		clone.p.SetBytes(baseSize, _SubmitNewOCOOrderDefault[baseSize:])
		if len(b) > baseSize {
			shift := uint16(176 - baseSize)
			var offset uint16
			offset = clone.p.Uint16LE(6)
			if offset > 0 {
				clone.p.SetUint16LE(6, offset+shift)
			}
			offset = clone.p.Uint16LE(10)
			if offset > 0 {
				clone.p.SetUint16LE(10, offset+shift)
			}
			offset = clone.p.Uint16LE(14)
			if offset > 0 {
				clone.p.SetUint16LE(14, offset+shift)
			}
			offset = clone.p.Uint16LE(56)
			if offset > 0 {
				clone.p.SetUint16LE(56, offset+shift)
			}
			offset = clone.p.Uint16LE(112)
			if offset > 0 {
				clone.p.SetUint16LE(112, offset+shift)
			}
			offset = clone.p.Uint16LE(118)
			if offset > 0 {
				clone.p.SetUint16LE(118, offset+shift)
			}
			offset = clone.p.Uint16LE(122)
			if offset > 0 {
				clone.p.SetUint16LE(122, offset+shift)
			}
			offset = clone.p.Uint16LE(154)
			if offset > 0 {
				clone.p.SetUint16LE(154, offset+shift)
			}
			offset = clone.p.Uint16LE(158)
			if offset > 0 {
				clone.p.SetUint16LE(158, offset+shift)
			}
			offset = clone.p.Uint16LE(162)
			if offset > 0 {
				clone.p.SetUint16LE(162, offset+shift)
			}
			offset = clone.p.Uint16LE(166)
			if offset > 0 {
				clone.p.SetUint16LE(166, offset+shift)
			}
		}
		return clone, nil
	}
	return m, nil
}

func NewSubmitNewOCOOrderFixedFrom(b []byte) SubmitNewOCOOrderFixed {
	return SubmitNewOCOOrderFixed{p: message.NewFixed(b)}
}

func WrapSubmitNewOCOOrderFixed(b []byte) SubmitNewOCOOrderFixed {
	return SubmitNewOCOOrderFixed{p: message.WrapFixed(b)}
}

func NewSubmitNewOCOOrderFixed() *SubmitNewOCOOrderFixed {
	return &SubmitNewOCOOrderFixed{p: message.NewFixed(_SubmitNewOCOOrderFixedDefault)}
}

func ParseSubmitNewOCOOrderFixed(b []byte) (SubmitNewOCOOrderFixed, error) {
	if len(b) < 4 {
		return SubmitNewOCOOrderFixed{}, message.ErrShortBuffer
	}
	m := WrapSubmitNewOCOOrderFixed(b)
	if int(m.p.AsUint16LE()) != len(b) {
		return SubmitNewOCOOrderFixed{}, message.ErrOverflow
	}
	size := int(m.p.AsUint16LE())
	if size > len(b) {
		return SubmitNewOCOOrderFixed{}, message.ErrBaseSizeOverflow
	}
	if size < 448 {
		clone := *NewSubmitNewOCOOrderFixed()
		clone.p.SetBytes(0, b[0:size])
		clone.p.SetBytes(size, _SubmitNewOCOOrderFixedDefault[size:])
		return clone, nil
	}
	return m, nil
}

// Size The standard message size field. Automatically set by constructor.
func (m SubmitNewOCOOrder) Size() uint16 {
	return m.p.Uint16LE(0)
}

// Type The standard message type field. Automatically set by constructor.
func (m SubmitNewOCOOrder) Type() uint16 {
	return m.p.Uint16LE(2)
}

// BaseSize
func (m SubmitNewOCOOrder) BaseSize() uint16 {
	return m.p.Uint16LE(4)
}

// Symbol The symbol for the order.
func (m SubmitNewOCOOrder) Symbol() string {
	return m.p.StringVLS(6)
}

// Exchange The optional exchange for the symbol.
func (m SubmitNewOCOOrder) Exchange() string {
	return m.p.StringVLS(10)
}

// ClientOrderID_1 The Client supplied order identifier for the first order. The Server will
// remember this for the life of the order.
func (m SubmitNewOCOOrder) ClientOrderID_1() string {
	return m.p.StringVLS(14)
}

// OrderType_1 The order type for the first order. For list of order types, refer to
// OrderTypeEnum.
func (m SubmitNewOCOOrder) OrderType_1() OrderTypeEnum {
	return OrderTypeEnum(m.p.Int32LE(20))
}

// BuySell_1 The side for the first order. Either Buy or Sell.
func (m SubmitNewOCOOrder) BuySell_1() BuySellEnum {
	return BuySellEnum(m.p.Int32LE(24))
}

// Price1_1 This is the price of the first order. This is the limit price for a Limit
// order, the stop price for a Stop order, or the trigger price for a Market
// if Touched order.
func (m SubmitNewOCOOrder) Price1_1() float64 {
	return m.p.Float64LE(32)
}

// Price2_1 This is the second price for the first order. For a Stop-Limit order,
// this is the limit price. Price2_1 only applies to Stop-Limit orders.
func (m SubmitNewOCOOrder) Price2_1() float64 {
	return m.p.Float64LE(40)
}

// Quantity_1 The quantity for the first order.
func (m SubmitNewOCOOrder) Quantity_1() float64 {
	return m.p.Float64LE(48)
}

// ClientOrderID_2 The Client supplied order identifier for the second order. The Server
// will remember this for the life of the order.
func (m SubmitNewOCOOrder) ClientOrderID_2() string {
	return m.p.StringVLS(56)
}

// OrderType_2 The order type for the second order. For list of order types, refer to
// OrderTypeEnum.
func (m SubmitNewOCOOrder) OrderType_2() OrderTypeEnum {
	return OrderTypeEnum(m.p.Int32LE(60))
}

// BuySell_2 The side for the second order. Either Buy or Sell.
func (m SubmitNewOCOOrder) BuySell_2() BuySellEnum {
	return BuySellEnum(m.p.Int32LE(64))
}

// Price1_2 This is the price of the second order. This is the limit price for a Limit
// order, the stop price for a Stop order, or the trigger price for a Market
// if Touched order.
func (m SubmitNewOCOOrder) Price1_2() float64 {
	return m.p.Float64LE(72)
}

// Price2_2 This is the second price for the second order. For a Stop-Limit order,
// this is the limit price. Price2_2 only applies to Stop-Limit orders.
func (m SubmitNewOCOOrder) Price2_2() float64 {
	return m.p.Float64LE(80)
}

// Quantity_2 The quantity for the second order.
func (m SubmitNewOCOOrder) Quantity_2() float64 {
	return m.p.Float64LE(88)
}

// TimeInForce The Time in Force for the order or orders (in the case of an OCO order).
// The Time in Force for the order or orders (in the case of an OCO order).
//
// For more information, refer to TimeInForceEnum.
func (m SubmitNewOCOOrder) TimeInForce() TimeInForceEnum {
	return TimeInForceEnum(m.p.Int32LE(96))
}

// GoodTillDateTime In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
// the expiration Date-Time of the order. This applies to both of the orders
// in the OCO pair.
func (m SubmitNewOCOOrder) GoodTillDateTime() DateTime {
	return DateTime(m.p.Int64LE(104))
}

// TradeAccount This is the trade account as a text string that the orders belong to.
func (m SubmitNewOCOOrder) TradeAccount() string {
	return m.p.StringVLS(112)
}

// IsAutomatedOrder Set to 1 for an order submitted by an automated trading system.
func (m SubmitNewOCOOrder) IsAutomatedOrder() bool {
	return m.p.Bool(116)
}

// ParentTriggerClientOrderID Optional: This field supports the submission of an OCO order pair which
// has a parent. This is known as a Bracket order.
//
// For complete documentation for bracket orders, refer to Bracket Order
// Procedures.
func (m SubmitNewOCOOrder) ParentTriggerClientOrderID() string {
	return m.p.StringVLS(118)
}

// FreeFormText Optional: This is an optional text string which can be set by the Client
// to associate text with each of the OCO orders. The Server is not under
// any obligation to use this text and it may place a limitation on the length
// of this text.
func (m SubmitNewOCOOrder) FreeFormText() string {
	return m.p.StringVLS(122)
}

// OpenOrClose For the description for this field, refer to OpenCloseTradeEnum.
func (m SubmitNewOCOOrder) OpenOrClose() OpenCloseTradeEnum {
	return OpenCloseTradeEnum(m.p.Int32LE(128))
}

// PartialFillHandling Specifies how partial fills should be handled when when one of the orders
// in the OCO order set partially fills.
//
// For the possible values, refer to PartialFillHandlingEnum.
func (m SubmitNewOCOOrder) PartialFillHandling() PartialFillHandlingEnum {
	return PartialFillHandlingEnum(m.p.Int8(132))
}

// UseOffsets This field is only relevant to a Bracket order which is the case when
// the ParentTriggerClientOrderID field is set.
//
// UseOffsets can be set to 1 and indicates that the OffsetFromParent1 and
// OffsetFromParent2 fields specify the two OCO order prices as a price offset
// from the parent order Price1 field, rather than an absolute price. In
// this case Price1_1 and Price1_2 are not used.
//
// When UseOffsets is set to 0, the default, then the OCO order prices are
// specified with Price1_1 and Price1_2.
//
// When UseOffsets is set to 1 and the OffsetFromParent1 and OffsetFromParent2
// fields are set, it is necessary that the parent order Price1 field be
// set even in the case of a Market order type. In the case of a Market order
// type use the current order price. This is so that the server has a reference
// price for the offsets in case it needs to translate them to actual prices.
// price for the offsets in case it needs to translate them to actual prices.
//
// When the parent order fills, it is expected the Server will maintain the
// specified offsets to the parent order fill price for the Target and Stop
// orders.
//
// A Server is not required to support this field.
func (m SubmitNewOCOOrder) UseOffsets() bool {
	return m.p.Bool(133)
}

// OffsetFromParent1 When UseOffsets is set to 1, then this field specifies the Price1_1 price
// as an offset from the parent order. In this case Price1_1 will not be
// set in the message. Instead the Server calculates that price from this
// offset and parent order price.
//
// This needs to always be set to a positive price value which is an offset
// from the parent order price. The Server will make the correct calculation
// based upon the Side and Order Type.
//
// A Server is not required to support this field.
func (m SubmitNewOCOOrder) OffsetFromParent1() float64 {
	return m.p.Float64LE(136)
}

// OffsetFromParent2 When UseOffsets is set to 1, then this field specifies the Price1_2 price
// as an offset from the parent order. In this case Price1_2 will not be
// set in the message. Instead the Server calculates that price from this
// offset and parent order price.
//
// This needs to always be set to a positive price value which is an offset
// from the parent order price. The Server will make the correct calculation
// based upon the Side and Order Type.
//
// A Server is not required to support this field.
func (m SubmitNewOCOOrder) OffsetFromParent2() float64 {
	return m.p.Float64LE(144)
}

// MaintainSamePricesOnParentFill
func (m SubmitNewOCOOrder) MaintainSamePricesOnParentFill() uint8 {
	return m.p.Uint8(152)
}

// Price1_1AsString
func (m SubmitNewOCOOrder) Price1_1AsString() string {
	return m.p.StringVLS(154)
}

// Price2_1AsString
func (m SubmitNewOCOOrder) Price2_1AsString() string {
	return m.p.StringVLS(158)
}

// Price1_2AsString
func (m SubmitNewOCOOrder) Price1_2AsString() string {
	return m.p.StringVLS(162)
}

// Price2_2AsString
func (m SubmitNewOCOOrder) Price2_2AsString() string {
	return m.p.StringVLS(166)
}

// Size The standard message size field. Automatically set by constructor.
func (m SubmitNewOCOOrderFixed) Size() uint16 {
	return m.p.Uint16LE(0)
}

// Type The standard message type field. Automatically set by constructor.
func (m SubmitNewOCOOrderFixed) Type() uint16 {
	return m.p.Uint16LE(2)
}

// Symbol The symbol for the order.
func (m SubmitNewOCOOrderFixed) Symbol() string {
	return m.p.StringFixed(4, 64)
}

// Exchange The optional exchange for the symbol.
func (m SubmitNewOCOOrderFixed) Exchange() string {
	return m.p.StringFixed(68, 16)
}

// ClientOrderID_1 The Client supplied order identifier for the first order. The Server will
// remember this for the life of the order.
func (m SubmitNewOCOOrderFixed) ClientOrderID_1() string {
	return m.p.StringFixed(84, 32)
}

// OrderType_1 The order type for the first order. For list of order types, refer to
// OrderTypeEnum.
func (m SubmitNewOCOOrderFixed) OrderType_1() OrderTypeEnum {
	return OrderTypeEnum(m.p.Int32LE(116))
}

// BuySell_1 The side for the first order. Either Buy or Sell.
func (m SubmitNewOCOOrderFixed) BuySell_1() BuySellEnum {
	return BuySellEnum(m.p.Int32LE(120))
}

// Price1_1 This is the price of the first order. This is the limit price for a Limit
// order, the stop price for a Stop order, or the trigger price for a Market
// if Touched order.
func (m SubmitNewOCOOrderFixed) Price1_1() float64 {
	return m.p.Float64LE(128)
}

// Price2_1 This is the second price for the first order. For a Stop-Limit order,
// this is the limit price. Price2_1 only applies to Stop-Limit orders.
func (m SubmitNewOCOOrderFixed) Price2_1() float64 {
	return m.p.Float64LE(136)
}

// Quantity_1 The quantity for the first order.
func (m SubmitNewOCOOrderFixed) Quantity_1() float64 {
	return m.p.Float64LE(144)
}

// ClientOrderID_2 The Client supplied order identifier for the second order. The Server
// will remember this for the life of the order.
func (m SubmitNewOCOOrderFixed) ClientOrderID_2() string {
	return m.p.StringFixed(152, 32)
}

// OrderType_2 The order type for the second order. For list of order types, refer to
// OrderTypeEnum.
func (m SubmitNewOCOOrderFixed) OrderType_2() OrderTypeEnum {
	return OrderTypeEnum(m.p.Int32LE(184))
}

// BuySell_2 The side for the second order. Either Buy or Sell.
func (m SubmitNewOCOOrderFixed) BuySell_2() BuySellEnum {
	return BuySellEnum(m.p.Int32LE(188))
}

// Price1_2 This is the price of the second order. This is the limit price for a Limit
// order, the stop price for a Stop order, or the trigger price for a Market
// if Touched order.
func (m SubmitNewOCOOrderFixed) Price1_2() float64 {
	return m.p.Float64LE(192)
}

// Price2_2 This is the second price for the second order. For a Stop-Limit order,
// this is the limit price. Price2_2 only applies to Stop-Limit orders.
func (m SubmitNewOCOOrderFixed) Price2_2() float64 {
	return m.p.Float64LE(200)
}

// Quantity_2 The quantity for the second order.
func (m SubmitNewOCOOrderFixed) Quantity_2() float64 {
	return m.p.Float64LE(208)
}

// TimeInForce The Time in Force for the order or orders (in the case of an OCO order).
// The Time in Force for the order or orders (in the case of an OCO order).
//
// For more information, refer to TimeInForceEnum.
func (m SubmitNewOCOOrderFixed) TimeInForce() TimeInForceEnum {
	return TimeInForceEnum(m.p.Int32LE(216))
}

// GoodTillDateTime In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
// the expiration Date-Time of the order. This applies to both of the orders
// in the OCO pair.
func (m SubmitNewOCOOrderFixed) GoodTillDateTime() DateTime {
	return DateTime(m.p.Int64LE(224))
}

// TradeAccount This is the trade account as a text string that the orders belong to.
func (m SubmitNewOCOOrderFixed) TradeAccount() string {
	return m.p.StringFixed(232, 32)
}

// IsAutomatedOrder Set to 1 for an order submitted by an automated trading system.
func (m SubmitNewOCOOrderFixed) IsAutomatedOrder() bool {
	return m.p.Bool(264)
}

// ParentTriggerClientOrderID Optional: This field supports the submission of an OCO order pair which
// has a parent. This is known as a Bracket order.
//
// For complete documentation for bracket orders, refer to Bracket Order
// Procedures.
func (m SubmitNewOCOOrderFixed) ParentTriggerClientOrderID() string {
	return m.p.StringFixed(265, 32)
}

// FreeFormText Optional: This is an optional text string which can be set by the Client
// to associate text with each of the OCO orders. The Server is not under
// any obligation to use this text and it may place a limitation on the length
// of this text.
func (m SubmitNewOCOOrderFixed) FreeFormText() string {
	return m.p.StringFixed(297, 48)
}

// OpenOrClose For the description for this field, refer to OpenCloseTradeEnum.
func (m SubmitNewOCOOrderFixed) OpenOrClose() OpenCloseTradeEnum {
	return OpenCloseTradeEnum(m.p.Int32LE(348))
}

// PartialFillHandling Specifies how partial fills should be handled when when one of the orders
// in the OCO order set partially fills.
//
// For the possible values, refer to PartialFillHandlingEnum.
func (m SubmitNewOCOOrderFixed) PartialFillHandling() PartialFillHandlingEnum {
	return PartialFillHandlingEnum(m.p.Int8(352))
}

// UseOffsets This field is only relevant to a Bracket order which is the case when
// the ParentTriggerClientOrderID field is set.
//
// UseOffsets can be set to 1 and indicates that the OffsetFromParent1 and
// OffsetFromParent2 fields specify the two OCO order prices as a price offset
// from the parent order Price1 field, rather than an absolute price. In
// this case Price1_1 and Price1_2 are not used.
//
// When UseOffsets is set to 0, the default, then the OCO order prices are
// specified with Price1_1 and Price1_2.
//
// When UseOffsets is set to 1 and the OffsetFromParent1 and OffsetFromParent2
// fields are set, it is necessary that the parent order Price1 field be
// set even in the case of a Market order type. In the case of a Market order
// type use the current order price. This is so that the server has a reference
// price for the offsets in case it needs to translate them to actual prices.
// price for the offsets in case it needs to translate them to actual prices.
//
// When the parent order fills, it is expected the Server will maintain the
// specified offsets to the parent order fill price for the Target and Stop
// orders.
//
// A Server is not required to support this field.
func (m SubmitNewOCOOrderFixed) UseOffsets() bool {
	return m.p.Bool(353)
}

// OffsetFromParent1 When UseOffsets is set to 1, then this field specifies the Price1_1 price
// as an offset from the parent order. In this case Price1_1 will not be
// set in the message. Instead the Server calculates that price from this
// offset and parent order price.
//
// This needs to always be set to a positive price value which is an offset
// from the parent order price. The Server will make the correct calculation
// based upon the Side and Order Type.
//
// A Server is not required to support this field.
func (m SubmitNewOCOOrderFixed) OffsetFromParent1() float64 {
	return m.p.Float64LE(360)
}

// OffsetFromParent2 When UseOffsets is set to 1, then this field specifies the Price1_2 price
// as an offset from the parent order. In this case Price1_2 will not be
// set in the message. Instead the Server calculates that price from this
// offset and parent order price.
//
// This needs to always be set to a positive price value which is an offset
// from the parent order price. The Server will make the correct calculation
// based upon the Side and Order Type.
//
// A Server is not required to support this field.
func (m SubmitNewOCOOrderFixed) OffsetFromParent2() float64 {
	return m.p.Float64LE(368)
}

// MaintainSamePricesOnParentFill
func (m SubmitNewOCOOrderFixed) MaintainSamePricesOnParentFill() uint8 {
	return m.p.Uint8(376)
}

// Price1_1AsString
func (m SubmitNewOCOOrderFixed) Price1_1AsString() string {
	return m.p.StringFixed(377, 16)
}

// Price2_1AsString
func (m SubmitNewOCOOrderFixed) Price2_1AsString() string {
	return m.p.StringFixed(393, 16)
}

// Price1_2AsString
func (m SubmitNewOCOOrderFixed) Price1_2AsString() string {
	return m.p.StringFixed(409, 16)
}

// Price2_2AsString
func (m SubmitNewOCOOrderFixed) Price2_2AsString() string {
	return m.p.StringFixed(425, 16)
}

// SetSymbol The symbol for the order.
func (m *SubmitNewOCOOrder) SetSymbol(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(6, value)
	return m
}

// SetExchange The optional exchange for the symbol.
func (m *SubmitNewOCOOrder) SetExchange(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(10, value)
	return m
}

// SetClientOrderID_1 The Client supplied order identifier for the first order. The Server will
// remember this for the life of the order.
func (m *SubmitNewOCOOrder) SetClientOrderID_1(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(14, value)
	return m
}

// SetOrderType_1 The order type for the first order. For list of order types, refer to
// OrderTypeEnum.
func (m *SubmitNewOCOOrder) SetOrderType_1(value OrderTypeEnum) *SubmitNewOCOOrder {
	m.p.SetInt32LE(20, int32(value))
	return m
}

// SetBuySell_1 The side for the first order. Either Buy or Sell.
func (m *SubmitNewOCOOrder) SetBuySell_1(value BuySellEnum) *SubmitNewOCOOrder {
	m.p.SetInt32LE(24, int32(value))
	return m
}

// SetPrice1_1 This is the price of the first order. This is the limit price for a Limit
// order, the stop price for a Stop order, or the trigger price for a Market
// if Touched order.
func (m *SubmitNewOCOOrder) SetPrice1_1(value float64) *SubmitNewOCOOrder {
	m.p.SetFloat64LE(32, value)
	return m
}

// SetPrice2_1 This is the second price for the first order. For a Stop-Limit order,
// this is the limit price. Price2_1 only applies to Stop-Limit orders.
func (m *SubmitNewOCOOrder) SetPrice2_1(value float64) *SubmitNewOCOOrder {
	m.p.SetFloat64LE(40, value)
	return m
}

// SetQuantity_1 The quantity for the first order.
func (m *SubmitNewOCOOrder) SetQuantity_1(value float64) *SubmitNewOCOOrder {
	m.p.SetFloat64LE(48, value)
	return m
}

// SetClientOrderID_2 The Client supplied order identifier for the second order. The Server
// will remember this for the life of the order.
func (m *SubmitNewOCOOrder) SetClientOrderID_2(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(56, value)
	return m
}

// SetOrderType_2 The order type for the second order. For list of order types, refer to
// OrderTypeEnum.
func (m *SubmitNewOCOOrder) SetOrderType_2(value OrderTypeEnum) *SubmitNewOCOOrder {
	m.p.SetInt32LE(60, int32(value))
	return m
}

// SetBuySell_2 The side for the second order. Either Buy or Sell.
func (m *SubmitNewOCOOrder) SetBuySell_2(value BuySellEnum) *SubmitNewOCOOrder {
	m.p.SetInt32LE(64, int32(value))
	return m
}

// SetPrice1_2 This is the price of the second order. This is the limit price for a Limit
// order, the stop price for a Stop order, or the trigger price for a Market
// if Touched order.
func (m *SubmitNewOCOOrder) SetPrice1_2(value float64) *SubmitNewOCOOrder {
	m.p.SetFloat64LE(72, value)
	return m
}

// SetPrice2_2 This is the second price for the second order. For a Stop-Limit order,
// this is the limit price. Price2_2 only applies to Stop-Limit orders.
func (m *SubmitNewOCOOrder) SetPrice2_2(value float64) *SubmitNewOCOOrder {
	m.p.SetFloat64LE(80, value)
	return m
}

// SetQuantity_2 The quantity for the second order.
func (m *SubmitNewOCOOrder) SetQuantity_2(value float64) *SubmitNewOCOOrder {
	m.p.SetFloat64LE(88, value)
	return m
}

// SetTimeInForce The Time in Force for the order or orders (in the case of an OCO order).
// The Time in Force for the order or orders (in the case of an OCO order).
//
// For more information, refer to TimeInForceEnum.
func (m *SubmitNewOCOOrder) SetTimeInForce(value TimeInForceEnum) *SubmitNewOCOOrder {
	m.p.SetInt32LE(96, int32(value))
	return m
}

// SetGoodTillDateTime In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
// the expiration Date-Time of the order. This applies to both of the orders
// in the OCO pair.
func (m *SubmitNewOCOOrder) SetGoodTillDateTime(value DateTime) *SubmitNewOCOOrder {
	m.p.SetInt64LE(104, int64(value))
	return m
}

// SetTradeAccount This is the trade account as a text string that the orders belong to.
func (m *SubmitNewOCOOrder) SetTradeAccount(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(112, value)
	return m
}

// SetIsAutomatedOrder Set to 1 for an order submitted by an automated trading system.
func (m *SubmitNewOCOOrder) SetIsAutomatedOrder(value bool) *SubmitNewOCOOrder {
	m.p.SetBool(116, value)
	return m
}

// SetParentTriggerClientOrderID Optional: This field supports the submission of an OCO order pair which
// has a parent. This is known as a Bracket order.
//
// For complete documentation for bracket orders, refer to Bracket Order
// Procedures.
func (m *SubmitNewOCOOrder) SetParentTriggerClientOrderID(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(118, value)
	return m
}

// SetFreeFormText Optional: This is an optional text string which can be set by the Client
// to associate text with each of the OCO orders. The Server is not under
// any obligation to use this text and it may place a limitation on the length
// of this text.
func (m *SubmitNewOCOOrder) SetFreeFormText(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(122, value)
	return m
}

// SetOpenOrClose For the description for this field, refer to OpenCloseTradeEnum.
func (m *SubmitNewOCOOrder) SetOpenOrClose(value OpenCloseTradeEnum) *SubmitNewOCOOrder {
	m.p.SetInt32LE(128, int32(value))
	return m
}

// SetPartialFillHandling Specifies how partial fills should be handled when when one of the orders
// in the OCO order set partially fills.
//
// For the possible values, refer to PartialFillHandlingEnum.
func (m *SubmitNewOCOOrder) SetPartialFillHandling(value PartialFillHandlingEnum) *SubmitNewOCOOrder {
	m.p.SetInt8(132, int8(value))
	return m
}

// SetUseOffsets This field is only relevant to a Bracket order which is the case when
// the ParentTriggerClientOrderID field is set.
//
// UseOffsets can be set to 1 and indicates that the OffsetFromParent1 and
// OffsetFromParent2 fields specify the two OCO order prices as a price offset
// from the parent order Price1 field, rather than an absolute price. In
// this case Price1_1 and Price1_2 are not used.
//
// When UseOffsets is set to 0, the default, then the OCO order prices are
// specified with Price1_1 and Price1_2.
//
// When UseOffsets is set to 1 and the OffsetFromParent1 and OffsetFromParent2
// fields are set, it is necessary that the parent order Price1 field be
// set even in the case of a Market order type. In the case of a Market order
// type use the current order price. This is so that the server has a reference
// price for the offsets in case it needs to translate them to actual prices.
// price for the offsets in case it needs to translate them to actual prices.
//
// When the parent order fills, it is expected the Server will maintain the
// specified offsets to the parent order fill price for the Target and Stop
// orders.
//
// A Server is not required to support this field.
func (m *SubmitNewOCOOrder) SetUseOffsets(value bool) *SubmitNewOCOOrder {
	m.p.SetBool(133, value)
	return m
}

// SetOffsetFromParent1 When UseOffsets is set to 1, then this field specifies the Price1_1 price
// as an offset from the parent order. In this case Price1_1 will not be
// set in the message. Instead the Server calculates that price from this
// offset and parent order price.
//
// This needs to always be set to a positive price value which is an offset
// from the parent order price. The Server will make the correct calculation
// based upon the Side and Order Type.
//
// A Server is not required to support this field.
func (m *SubmitNewOCOOrder) SetOffsetFromParent1(value float64) *SubmitNewOCOOrder {
	m.p.SetFloat64LE(136, value)
	return m
}

// SetOffsetFromParent2 When UseOffsets is set to 1, then this field specifies the Price1_2 price
// as an offset from the parent order. In this case Price1_2 will not be
// set in the message. Instead the Server calculates that price from this
// offset and parent order price.
//
// This needs to always be set to a positive price value which is an offset
// from the parent order price. The Server will make the correct calculation
// based upon the Side and Order Type.
//
// A Server is not required to support this field.
func (m *SubmitNewOCOOrder) SetOffsetFromParent2(value float64) *SubmitNewOCOOrder {
	m.p.SetFloat64LE(144, value)
	return m
}

// SetMaintainSamePricesOnParentFill
func (m *SubmitNewOCOOrder) SetMaintainSamePricesOnParentFill(value uint8) *SubmitNewOCOOrder {
	m.p.SetUint8(152, value)
	return m
}

// SetPrice1_1AsString
func (m *SubmitNewOCOOrder) SetPrice1_1AsString(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(154, value)
	return m
}

// SetPrice2_1AsString
func (m *SubmitNewOCOOrder) SetPrice2_1AsString(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(158, value)
	return m
}

// SetPrice1_2AsString
func (m *SubmitNewOCOOrder) SetPrice1_2AsString(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(162, value)
	return m
}

// SetPrice2_2AsString
func (m *SubmitNewOCOOrder) SetPrice2_2AsString(value string) *SubmitNewOCOOrder {
	m.p.SetStringVLS(166, value)
	return m
}

// SetSymbol The symbol for the order.
func (m *SubmitNewOCOOrderFixed) SetSymbol(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(4, 64, value)
	return m
}

// SetExchange The optional exchange for the symbol.
func (m *SubmitNewOCOOrderFixed) SetExchange(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(68, 16, value)
	return m
}

// SetClientOrderID_1 The Client supplied order identifier for the first order. The Server will
// remember this for the life of the order.
func (m *SubmitNewOCOOrderFixed) SetClientOrderID_1(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(84, 32, value)
	return m
}

// SetOrderType_1 The order type for the first order. For list of order types, refer to
// OrderTypeEnum.
func (m *SubmitNewOCOOrderFixed) SetOrderType_1(value OrderTypeEnum) *SubmitNewOCOOrderFixed {
	m.p.SetInt32LE(116, int32(value))
	return m
}

// SetBuySell_1 The side for the first order. Either Buy or Sell.
func (m *SubmitNewOCOOrderFixed) SetBuySell_1(value BuySellEnum) *SubmitNewOCOOrderFixed {
	m.p.SetInt32LE(120, int32(value))
	return m
}

// SetPrice1_1 This is the price of the first order. This is the limit price for a Limit
// order, the stop price for a Stop order, or the trigger price for a Market
// if Touched order.
func (m *SubmitNewOCOOrderFixed) SetPrice1_1(value float64) *SubmitNewOCOOrderFixed {
	m.p.SetFloat64LE(128, value)
	return m
}

// SetPrice2_1 This is the second price for the first order. For a Stop-Limit order,
// this is the limit price. Price2_1 only applies to Stop-Limit orders.
func (m *SubmitNewOCOOrderFixed) SetPrice2_1(value float64) *SubmitNewOCOOrderFixed {
	m.p.SetFloat64LE(136, value)
	return m
}

// SetQuantity_1 The quantity for the first order.
func (m *SubmitNewOCOOrderFixed) SetQuantity_1(value float64) *SubmitNewOCOOrderFixed {
	m.p.SetFloat64LE(144, value)
	return m
}

// SetClientOrderID_2 The Client supplied order identifier for the second order. The Server
// will remember this for the life of the order.
func (m *SubmitNewOCOOrderFixed) SetClientOrderID_2(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(152, 32, value)
	return m
}

// SetOrderType_2 The order type for the second order. For list of order types, refer to
// OrderTypeEnum.
func (m *SubmitNewOCOOrderFixed) SetOrderType_2(value OrderTypeEnum) *SubmitNewOCOOrderFixed {
	m.p.SetInt32LE(184, int32(value))
	return m
}

// SetBuySell_2 The side for the second order. Either Buy or Sell.
func (m *SubmitNewOCOOrderFixed) SetBuySell_2(value BuySellEnum) *SubmitNewOCOOrderFixed {
	m.p.SetInt32LE(188, int32(value))
	return m
}

// SetPrice1_2 This is the price of the second order. This is the limit price for a Limit
// order, the stop price for a Stop order, or the trigger price for a Market
// if Touched order.
func (m *SubmitNewOCOOrderFixed) SetPrice1_2(value float64) *SubmitNewOCOOrderFixed {
	m.p.SetFloat64LE(192, value)
	return m
}

// SetPrice2_2 This is the second price for the second order. For a Stop-Limit order,
// this is the limit price. Price2_2 only applies to Stop-Limit orders.
func (m *SubmitNewOCOOrderFixed) SetPrice2_2(value float64) *SubmitNewOCOOrderFixed {
	m.p.SetFloat64LE(200, value)
	return m
}

// SetQuantity_2 The quantity for the second order.
func (m *SubmitNewOCOOrderFixed) SetQuantity_2(value float64) *SubmitNewOCOOrderFixed {
	m.p.SetFloat64LE(208, value)
	return m
}

// SetTimeInForce The Time in Force for the order or orders (in the case of an OCO order).
// The Time in Force for the order or orders (in the case of an OCO order).
//
// For more information, refer to TimeInForceEnum.
func (m *SubmitNewOCOOrderFixed) SetTimeInForce(value TimeInForceEnum) *SubmitNewOCOOrderFixed {
	m.p.SetInt32LE(216, int32(value))
	return m
}

// SetGoodTillDateTime In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
// the expiration Date-Time of the order. This applies to both of the orders
// in the OCO pair.
func (m *SubmitNewOCOOrderFixed) SetGoodTillDateTime(value DateTime) *SubmitNewOCOOrderFixed {
	m.p.SetInt64LE(224, int64(value))
	return m
}

// SetTradeAccount This is the trade account as a text string that the orders belong to.
func (m *SubmitNewOCOOrderFixed) SetTradeAccount(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(232, 32, value)
	return m
}

// SetIsAutomatedOrder Set to 1 for an order submitted by an automated trading system.
func (m *SubmitNewOCOOrderFixed) SetIsAutomatedOrder(value bool) *SubmitNewOCOOrderFixed {
	m.p.SetBool(264, value)
	return m
}

// SetParentTriggerClientOrderID Optional: This field supports the submission of an OCO order pair which
// has a parent. This is known as a Bracket order.
//
// For complete documentation for bracket orders, refer to Bracket Order
// Procedures.
func (m *SubmitNewOCOOrderFixed) SetParentTriggerClientOrderID(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(265, 32, value)
	return m
}

// SetFreeFormText Optional: This is an optional text string which can be set by the Client
// to associate text with each of the OCO orders. The Server is not under
// any obligation to use this text and it may place a limitation on the length
// of this text.
func (m *SubmitNewOCOOrderFixed) SetFreeFormText(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(297, 48, value)
	return m
}

// SetOpenOrClose For the description for this field, refer to OpenCloseTradeEnum.
func (m *SubmitNewOCOOrderFixed) SetOpenOrClose(value OpenCloseTradeEnum) *SubmitNewOCOOrderFixed {
	m.p.SetInt32LE(348, int32(value))
	return m
}

// SetPartialFillHandling Specifies how partial fills should be handled when when one of the orders
// in the OCO order set partially fills.
//
// For the possible values, refer to PartialFillHandlingEnum.
func (m *SubmitNewOCOOrderFixed) SetPartialFillHandling(value PartialFillHandlingEnum) *SubmitNewOCOOrderFixed {
	m.p.SetInt8(352, int8(value))
	return m
}

// SetUseOffsets This field is only relevant to a Bracket order which is the case when
// the ParentTriggerClientOrderID field is set.
//
// UseOffsets can be set to 1 and indicates that the OffsetFromParent1 and
// OffsetFromParent2 fields specify the two OCO order prices as a price offset
// from the parent order Price1 field, rather than an absolute price. In
// this case Price1_1 and Price1_2 are not used.
//
// When UseOffsets is set to 0, the default, then the OCO order prices are
// specified with Price1_1 and Price1_2.
//
// When UseOffsets is set to 1 and the OffsetFromParent1 and OffsetFromParent2
// fields are set, it is necessary that the parent order Price1 field be
// set even in the case of a Market order type. In the case of a Market order
// type use the current order price. This is so that the server has a reference
// price for the offsets in case it needs to translate them to actual prices.
// price for the offsets in case it needs to translate them to actual prices.
//
// When the parent order fills, it is expected the Server will maintain the
// specified offsets to the parent order fill price for the Target and Stop
// orders.
//
// A Server is not required to support this field.
func (m *SubmitNewOCOOrderFixed) SetUseOffsets(value bool) *SubmitNewOCOOrderFixed {
	m.p.SetBool(353, value)
	return m
}

// SetOffsetFromParent1 When UseOffsets is set to 1, then this field specifies the Price1_1 price
// as an offset from the parent order. In this case Price1_1 will not be
// set in the message. Instead the Server calculates that price from this
// offset and parent order price.
//
// This needs to always be set to a positive price value which is an offset
// from the parent order price. The Server will make the correct calculation
// based upon the Side and Order Type.
//
// A Server is not required to support this field.
func (m *SubmitNewOCOOrderFixed) SetOffsetFromParent1(value float64) *SubmitNewOCOOrderFixed {
	m.p.SetFloat64LE(360, value)
	return m
}

// SetOffsetFromParent2 When UseOffsets is set to 1, then this field specifies the Price1_2 price
// as an offset from the parent order. In this case Price1_2 will not be
// set in the message. Instead the Server calculates that price from this
// offset and parent order price.
//
// This needs to always be set to a positive price value which is an offset
// from the parent order price. The Server will make the correct calculation
// based upon the Side and Order Type.
//
// A Server is not required to support this field.
func (m *SubmitNewOCOOrderFixed) SetOffsetFromParent2(value float64) *SubmitNewOCOOrderFixed {
	m.p.SetFloat64LE(368, value)
	return m
}

// SetMaintainSamePricesOnParentFill
func (m *SubmitNewOCOOrderFixed) SetMaintainSamePricesOnParentFill(value uint8) *SubmitNewOCOOrderFixed {
	m.p.SetUint8(376, value)
	return m
}

// SetPrice1_1AsString
func (m *SubmitNewOCOOrderFixed) SetPrice1_1AsString(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(377, 16, value)
	return m
}

// SetPrice2_1AsString
func (m *SubmitNewOCOOrderFixed) SetPrice2_1AsString(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(393, 16, value)
	return m
}

// SetPrice1_2AsString
func (m *SubmitNewOCOOrderFixed) SetPrice1_2AsString(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(409, 16, value)
	return m
}

// SetPrice2_2AsString
func (m *SubmitNewOCOOrderFixed) SetPrice2_2AsString(value string) *SubmitNewOCOOrderFixed {
	m.p.SetStringFixed(425, 16, value)
	return m
}

func (m *SubmitNewOCOOrder) WriteTo(w io.Writer) (int64, error) {
	s := int(m.Size())
	n, err := w.Write(m.p.AsBytes(s))
	return int64(n), err
}

func (m *SubmitNewOCOOrder) MarshalBinary() ([]byte, error) {
	return m.p.AsBytes(int(m.Size())), nil
}

func (m *SubmitNewOCOOrder) Clone() *SubmitNewOCOOrder {
	return &SubmitNewOCOOrder{message.WrapVLSPointer(m.p.Clone(uintptr(m.Size())), int(m.Size()))}
}

func (m *SubmitNewOCOOrderFixed) WriteTo(w io.Writer) (int64, error) {
	s := int(m.Size())
	n, err := w.Write(m.p.AsBytes(s))
	return int64(n), err
}

func (m *SubmitNewOCOOrderFixed) MarshalBinary() ([]byte, error) {
	return m.p.AsBytes(int(m.Size())), nil
}

func (m *SubmitNewOCOOrderFixed) Clone() *SubmitNewOCOOrderFixed {
	return &SubmitNewOCOOrderFixed{message.WrapFixedPointer(m.p.Clone(uintptr(m.Size())))}
}

// Copy
func (m SubmitNewOCOOrder) Copy(to SubmitNewOCOOrder) {
	to.SetSymbol(m.Symbol())
	to.SetExchange(m.Exchange())
	to.SetClientOrderID_1(m.ClientOrderID_1())
	to.SetOrderType_1(m.OrderType_1())
	to.SetBuySell_1(m.BuySell_1())
	to.SetPrice1_1(m.Price1_1())
	to.SetPrice2_1(m.Price2_1())
	to.SetQuantity_1(m.Quantity_1())
	to.SetClientOrderID_2(m.ClientOrderID_2())
	to.SetOrderType_2(m.OrderType_2())
	to.SetBuySell_2(m.BuySell_2())
	to.SetPrice1_2(m.Price1_2())
	to.SetPrice2_2(m.Price2_2())
	to.SetQuantity_2(m.Quantity_2())
	to.SetTimeInForce(m.TimeInForce())
	to.SetGoodTillDateTime(m.GoodTillDateTime())
	to.SetTradeAccount(m.TradeAccount())
	to.SetIsAutomatedOrder(m.IsAutomatedOrder())
	to.SetParentTriggerClientOrderID(m.ParentTriggerClientOrderID())
	to.SetFreeFormText(m.FreeFormText())
	to.SetOpenOrClose(m.OpenOrClose())
	to.SetPartialFillHandling(m.PartialFillHandling())
	to.SetUseOffsets(m.UseOffsets())
	to.SetOffsetFromParent1(m.OffsetFromParent1())
	to.SetOffsetFromParent2(m.OffsetFromParent2())
	to.SetMaintainSamePricesOnParentFill(m.MaintainSamePricesOnParentFill())
	to.SetPrice1_1AsString(m.Price1_1AsString())
	to.SetPrice2_1AsString(m.Price2_1AsString())
	to.SetPrice1_2AsString(m.Price1_2AsString())
	to.SetPrice2_2AsString(m.Price2_2AsString())
}

// CopyTo
func (m SubmitNewOCOOrder) CopyTo(to SubmitNewOCOOrderFixed) {
	to.SetSymbol(m.Symbol())
	to.SetExchange(m.Exchange())
	to.SetClientOrderID_1(m.ClientOrderID_1())
	to.SetOrderType_1(m.OrderType_1())
	to.SetBuySell_1(m.BuySell_1())
	to.SetPrice1_1(m.Price1_1())
	to.SetPrice2_1(m.Price2_1())
	to.SetQuantity_1(m.Quantity_1())
	to.SetClientOrderID_2(m.ClientOrderID_2())
	to.SetOrderType_2(m.OrderType_2())
	to.SetBuySell_2(m.BuySell_2())
	to.SetPrice1_2(m.Price1_2())
	to.SetPrice2_2(m.Price2_2())
	to.SetQuantity_2(m.Quantity_2())
	to.SetTimeInForce(m.TimeInForce())
	to.SetGoodTillDateTime(m.GoodTillDateTime())
	to.SetTradeAccount(m.TradeAccount())
	to.SetIsAutomatedOrder(m.IsAutomatedOrder())
	to.SetParentTriggerClientOrderID(m.ParentTriggerClientOrderID())
	to.SetFreeFormText(m.FreeFormText())
	to.SetOpenOrClose(m.OpenOrClose())
	to.SetPartialFillHandling(m.PartialFillHandling())
	to.SetUseOffsets(m.UseOffsets())
	to.SetOffsetFromParent1(m.OffsetFromParent1())
	to.SetOffsetFromParent2(m.OffsetFromParent2())
	to.SetMaintainSamePricesOnParentFill(m.MaintainSamePricesOnParentFill())
	to.SetPrice1_1AsString(m.Price1_1AsString())
	to.SetPrice2_1AsString(m.Price2_1AsString())
	to.SetPrice1_2AsString(m.Price1_2AsString())
	to.SetPrice2_2AsString(m.Price2_2AsString())
}

// Copy
func (m SubmitNewOCOOrderFixed) Copy(to SubmitNewOCOOrderFixed) {
	to.SetSymbol(m.Symbol())
	to.SetExchange(m.Exchange())
	to.SetClientOrderID_1(m.ClientOrderID_1())
	to.SetOrderType_1(m.OrderType_1())
	to.SetBuySell_1(m.BuySell_1())
	to.SetPrice1_1(m.Price1_1())
	to.SetPrice2_1(m.Price2_1())
	to.SetQuantity_1(m.Quantity_1())
	to.SetClientOrderID_2(m.ClientOrderID_2())
	to.SetOrderType_2(m.OrderType_2())
	to.SetBuySell_2(m.BuySell_2())
	to.SetPrice1_2(m.Price1_2())
	to.SetPrice2_2(m.Price2_2())
	to.SetQuantity_2(m.Quantity_2())
	to.SetTimeInForce(m.TimeInForce())
	to.SetGoodTillDateTime(m.GoodTillDateTime())
	to.SetTradeAccount(m.TradeAccount())
	to.SetIsAutomatedOrder(m.IsAutomatedOrder())
	to.SetParentTriggerClientOrderID(m.ParentTriggerClientOrderID())
	to.SetFreeFormText(m.FreeFormText())
	to.SetOpenOrClose(m.OpenOrClose())
	to.SetPartialFillHandling(m.PartialFillHandling())
	to.SetUseOffsets(m.UseOffsets())
	to.SetOffsetFromParent1(m.OffsetFromParent1())
	to.SetOffsetFromParent2(m.OffsetFromParent2())
	to.SetMaintainSamePricesOnParentFill(m.MaintainSamePricesOnParentFill())
	to.SetPrice1_1AsString(m.Price1_1AsString())
	to.SetPrice2_1AsString(m.Price2_1AsString())
	to.SetPrice1_2AsString(m.Price1_2AsString())
	to.SetPrice2_2AsString(m.Price2_2AsString())
}

// CopyTo
func (m SubmitNewOCOOrderFixed) CopyTo(to SubmitNewOCOOrder) {
	to.SetSymbol(m.Symbol())
	to.SetExchange(m.Exchange())
	to.SetClientOrderID_1(m.ClientOrderID_1())
	to.SetOrderType_1(m.OrderType_1())
	to.SetBuySell_1(m.BuySell_1())
	to.SetPrice1_1(m.Price1_1())
	to.SetPrice2_1(m.Price2_1())
	to.SetQuantity_1(m.Quantity_1())
	to.SetClientOrderID_2(m.ClientOrderID_2())
	to.SetOrderType_2(m.OrderType_2())
	to.SetBuySell_2(m.BuySell_2())
	to.SetPrice1_2(m.Price1_2())
	to.SetPrice2_2(m.Price2_2())
	to.SetQuantity_2(m.Quantity_2())
	to.SetTimeInForce(m.TimeInForce())
	to.SetGoodTillDateTime(m.GoodTillDateTime())
	to.SetTradeAccount(m.TradeAccount())
	to.SetIsAutomatedOrder(m.IsAutomatedOrder())
	to.SetParentTriggerClientOrderID(m.ParentTriggerClientOrderID())
	to.SetFreeFormText(m.FreeFormText())
	to.SetOpenOrClose(m.OpenOrClose())
	to.SetPartialFillHandling(m.PartialFillHandling())
	to.SetUseOffsets(m.UseOffsets())
	to.SetOffsetFromParent1(m.OffsetFromParent1())
	to.SetOffsetFromParent2(m.OffsetFromParent2())
	to.SetMaintainSamePricesOnParentFill(m.MaintainSamePricesOnParentFill())
	to.SetPrice1_1AsString(m.Price1_1AsString())
	to.SetPrice2_1AsString(m.Price2_1AsString())
	to.SetPrice1_2AsString(m.Price1_2AsString())
	to.SetPrice2_2AsString(m.Price2_2AsString())
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Marshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *SubmitNewOCOOrder) MarshalJSON() ([]byte, error) {
	return m.MarshalJSONTo(nil)
}

func (m *SubmitNewOCOOrder) MarshalJSONTo(b []byte) ([]byte, error) {
	w := json.NewWriter(b, 201)
	w.StringField("Symbol", m.Symbol())
	w.StringField("Exchange", m.Exchange())
	w.StringField("ClientOrderID_1", m.ClientOrderID_1())
	w.Int32Field("OrderType_1", int32(m.OrderType_1()))
	w.Int32Field("BuySell_1", int32(m.BuySell_1()))
	w.Float64Field("Price1_1", m.Price1_1())
	w.Float64Field("Price2_1", m.Price2_1())
	w.Float64Field("Quantity_1", m.Quantity_1())
	w.StringField("ClientOrderID_2", m.ClientOrderID_2())
	w.Int32Field("OrderType_2", int32(m.OrderType_2()))
	w.Int32Field("BuySell_2", int32(m.BuySell_2()))
	w.Float64Field("Price1_2", m.Price1_2())
	w.Float64Field("Price2_2", m.Price2_2())
	w.Float64Field("Quantity_2", m.Quantity_2())
	w.Int32Field("TimeInForce", int32(m.TimeInForce()))
	w.Int64Field("GoodTillDateTime", int64(m.GoodTillDateTime()))
	w.StringField("TradeAccount", m.TradeAccount())
	w.BoolField("IsAutomatedOrder", m.IsAutomatedOrder())
	w.StringField("ParentTriggerClientOrderID", m.ParentTriggerClientOrderID())
	w.StringField("FreeFormText", m.FreeFormText())
	w.Int32Field("OpenOrClose", int32(m.OpenOrClose()))
	w.Int8Field("PartialFillHandling", int8(m.PartialFillHandling()))
	w.BoolField("UseOffsets", m.UseOffsets())
	w.Float64Field("OffsetFromParent1", m.OffsetFromParent1())
	w.Float64Field("OffsetFromParent2", m.OffsetFromParent2())
	w.Uint8Field("MaintainSamePricesOnParentFill", m.MaintainSamePricesOnParentFill())
	w.StringField("Price1_1AsString", m.Price1_1AsString())
	w.StringField("Price2_1AsString", m.Price2_1AsString())
	w.StringField("Price1_2AsString", m.Price1_2AsString())
	w.StringField("Price2_2AsString", m.Price2_2AsString())
	return w.Finish(), nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Unmarshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *SubmitNewOCOOrder) UnmarshalJSON(b []byte) error {
	r, err := json.OpenReader(b)
	if err != nil {
		return err
	}
	return m.UnmarshalJSONFromReader(&r)
}

func (m *SubmitNewOCOOrder) UnmarshalJSONFromReader(r *json.Reader) error {
	if r.Type != 201 {
		return message.ErrWrongType
	}
	in := &r.Lexer
LOOP:
	for !in.IsDelim('}') {
		key, err := r.FieldName()
		if err != nil {
			return err
		}
		switch key {
		case "Symbol":
			m.SetSymbol(r.String())
		case "Exchange":
			m.SetExchange(r.String())
		case "ClientOrderID_1":
			m.SetClientOrderID_1(r.String())
		case "OrderType_1":
			m.SetOrderType_1(OrderTypeEnum(r.Int32()))
		case "BuySell_1":
			m.SetBuySell_1(BuySellEnum(r.Int32()))
		case "Price1_1":
			m.SetPrice1_1(r.Float64())
		case "Price2_1":
			m.SetPrice2_1(r.Float64())
		case "Quantity_1":
			m.SetQuantity_1(r.Float64())
		case "ClientOrderID_2":
			m.SetClientOrderID_2(r.String())
		case "OrderType_2":
			m.SetOrderType_2(OrderTypeEnum(r.Int32()))
		case "BuySell_2":
			m.SetBuySell_2(BuySellEnum(r.Int32()))
		case "Price1_2":
			m.SetPrice1_2(r.Float64())
		case "Price2_2":
			m.SetPrice2_2(r.Float64())
		case "Quantity_2":
			m.SetQuantity_2(r.Float64())
		case "TimeInForce":
			m.SetTimeInForce(TimeInForceEnum(r.Int32()))
		case "GoodTillDateTime":
			m.SetGoodTillDateTime(DateTime(r.Int64()))
		case "TradeAccount":
			m.SetTradeAccount(r.String())
		case "IsAutomatedOrder":
			m.SetIsAutomatedOrder(r.Bool())
		case "ParentTriggerClientOrderID":
			m.SetParentTriggerClientOrderID(r.String())
		case "FreeFormText":
			m.SetFreeFormText(r.String())
		case "OpenOrClose":
			m.SetOpenOrClose(OpenCloseTradeEnum(r.Int32()))
		case "PartialFillHandling":
			m.SetPartialFillHandling(PartialFillHandlingEnum(r.Int8()))
		case "UseOffsets":
			m.SetUseOffsets(r.Bool())
		case "OffsetFromParent1":
			m.SetOffsetFromParent1(r.Float64())
		case "OffsetFromParent2":
			m.SetOffsetFromParent2(r.Float64())
		case "MaintainSamePricesOnParentFill":
			m.SetMaintainSamePricesOnParentFill(r.Uint8())
		case "Price1_1AsString":
			m.SetPrice1_1AsString(r.String())
		case "Price2_1AsString":
			m.SetPrice2_1AsString(r.String())
		case "Price1_2AsString":
			m.SetPrice1_2AsString(r.String())
		case "Price2_2AsString":
			m.SetPrice2_2AsString(r.String())
		case "f", "F":
			return message.ErrJSONCompactDetected
		case "":
			break LOOP
		default:
			in.SkipRecursive()
		}
		if r.IsError() {
			return r.Error()
		}
		in.WantComma()
	}
	return nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Marshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *SubmitNewOCOOrderFixed) MarshalJSON() ([]byte, error) {
	return m.MarshalJSONTo(nil)
}

func (m *SubmitNewOCOOrderFixed) MarshalJSONTo(b []byte) ([]byte, error) {
	w := json.NewWriter(b, 201)
	w.StringField("Symbol", m.Symbol())
	w.StringField("Exchange", m.Exchange())
	w.StringField("ClientOrderID_1", m.ClientOrderID_1())
	w.Int32Field("OrderType_1", int32(m.OrderType_1()))
	w.Int32Field("BuySell_1", int32(m.BuySell_1()))
	w.Float64Field("Price1_1", m.Price1_1())
	w.Float64Field("Price2_1", m.Price2_1())
	w.Float64Field("Quantity_1", m.Quantity_1())
	w.StringField("ClientOrderID_2", m.ClientOrderID_2())
	w.Int32Field("OrderType_2", int32(m.OrderType_2()))
	w.Int32Field("BuySell_2", int32(m.BuySell_2()))
	w.Float64Field("Price1_2", m.Price1_2())
	w.Float64Field("Price2_2", m.Price2_2())
	w.Float64Field("Quantity_2", m.Quantity_2())
	w.Int32Field("TimeInForce", int32(m.TimeInForce()))
	w.Int64Field("GoodTillDateTime", int64(m.GoodTillDateTime()))
	w.StringField("TradeAccount", m.TradeAccount())
	w.BoolField("IsAutomatedOrder", m.IsAutomatedOrder())
	w.StringField("ParentTriggerClientOrderID", m.ParentTriggerClientOrderID())
	w.StringField("FreeFormText", m.FreeFormText())
	w.Int32Field("OpenOrClose", int32(m.OpenOrClose()))
	w.Int8Field("PartialFillHandling", int8(m.PartialFillHandling()))
	w.BoolField("UseOffsets", m.UseOffsets())
	w.Float64Field("OffsetFromParent1", m.OffsetFromParent1())
	w.Float64Field("OffsetFromParent2", m.OffsetFromParent2())
	w.Uint8Field("MaintainSamePricesOnParentFill", m.MaintainSamePricesOnParentFill())
	w.StringField("Price1_1AsString", m.Price1_1AsString())
	w.StringField("Price2_1AsString", m.Price2_1AsString())
	w.StringField("Price1_2AsString", m.Price1_2AsString())
	w.StringField("Price2_2AsString", m.Price2_2AsString())
	return w.Finish(), nil
}

//////////////////////////////////////////////////////////////////////////////////////////
// JSON Unmarshal
//////////////////////////////////////////////////////////////////////////////////////////

func (m *SubmitNewOCOOrderFixed) UnmarshalJSON(b []byte) error {
	r, err := json.OpenReader(b)
	if err != nil {
		return err
	}
	return m.UnmarshalJSONFromReader(&r)
}

func (m *SubmitNewOCOOrderFixed) UnmarshalJSONFromReader(r *json.Reader) error {
	if r.Type != 201 {
		return message.ErrWrongType
	}
	in := &r.Lexer
LOOP:
	for !in.IsDelim('}') {
		key, err := r.FieldName()
		if err != nil {
			return err
		}
		switch key {
		case "Symbol":
			m.SetSymbol(r.String())
		case "Exchange":
			m.SetExchange(r.String())
		case "ClientOrderID_1":
			m.SetClientOrderID_1(r.String())
		case "OrderType_1":
			m.SetOrderType_1(OrderTypeEnum(r.Int32()))
		case "BuySell_1":
			m.SetBuySell_1(BuySellEnum(r.Int32()))
		case "Price1_1":
			m.SetPrice1_1(r.Float64())
		case "Price2_1":
			m.SetPrice2_1(r.Float64())
		case "Quantity_1":
			m.SetQuantity_1(r.Float64())
		case "ClientOrderID_2":
			m.SetClientOrderID_2(r.String())
		case "OrderType_2":
			m.SetOrderType_2(OrderTypeEnum(r.Int32()))
		case "BuySell_2":
			m.SetBuySell_2(BuySellEnum(r.Int32()))
		case "Price1_2":
			m.SetPrice1_2(r.Float64())
		case "Price2_2":
			m.SetPrice2_2(r.Float64())
		case "Quantity_2":
			m.SetQuantity_2(r.Float64())
		case "TimeInForce":
			m.SetTimeInForce(TimeInForceEnum(r.Int32()))
		case "GoodTillDateTime":
			m.SetGoodTillDateTime(DateTime(r.Int64()))
		case "TradeAccount":
			m.SetTradeAccount(r.String())
		case "IsAutomatedOrder":
			m.SetIsAutomatedOrder(r.Bool())
		case "ParentTriggerClientOrderID":
			m.SetParentTriggerClientOrderID(r.String())
		case "FreeFormText":
			m.SetFreeFormText(r.String())
		case "OpenOrClose":
			m.SetOpenOrClose(OpenCloseTradeEnum(r.Int32()))
		case "PartialFillHandling":
			m.SetPartialFillHandling(PartialFillHandlingEnum(r.Int8()))
		case "UseOffsets":
			m.SetUseOffsets(r.Bool())
		case "OffsetFromParent1":
			m.SetOffsetFromParent1(r.Float64())
		case "OffsetFromParent2":
			m.SetOffsetFromParent2(r.Float64())
		case "MaintainSamePricesOnParentFill":
			m.SetMaintainSamePricesOnParentFill(r.Uint8())
		case "Price1_1AsString":
			m.SetPrice1_1AsString(r.String())
		case "Price2_1AsString":
			m.SetPrice2_1AsString(r.String())
		case "Price1_2AsString":
			m.SetPrice1_2AsString(r.String())
		case "Price2_2AsString":
			m.SetPrice2_2AsString(r.String())
		case "f", "F":
			return message.ErrJSONCompactDetected
		case "":
			break LOOP
		default:
			in.SkipRecursive()
		}
		if r.IsError() {
			return r.Error()
		}
		in.WantComma()
	}
	return nil
}
