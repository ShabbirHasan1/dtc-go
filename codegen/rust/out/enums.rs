/// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-23 21:07:20.84591 +0800 WITA m=+0.009860584


/// This enumeration indicates the encoding method. It can be one of the following
/// values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum EncodingEnum {
    BinaryEncoding = 0,
    BinaryWithVariableLengthStrings = 1,
    JsonEncoding = 2,
    JsonCompactEncoding = 3,
    ProtocolBuffers = 4,
}

impl EncodingEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(i32)]
pub enum LogonStatusEnum {
    LogonSuccess = 1,
    LogonError = 2,
    LogonErrorNoReconnect = 3,
    LogonReconnectNewAddress = 4,
}

impl LogonStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// This indicates the particular request action for market data and market
/// depth requests. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum RequestActionEnum {
    Subscribe = 1,
    Unsubscribe = 2,
    Snapshot = 3,
    SnapshotWithIntervalUpdates = 4,
}

impl RequestActionEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(i8)]
pub enum UnbundledTradeIndicatorEnum {
    UnbundledTradeNone = 0,
    FirstSubTradeOfUnbundledTrade = 1,
    LastSubTradeOfUnbundledTrade = 2,
}

impl UnbundledTradeIndicatorEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

/// This enumeration indicates the Order Status. It can be one of the following
/// values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum OrderStatusEnum {
    OrderStatusUnspecified = 0,
    OrderStatusOrderSent = 1,
    OrderStatusPendingOpen = 2,
    OrderStatusPendingChild = 3,
    OrderStatusOpen = 4,
    OrderStatusPendingCancelReplace = 5,
    OrderStatusPendingCancel = 6,
    OrderStatusFilled = 7,
    OrderStatusCanceled = 8,
    OrderStatusRejected = 9,
    OrderStatusPartiallyFilled = 10,
}

impl OrderStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// This indicates the reason for sending an Order Update message. It can
/// be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum OrderUpdateReasonEnum {
    OrderUpdateReasonUnset = 0,
    OpenOrdersRequestResponse = 1,
    NewOrderAccepted = 2,
    GeneralOrderUpdate = 3,
    OrderFilled = 4,
    OrderFilledPartially = 5,
    OrderCanceled = 6,
    OrderCancelReplaceComplete = 7,
    NewOrderRejected = 8,
    OrderCancelRejected = 9,
    OrderCancelReplaceRejected = 10,
}

impl OrderUpdateReasonEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(u8)]
pub enum AtBidOrAskEnum8 {
    BidAskUnset8 = 0,
    AtBid8 = 1,
    AtAsk8 = 2,
}

impl AtBidOrAskEnum8 {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(u16)]
pub enum AtBidOrAskEnum {
    BidAskUnset = 0,
    AtBid = 1,
    AtAsk = 2,
}

impl AtBidOrAskEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u16).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u16::from_le(value as u16)) }
        }
    }
}

/// This indicates the particular market depth update type. It can be one
/// of the following values.
#[derive(Clone, Copy)]
#[repr(u8)]
pub enum MarketDepthUpdateTypeEnum {
    MarketDepthUnset = 0,
    MarketDepthInsertUpdateLevel = 1,
    MarketDepthDeleteLevel = 2,
}

impl MarketDepthUpdateTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

/// This enumeration is for market depth updates.
#[derive(Clone, Copy)]
#[repr(u8)]
pub enum FinalUpdateInBatchEnum {
    /// Indicates the value is unset.
    FinalUpdateUnset = 0,
    /// Indicates the market depth update message is the final message in the
    /// batch.
    FinalUpdateTrue = 1,
    /// Indicates the market depth update message is not the final update in the
    /// batch.
    FinalUpdateFalse = 2,
    /// Indicates the market depth update message is the first update in the batch.
    /// Indicates the market depth update message is the first update in the batch.
    FinalUpdateBeginBatch = 3,
}

impl FinalUpdateInBatchEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(u8)]
pub enum MessageSetBoundaryEnum {
    MessageSetBoundaryUnset = 0,
    MessageSetBoundaryBegin = 1,
    MessageSetBoundaryEnd = 2,
}

impl MessageSetBoundaryEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

/// This indicates the order type. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum OrderTypeEnum {
    OrderTypeUnset = 0,
    OrderTypeMarket = 1,
    OrderTypeLimit = 2,
    OrderTypeStop = 3,
    OrderTypeStopLimit = 4,
    OrderTypeMarketIfTouched = 5,
    OrderTypeLimitIfTouched = 6,
    OrderTypeMarketLimit = 7,
}

impl OrderTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// This enumeration indicates the Time in Force for orders. It can be one
/// of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum TimeInForceEnum {
    TifUnset = 0,
    TifDay = 1,
    TifGoodTillCanceled = 2,
    TifGoodTillDateTime = 3,
    TifImmediateOrCancel = 4,
    TifAllOrNone = 5,
    TifFillOrKill = 6,
}

impl TimeInForceEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// This indicates buy or sell. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum BuySellEnum {
    BuySellUnset = 0,
    Buy = 1,
    Sell = 2,
}

impl BuySellEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// For orders this field specifies whether the order opens a new Position
/// or increases an existing Position, or closes an existing Position or decreases
/// an existing Position.
///
/// For order fills this field specifies whether the fill opened a new Position
/// or increased an existing Position, or closed an existing Position or decreased
/// an existing Position.
///
/// The use of this field for new orders depends upon the particular market/security
/// as specified by the Symbol and Exchange fields and whether the Server
/// requires it. Clients should always try to set this field for new orders,
/// however the Server may not use it. This field is not used for futures.
///
/// It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum OpenCloseTradeEnum {
    TradeUnset = 0,
    TradeOpen = 1,
    TradeClose = 2,
}

impl OpenCloseTradeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// This enumeration is for the OCO order messages.
#[derive(Clone, Copy)]
#[repr(i8)]
pub enum PartialFillHandlingEnum {
    /// Indicates no special partial fill handling.
    PartialFillUnset = 0,
    /// This specifies that when there is a partial fill of one of the orders
    /// in the OCO order set, that the quantity of the other order needs to be
    /// reduced by the quantity of the order fill.
    PartialFillHandlingReduceQuantity = 1,
    /// This specifies that when there is a partial fill of one of the orders
    /// of the OCO order set, that the other order needs to be immediately canceled.
    /// of the OCO order set, that the other order needs to be immediately canceled.
    PartialFillHandlingImmediateCancel = 2,
}

impl PartialFillHandlingEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

/// This indicates if the market data feed is available it in its entirety
/// or for an individual symbol. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum MarketDataFeedStatusEnum {
    MarketDataFeedStatusUnset = 0,
    MarketDataFeedUnavailable = 1,
    MarketDataFeedAvailable = 2,
}

impl MarketDataFeedStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(i8)]
pub enum TradingStatusEnum {
    TradingStatusUnknown = 0,
    TradingStatusPreOpen = 1,
    TradingStatusOpen = 2,
    TradingStatusClose = 3,
    TradingStatusTradingHalt = 4,
}

impl TradingStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

/// This indicates the price display format for market data prices. It can
/// be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum PriceDisplayFormatEnum {
    PriceDisplayFormatUnset = -1,
    PriceDisplayFormatDecimal0 = 0,
    PriceDisplayFormatDecimal1 = 1,
    PriceDisplayFormatDecimal2 = 2,
    PriceDisplayFormatDecimal3 = 3,
    PriceDisplayFormatDecimal4 = 4,
    PriceDisplayFormatDecimal5 = 5,
    PriceDisplayFormatDecimal6 = 6,
    PriceDisplayFormatDecimal7 = 7,
    PriceDisplayFormatDecimal8 = 8,
    PriceDisplayFormatDecimal9 = 9,
    PriceDisplayFormatDenominator256 = 356,
    PriceDisplayFormatDenominator128 = 228,
    PriceDisplayFormatDenominator64 = 164,
    PriceDisplayFormatDenominator32Eighths = 140,
    PriceDisplayFormatDenominator32Quarters = 136,
    PriceDisplayFormatDenominator32Halves = 134,
    PriceDisplayFormatDenominator32 = 132,
    PriceDisplayFormatDenominator16 = 116,
    PriceDisplayFormatDenominator8 = 108,
    PriceDisplayFormatDenominator4 = 104,
    PriceDisplayFormatDenominator2 = 102,
}

impl PriceDisplayFormatEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// This indicates the Security Type. It can be one of the following values.
/// This indicates the Security Type. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum SecurityTypeEnum {
    SecurityTypeUnset = 0,
    SecurityTypeFutures = 1,
    SecurityTypeStock = 2,
    /// (Also applies to Bitcoins)
    SecurityTypeForex = 3,
    SecurityTypeIndex = 4,
    SecurityTypeFuturesStrategy = 5,
    SecurityTypeFuturesOption = 7,
    SecurityTypeStockOption = 6,
    SecurityTypeIndexOption = 8,
    SecurityTypeBond = 9,
    SecurityTypeMutualFund = 10,
}

impl SecurityTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// This indicates if the option is a put or call. It can be one of the following
/// values.
#[derive(Clone, Copy)]
#[repr(u8)]
pub enum PutCallEnum {
    PcUnset = 0,
    PcCall = 1,
    PcPut = 2,
}

impl PutCallEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

/// This indicates the Search Type. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum SearchTypeEnum {
    SearchTypeUnset = 0,
    SearchTypeBySymbol = 1,
    SearchTypeByDescription = 2,
}

impl SearchTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// This indicates the time interval for historical price data records. It
/// can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum HistoricalDataIntervalEnum {
    IntervalTick = 0,
    Interval1Second = 1,
    Interval2Seconds = 2,
    Interval4Seconds = 4,
    Interval5Seconds = 5,
    Interval10Seconds = 10,
    Interval30Seconds = 30,
    Interval1Minute = 60,
    Interval5Minute = 300,
    Interval10Minute = 600,
    Interval15Minute = 900,
    Interval30Minute = 1800,
    Interval1Hour = 3600,
    Interval2Hours = 7200,
    Interval1Day = 86400,
    Interval1Week = 604800,
}

impl HistoricalDataIntervalEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

/// The following enumerations are for the Historical Price Data Reject message.
/// The following enumerations are for the Historical Price Data Reject message.
#[derive(Clone, Copy)]
#[repr(i16)]
pub enum HistoricalPriceDataRejectReasonCodeEnum {
    /// The historical price data reject code is unset.
    HpdrUnset = 0,
    /// The server is unable to serve the historical data request and the request
    /// should be retried in the specified number of seconds. A properly implemented
    /// high-performance server should never utilize this reject code.
    HpdrUnableToServeDataRetryInSpecifiedSeconds = 1,
    /// The server is unable to serve the historical data request and there should
    /// be no retry.
    HpdrUnableToServeDataDoNotRetry = 2,
    /// The Date-Time range of historical data requested is outside the bounds
    /// of the available data.
    HpdrDataRequestOutsideBoundsOfAvailableData = 3,
    /// There is another undocumented reason the server cannot accept the historical
    /// data request and it has been rejected.
    HpdrGeneralRejectError = 4,
}

impl HistoricalPriceDataRejectReasonCodeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i16).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i16::from_le(value as i16)) }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(i8)]
pub enum TradeConditionEnum {
    TradeConditionNone = 0,
    TradeConditionNonLastUpdateEquityTrade = 1,
    TradeConditionOddLotEquityTrade = 2,
}

impl TradeConditionEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

#[derive(Clone, Copy)]
#[repr(i8)]
pub enum TradeModeEnum {
    TradeModeUnset = 0,
    TradeModeDemo = 1,
    TradeModeSimulated = 2,
    TradeModeLive = 3,
}

impl TradeModeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

