/// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-27 08:32:53.747629 +0800 WITA m=+0.008238335

/// This enumeration indicates the encoding method. It can be one of the following
/// values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum EncodingEnum {
    BinaryEncoding = 0,
    BinaryWithVariableLengthStrings = 1,
    JsonEncoding = 2,
    JsonCompactEncoding = 3,
    ProtocolBuffers = 4,
}

impl EncodingEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for EncodingEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::BinaryEncoding => "BinaryEncoding",
            Self::BinaryWithVariableLengthStrings => "BinaryWithVariableLengthStrings",
            Self::JsonEncoding => "JsonEncoding",
            Self::JsonCompactEncoding => "JsonCompactEncoding",
            Self::ProtocolBuffers => "ProtocolBuffers",
        })
    }
}

impl core::fmt::Debug for EncodingEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::BinaryEncoding => "BinaryEncoding",
            Self::BinaryWithVariableLengthStrings => "BinaryWithVariableLengthStrings",
            Self::JsonEncoding => "JsonEncoding",
            Self::JsonCompactEncoding => "JsonCompactEncoding",
            Self::ProtocolBuffers => "ProtocolBuffers",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i32)]
pub enum LogonStatusEnum {
    LogonSuccess = 1,
    LogonError = 2,
    LogonErrorNoReconnect = 3,
    LogonReconnectNewAddress = 4,
}

impl LogonStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for LogonStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::LogonSuccess => "LogonSuccess",
            Self::LogonError => "LogonError",
            Self::LogonErrorNoReconnect => "LogonErrorNoReconnect",
            Self::LogonReconnectNewAddress => "LogonReconnectNewAddress",
        })
    }
}

impl core::fmt::Debug for LogonStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::LogonSuccess => "LogonSuccess",
            Self::LogonError => "LogonError",
            Self::LogonErrorNoReconnect => "LogonErrorNoReconnect",
            Self::LogonReconnectNewAddress => "LogonReconnectNewAddress",
        })
    }
}

/// This indicates the particular request action for market data and market
/// depth requests. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum RequestActionEnum {
    Subscribe = 1,
    Unsubscribe = 2,
    Snapshot = 3,
    SnapshotWithIntervalUpdates = 4,
}

impl RequestActionEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for RequestActionEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::Subscribe => "Subscribe",
            Self::Unsubscribe => "Unsubscribe",
            Self::Snapshot => "Snapshot",
            Self::SnapshotWithIntervalUpdates => "SnapshotWithIntervalUpdates",
        })
    }
}

impl core::fmt::Debug for RequestActionEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::Subscribe => "Subscribe",
            Self::Unsubscribe => "Unsubscribe",
            Self::Snapshot => "Snapshot",
            Self::SnapshotWithIntervalUpdates => "SnapshotWithIntervalUpdates",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i8)]
pub enum UnbundledTradeIndicatorEnum {
    UnbundledTradeNone = 0,
    FirstSubTradeOfUnbundledTrade = 1,
    LastSubTradeOfUnbundledTrade = 2,
}

impl UnbundledTradeIndicatorEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

impl core::fmt::Display for UnbundledTradeIndicatorEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::UnbundledTradeNone => "UnbundledTradeNone",
            Self::FirstSubTradeOfUnbundledTrade => "FirstSubTradeOfUnbundledTrade",
            Self::LastSubTradeOfUnbundledTrade => "LastSubTradeOfUnbundledTrade",
        })
    }
}

impl core::fmt::Debug for UnbundledTradeIndicatorEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::UnbundledTradeNone => "UnbundledTradeNone",
            Self::FirstSubTradeOfUnbundledTrade => "FirstSubTradeOfUnbundledTrade",
            Self::LastSubTradeOfUnbundledTrade => "LastSubTradeOfUnbundledTrade",
        })
    }
}

/// This enumeration indicates the Order Status. It can be one of the following
/// values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum OrderStatusEnum {
    OrderStatusUnspecified = 0,
    OrderStatusOrderSent = 1,
    OrderStatusPendingOpen = 2,
    OrderStatusPendingChild = 3,
    OrderStatusOpen = 4,
    OrderStatusPendingCancelReplace = 5,
    OrderStatusPendingCancel = 6,
    OrderStatusFilled = 7,
    OrderStatusCanceled = 8,
    OrderStatusRejected = 9,
    OrderStatusPartiallyFilled = 10,
}

impl OrderStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for OrderStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::OrderStatusUnspecified => "OrderStatusUnspecified",
            Self::OrderStatusOrderSent => "OrderStatusOrderSent",
            Self::OrderStatusPendingOpen => "OrderStatusPendingOpen",
            Self::OrderStatusPendingChild => "OrderStatusPendingChild",
            Self::OrderStatusOpen => "OrderStatusOpen",
            Self::OrderStatusPendingCancelReplace => "OrderStatusPendingCancelReplace",
            Self::OrderStatusPendingCancel => "OrderStatusPendingCancel",
            Self::OrderStatusFilled => "OrderStatusFilled",
            Self::OrderStatusCanceled => "OrderStatusCanceled",
            Self::OrderStatusRejected => "OrderStatusRejected",
            Self::OrderStatusPartiallyFilled => "OrderStatusPartiallyFilled",
        })
    }
}

impl core::fmt::Debug for OrderStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::OrderStatusUnspecified => "OrderStatusUnspecified",
            Self::OrderStatusOrderSent => "OrderStatusOrderSent",
            Self::OrderStatusPendingOpen => "OrderStatusPendingOpen",
            Self::OrderStatusPendingChild => "OrderStatusPendingChild",
            Self::OrderStatusOpen => "OrderStatusOpen",
            Self::OrderStatusPendingCancelReplace => "OrderStatusPendingCancelReplace",
            Self::OrderStatusPendingCancel => "OrderStatusPendingCancel",
            Self::OrderStatusFilled => "OrderStatusFilled",
            Self::OrderStatusCanceled => "OrderStatusCanceled",
            Self::OrderStatusRejected => "OrderStatusRejected",
            Self::OrderStatusPartiallyFilled => "OrderStatusPartiallyFilled",
        })
    }
}

/// This indicates the reason for sending an Order Update message. It can
/// be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum OrderUpdateReasonEnum {
    OrderUpdateReasonUnset = 0,
    OpenOrdersRequestResponse = 1,
    NewOrderAccepted = 2,
    GeneralOrderUpdate = 3,
    OrderFilled = 4,
    OrderFilledPartially = 5,
    OrderCanceled = 6,
    OrderCancelReplaceComplete = 7,
    NewOrderRejected = 8,
    OrderCancelRejected = 9,
    OrderCancelReplaceRejected = 10,
}

impl OrderUpdateReasonEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for OrderUpdateReasonEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::OrderUpdateReasonUnset => "OrderUpdateReasonUnset",
            Self::OpenOrdersRequestResponse => "OpenOrdersRequestResponse",
            Self::NewOrderAccepted => "NewOrderAccepted",
            Self::GeneralOrderUpdate => "GeneralOrderUpdate",
            Self::OrderFilled => "OrderFilled",
            Self::OrderFilledPartially => "OrderFilledPartially",
            Self::OrderCanceled => "OrderCanceled",
            Self::OrderCancelReplaceComplete => "OrderCancelReplaceComplete",
            Self::NewOrderRejected => "NewOrderRejected",
            Self::OrderCancelRejected => "OrderCancelRejected",
            Self::OrderCancelReplaceRejected => "OrderCancelReplaceRejected",
        })
    }
}

impl core::fmt::Debug for OrderUpdateReasonEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::OrderUpdateReasonUnset => "OrderUpdateReasonUnset",
            Self::OpenOrdersRequestResponse => "OpenOrdersRequestResponse",
            Self::NewOrderAccepted => "NewOrderAccepted",
            Self::GeneralOrderUpdate => "GeneralOrderUpdate",
            Self::OrderFilled => "OrderFilled",
            Self::OrderFilledPartially => "OrderFilledPartially",
            Self::OrderCanceled => "OrderCanceled",
            Self::OrderCancelReplaceComplete => "OrderCancelReplaceComplete",
            Self::NewOrderRejected => "NewOrderRejected",
            Self::OrderCancelRejected => "OrderCancelRejected",
            Self::OrderCancelReplaceRejected => "OrderCancelReplaceRejected",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(u8)]
pub enum AtBidOrAskEnum8 {
    BidAskUnset8 = 0,
    AtBid8 = 1,
    AtAsk8 = 2,
}

impl AtBidOrAskEnum8 {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

impl core::fmt::Display for AtBidOrAskEnum8 {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::BidAskUnset8 => "BidAskUnset8",
            Self::AtBid8 => "AtBid8",
            Self::AtAsk8 => "AtAsk8",
        })
    }
}

impl core::fmt::Debug for AtBidOrAskEnum8 {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::BidAskUnset8 => "BidAskUnset8",
            Self::AtBid8 => "AtBid8",
            Self::AtAsk8 => "AtAsk8",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(u16)]
pub enum AtBidOrAskEnum {
    BidAskUnset = 0,
    AtBid = 1,
    AtAsk = 2,
}

impl AtBidOrAskEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u16).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u16::from_le(value as u16)) }
        }
    }
}

impl core::fmt::Display for AtBidOrAskEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::BidAskUnset => "BidAskUnset",
            Self::AtBid => "AtBid",
            Self::AtAsk => "AtAsk",
        })
    }
}

impl core::fmt::Debug for AtBidOrAskEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::BidAskUnset => "BidAskUnset",
            Self::AtBid => "AtBid",
            Self::AtAsk => "AtAsk",
        })
    }
}

/// This indicates the particular market depth update type. It can be one
/// of the following values.
#[derive(Clone, Copy)]
#[repr(u8)]
pub enum MarketDepthUpdateTypeEnum {
    MarketDepthUnset = 0,
    MarketDepthInsertUpdateLevel = 1,
    MarketDepthDeleteLevel = 2,
}

impl MarketDepthUpdateTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

impl core::fmt::Display for MarketDepthUpdateTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::MarketDepthUnset => "MarketDepthUnset",
            Self::MarketDepthInsertUpdateLevel => "MarketDepthInsertUpdateLevel",
            Self::MarketDepthDeleteLevel => "MarketDepthDeleteLevel",
        })
    }
}

impl core::fmt::Debug for MarketDepthUpdateTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::MarketDepthUnset => "MarketDepthUnset",
            Self::MarketDepthInsertUpdateLevel => "MarketDepthInsertUpdateLevel",
            Self::MarketDepthDeleteLevel => "MarketDepthDeleteLevel",
        })
    }
}

/// This enumeration is for market depth updates.
#[derive(Clone, Copy)]
#[repr(u8)]
pub enum FinalUpdateInBatchEnum {
    /// Indicates the value is unset.
    FinalUpdateUnset = 0,
    /// Indicates the market depth update message is the final message in the
    /// batch.
    FinalUpdateTrue = 1,
    /// Indicates the market depth update message is not the final update in the
    /// batch.
    FinalUpdateFalse = 2,
    /// Indicates the market depth update message is the first update in the batch.
    /// Indicates the market depth update message is the first update in the batch.
    FinalUpdateBeginBatch = 3,
}

impl FinalUpdateInBatchEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

impl core::fmt::Display for FinalUpdateInBatchEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::FinalUpdateUnset => "FinalUpdateUnset",
            Self::FinalUpdateTrue => "FinalUpdateTrue",
            Self::FinalUpdateFalse => "FinalUpdateFalse",
            Self::FinalUpdateBeginBatch => "FinalUpdateBeginBatch",
        })
    }
}

impl core::fmt::Debug for FinalUpdateInBatchEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::FinalUpdateUnset => "FinalUpdateUnset",
            Self::FinalUpdateTrue => "FinalUpdateTrue",
            Self::FinalUpdateFalse => "FinalUpdateFalse",
            Self::FinalUpdateBeginBatch => "FinalUpdateBeginBatch",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(u8)]
pub enum MessageSetBoundaryEnum {
    MessageSetBoundaryUnset = 0,
    MessageSetBoundaryBegin = 1,
    MessageSetBoundaryEnd = 2,
}

impl MessageSetBoundaryEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

impl core::fmt::Display for MessageSetBoundaryEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::MessageSetBoundaryUnset => "MessageSetBoundaryUnset",
            Self::MessageSetBoundaryBegin => "MessageSetBoundaryBegin",
            Self::MessageSetBoundaryEnd => "MessageSetBoundaryEnd",
        })
    }
}

impl core::fmt::Debug for MessageSetBoundaryEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::MessageSetBoundaryUnset => "MessageSetBoundaryUnset",
            Self::MessageSetBoundaryBegin => "MessageSetBoundaryBegin",
            Self::MessageSetBoundaryEnd => "MessageSetBoundaryEnd",
        })
    }
}

/// This indicates the order type. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum OrderTypeEnum {
    OrderTypeUnset = 0,
    OrderTypeMarket = 1,
    OrderTypeLimit = 2,
    OrderTypeStop = 3,
    OrderTypeStopLimit = 4,
    OrderTypeMarketIfTouched = 5,
    OrderTypeLimitIfTouched = 6,
    OrderTypeMarketLimit = 7,
}

impl OrderTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for OrderTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::OrderTypeUnset => "OrderTypeUnset",
            Self::OrderTypeMarket => "OrderTypeMarket",
            Self::OrderTypeLimit => "OrderTypeLimit",
            Self::OrderTypeStop => "OrderTypeStop",
            Self::OrderTypeStopLimit => "OrderTypeStopLimit",
            Self::OrderTypeMarketIfTouched => "OrderTypeMarketIfTouched",
            Self::OrderTypeLimitIfTouched => "OrderTypeLimitIfTouched",
            Self::OrderTypeMarketLimit => "OrderTypeMarketLimit",
        })
    }
}

impl core::fmt::Debug for OrderTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::OrderTypeUnset => "OrderTypeUnset",
            Self::OrderTypeMarket => "OrderTypeMarket",
            Self::OrderTypeLimit => "OrderTypeLimit",
            Self::OrderTypeStop => "OrderTypeStop",
            Self::OrderTypeStopLimit => "OrderTypeStopLimit",
            Self::OrderTypeMarketIfTouched => "OrderTypeMarketIfTouched",
            Self::OrderTypeLimitIfTouched => "OrderTypeLimitIfTouched",
            Self::OrderTypeMarketLimit => "OrderTypeMarketLimit",
        })
    }
}

/// This enumeration indicates the Time in Force for orders. It can be one
/// of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum TimeInForceEnum {
    TifUnset = 0,
    TifDay = 1,
    TifGoodTillCanceled = 2,
    TifGoodTillDateTime = 3,
    TifImmediateOrCancel = 4,
    TifAllOrNone = 5,
    TifFillOrKill = 6,
}

impl TimeInForceEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for TimeInForceEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TifUnset => "TifUnset",
            Self::TifDay => "TifDay",
            Self::TifGoodTillCanceled => "TifGoodTillCanceled",
            Self::TifGoodTillDateTime => "TifGoodTillDateTime",
            Self::TifImmediateOrCancel => "TifImmediateOrCancel",
            Self::TifAllOrNone => "TifAllOrNone",
            Self::TifFillOrKill => "TifFillOrKill",
        })
    }
}

impl core::fmt::Debug for TimeInForceEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TifUnset => "TifUnset",
            Self::TifDay => "TifDay",
            Self::TifGoodTillCanceled => "TifGoodTillCanceled",
            Self::TifGoodTillDateTime => "TifGoodTillDateTime",
            Self::TifImmediateOrCancel => "TifImmediateOrCancel",
            Self::TifAllOrNone => "TifAllOrNone",
            Self::TifFillOrKill => "TifFillOrKill",
        })
    }
}

/// This indicates buy or sell. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum BuySellEnum {
    BuySellUnset = 0,
    Buy = 1,
    Sell = 2,
}

impl BuySellEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for BuySellEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::BuySellUnset => "BuySellUnset",
            Self::Buy => "Buy",
            Self::Sell => "Sell",
        })
    }
}

impl core::fmt::Debug for BuySellEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::BuySellUnset => "BuySellUnset",
            Self::Buy => "Buy",
            Self::Sell => "Sell",
        })
    }
}

/// For orders this field specifies whether the order opens a new Position
/// or increases an existing Position, or closes an existing Position or decreases
/// an existing Position.
///
/// For order fills this field specifies whether the fill opened a new Position
/// or increased an existing Position, or closed an existing Position or decreased
/// an existing Position.
///
/// The use of this field for new orders depends upon the particular market/security
/// as specified by the Symbol and Exchange fields and whether the Server
/// requires it. Clients should always try to set this field for new orders,
/// however the Server may not use it. This field is not used for futures.
///
/// It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum OpenCloseTradeEnum {
    TradeUnset = 0,
    TradeOpen = 1,
    TradeClose = 2,
}

impl OpenCloseTradeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for OpenCloseTradeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TradeUnset => "TradeUnset",
            Self::TradeOpen => "TradeOpen",
            Self::TradeClose => "TradeClose",
        })
    }
}

impl core::fmt::Debug for OpenCloseTradeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TradeUnset => "TradeUnset",
            Self::TradeOpen => "TradeOpen",
            Self::TradeClose => "TradeClose",
        })
    }
}

/// This enumeration is for the OCO order messages.
#[derive(Clone, Copy)]
#[repr(i8)]
pub enum PartialFillHandlingEnum {
    /// Indicates no special partial fill handling.
    PartialFillUnset = 0,
    /// This specifies that when there is a partial fill of one of the orders
    /// in the OCO order set, that the quantity of the other order needs to be
    /// reduced by the quantity of the order fill.
    PartialFillHandlingReduceQuantity = 1,
    /// This specifies that when there is a partial fill of one of the orders
    /// of the OCO order set, that the other order needs to be immediately canceled.
    /// of the OCO order set, that the other order needs to be immediately canceled.
    PartialFillHandlingImmediateCancel = 2,
}

impl PartialFillHandlingEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

impl core::fmt::Display for PartialFillHandlingEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::PartialFillUnset => "PartialFillUnset",
            Self::PartialFillHandlingReduceQuantity => "PartialFillHandlingReduceQuantity",
            Self::PartialFillHandlingImmediateCancel => "PartialFillHandlingImmediateCancel",
        })
    }
}

impl core::fmt::Debug for PartialFillHandlingEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::PartialFillUnset => "PartialFillUnset",
            Self::PartialFillHandlingReduceQuantity => "PartialFillHandlingReduceQuantity",
            Self::PartialFillHandlingImmediateCancel => "PartialFillHandlingImmediateCancel",
        })
    }
}

/// This indicates if the market data feed is available it in its entirety
/// or for an individual symbol. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum MarketDataFeedStatusEnum {
    MarketDataFeedStatusUnset = 0,
    MarketDataFeedUnavailable = 1,
    MarketDataFeedAvailable = 2,
}

impl MarketDataFeedStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for MarketDataFeedStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::MarketDataFeedStatusUnset => "MarketDataFeedStatusUnset",
            Self::MarketDataFeedUnavailable => "MarketDataFeedUnavailable",
            Self::MarketDataFeedAvailable => "MarketDataFeedAvailable",
        })
    }
}

impl core::fmt::Debug for MarketDataFeedStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::MarketDataFeedStatusUnset => "MarketDataFeedStatusUnset",
            Self::MarketDataFeedUnavailable => "MarketDataFeedUnavailable",
            Self::MarketDataFeedAvailable => "MarketDataFeedAvailable",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i8)]
pub enum TradingStatusEnum {
    TradingStatusUnknown = 0,
    TradingStatusPreOpen = 1,
    TradingStatusOpen = 2,
    TradingStatusClose = 3,
    TradingStatusTradingHalt = 4,
}

impl TradingStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

impl core::fmt::Display for TradingStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TradingStatusUnknown => "TradingStatusUnknown",
            Self::TradingStatusPreOpen => "TradingStatusPreOpen",
            Self::TradingStatusOpen => "TradingStatusOpen",
            Self::TradingStatusClose => "TradingStatusClose",
            Self::TradingStatusTradingHalt => "TradingStatusTradingHalt",
        })
    }
}

impl core::fmt::Debug for TradingStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TradingStatusUnknown => "TradingStatusUnknown",
            Self::TradingStatusPreOpen => "TradingStatusPreOpen",
            Self::TradingStatusOpen => "TradingStatusOpen",
            Self::TradingStatusClose => "TradingStatusClose",
            Self::TradingStatusTradingHalt => "TradingStatusTradingHalt",
        })
    }
}

/// This indicates the price display format for market data prices. It can
/// be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum PriceDisplayFormatEnum {
    PriceDisplayFormatUnset = -1,
    PriceDisplayFormatDecimal0 = 0,
    PriceDisplayFormatDecimal1 = 1,
    PriceDisplayFormatDecimal2 = 2,
    PriceDisplayFormatDecimal3 = 3,
    PriceDisplayFormatDecimal4 = 4,
    PriceDisplayFormatDecimal5 = 5,
    PriceDisplayFormatDecimal6 = 6,
    PriceDisplayFormatDecimal7 = 7,
    PriceDisplayFormatDecimal8 = 8,
    PriceDisplayFormatDecimal9 = 9,
    PriceDisplayFormatDenominator256 = 356,
    PriceDisplayFormatDenominator128 = 228,
    PriceDisplayFormatDenominator64 = 164,
    PriceDisplayFormatDenominator32Eighths = 140,
    PriceDisplayFormatDenominator32Quarters = 136,
    PriceDisplayFormatDenominator32Halves = 134,
    PriceDisplayFormatDenominator32 = 132,
    PriceDisplayFormatDenominator16 = 116,
    PriceDisplayFormatDenominator8 = 108,
    PriceDisplayFormatDenominator4 = 104,
    PriceDisplayFormatDenominator2 = 102,
}

impl PriceDisplayFormatEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for PriceDisplayFormatEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::PriceDisplayFormatUnset => "PriceDisplayFormatUnset",
            Self::PriceDisplayFormatDecimal0 => "PriceDisplayFormatDecimal0",
            Self::PriceDisplayFormatDecimal1 => "PriceDisplayFormatDecimal1",
            Self::PriceDisplayFormatDecimal2 => "PriceDisplayFormatDecimal2",
            Self::PriceDisplayFormatDecimal3 => "PriceDisplayFormatDecimal3",
            Self::PriceDisplayFormatDecimal4 => "PriceDisplayFormatDecimal4",
            Self::PriceDisplayFormatDecimal5 => "PriceDisplayFormatDecimal5",
            Self::PriceDisplayFormatDecimal6 => "PriceDisplayFormatDecimal6",
            Self::PriceDisplayFormatDecimal7 => "PriceDisplayFormatDecimal7",
            Self::PriceDisplayFormatDecimal8 => "PriceDisplayFormatDecimal8",
            Self::PriceDisplayFormatDecimal9 => "PriceDisplayFormatDecimal9",
            Self::PriceDisplayFormatDenominator256 => "PriceDisplayFormatDenominator256",
            Self::PriceDisplayFormatDenominator128 => "PriceDisplayFormatDenominator128",
            Self::PriceDisplayFormatDenominator64 => "PriceDisplayFormatDenominator64",
            Self::PriceDisplayFormatDenominator32Eighths => {
                "PriceDisplayFormatDenominator32Eighths"
            }
            Self::PriceDisplayFormatDenominator32Quarters => {
                "PriceDisplayFormatDenominator32Quarters"
            }
            Self::PriceDisplayFormatDenominator32Halves => "PriceDisplayFormatDenominator32Halves",
            Self::PriceDisplayFormatDenominator32 => "PriceDisplayFormatDenominator32",
            Self::PriceDisplayFormatDenominator16 => "PriceDisplayFormatDenominator16",
            Self::PriceDisplayFormatDenominator8 => "PriceDisplayFormatDenominator8",
            Self::PriceDisplayFormatDenominator4 => "PriceDisplayFormatDenominator4",
            Self::PriceDisplayFormatDenominator2 => "PriceDisplayFormatDenominator2",
        })
    }
}

impl core::fmt::Debug for PriceDisplayFormatEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::PriceDisplayFormatUnset => "PriceDisplayFormatUnset",
            Self::PriceDisplayFormatDecimal0 => "PriceDisplayFormatDecimal0",
            Self::PriceDisplayFormatDecimal1 => "PriceDisplayFormatDecimal1",
            Self::PriceDisplayFormatDecimal2 => "PriceDisplayFormatDecimal2",
            Self::PriceDisplayFormatDecimal3 => "PriceDisplayFormatDecimal3",
            Self::PriceDisplayFormatDecimal4 => "PriceDisplayFormatDecimal4",
            Self::PriceDisplayFormatDecimal5 => "PriceDisplayFormatDecimal5",
            Self::PriceDisplayFormatDecimal6 => "PriceDisplayFormatDecimal6",
            Self::PriceDisplayFormatDecimal7 => "PriceDisplayFormatDecimal7",
            Self::PriceDisplayFormatDecimal8 => "PriceDisplayFormatDecimal8",
            Self::PriceDisplayFormatDecimal9 => "PriceDisplayFormatDecimal9",
            Self::PriceDisplayFormatDenominator256 => "PriceDisplayFormatDenominator256",
            Self::PriceDisplayFormatDenominator128 => "PriceDisplayFormatDenominator128",
            Self::PriceDisplayFormatDenominator64 => "PriceDisplayFormatDenominator64",
            Self::PriceDisplayFormatDenominator32Eighths => {
                "PriceDisplayFormatDenominator32Eighths"
            }
            Self::PriceDisplayFormatDenominator32Quarters => {
                "PriceDisplayFormatDenominator32Quarters"
            }
            Self::PriceDisplayFormatDenominator32Halves => "PriceDisplayFormatDenominator32Halves",
            Self::PriceDisplayFormatDenominator32 => "PriceDisplayFormatDenominator32",
            Self::PriceDisplayFormatDenominator16 => "PriceDisplayFormatDenominator16",
            Self::PriceDisplayFormatDenominator8 => "PriceDisplayFormatDenominator8",
            Self::PriceDisplayFormatDenominator4 => "PriceDisplayFormatDenominator4",
            Self::PriceDisplayFormatDenominator2 => "PriceDisplayFormatDenominator2",
        })
    }
}

/// This indicates the Security Type. It can be one of the following values.
/// This indicates the Security Type. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum SecurityTypeEnum {
    SecurityTypeUnset = 0,
    SecurityTypeFutures = 1,
    SecurityTypeStock = 2,
    /// (Also applies to Bitcoins)
    SecurityTypeForex = 3,
    SecurityTypeIndex = 4,
    SecurityTypeFuturesStrategy = 5,
    SecurityTypeFuturesOption = 7,
    SecurityTypeStockOption = 6,
    SecurityTypeIndexOption = 8,
    SecurityTypeBond = 9,
    SecurityTypeMutualFund = 10,
}

impl SecurityTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for SecurityTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::SecurityTypeUnset => "SecurityTypeUnset",
            Self::SecurityTypeFutures => "SecurityTypeFutures",
            Self::SecurityTypeStock => "SecurityTypeStock",
            Self::SecurityTypeForex => "SecurityTypeForex",
            Self::SecurityTypeIndex => "SecurityTypeIndex",
            Self::SecurityTypeFuturesStrategy => "SecurityTypeFuturesStrategy",
            Self::SecurityTypeFuturesOption => "SecurityTypeFuturesOption",
            Self::SecurityTypeStockOption => "SecurityTypeStockOption",
            Self::SecurityTypeIndexOption => "SecurityTypeIndexOption",
            Self::SecurityTypeBond => "SecurityTypeBond",
            Self::SecurityTypeMutualFund => "SecurityTypeMutualFund",
        })
    }
}

impl core::fmt::Debug for SecurityTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::SecurityTypeUnset => "SecurityTypeUnset",
            Self::SecurityTypeFutures => "SecurityTypeFutures",
            Self::SecurityTypeStock => "SecurityTypeStock",
            Self::SecurityTypeForex => "SecurityTypeForex",
            Self::SecurityTypeIndex => "SecurityTypeIndex",
            Self::SecurityTypeFuturesStrategy => "SecurityTypeFuturesStrategy",
            Self::SecurityTypeFuturesOption => "SecurityTypeFuturesOption",
            Self::SecurityTypeStockOption => "SecurityTypeStockOption",
            Self::SecurityTypeIndexOption => "SecurityTypeIndexOption",
            Self::SecurityTypeBond => "SecurityTypeBond",
            Self::SecurityTypeMutualFund => "SecurityTypeMutualFund",
        })
    }
}

/// This indicates if the option is a put or call. It can be one of the following
/// values.
#[derive(Clone, Copy)]
#[repr(u8)]
pub enum PutCallEnum {
    PcUnset = 0,
    PcCall = 1,
    PcPut = 2,
}

impl PutCallEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as u8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(u8::from_le(value as u8)) }
        }
    }
}

impl core::fmt::Display for PutCallEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::PcUnset => "PcUnset",
            Self::PcCall => "PcCall",
            Self::PcPut => "PcPut",
        })
    }
}

impl core::fmt::Debug for PutCallEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::PcUnset => "PcUnset",
            Self::PcCall => "PcCall",
            Self::PcPut => "PcPut",
        })
    }
}

/// This indicates the Search Type. It can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum SearchTypeEnum {
    SearchTypeUnset = 0,
    SearchTypeBySymbol = 1,
    SearchTypeByDescription = 2,
}

impl SearchTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for SearchTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::SearchTypeUnset => "SearchTypeUnset",
            Self::SearchTypeBySymbol => "SearchTypeBySymbol",
            Self::SearchTypeByDescription => "SearchTypeByDescription",
        })
    }
}

impl core::fmt::Debug for SearchTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::SearchTypeUnset => "SearchTypeUnset",
            Self::SearchTypeBySymbol => "SearchTypeBySymbol",
            Self::SearchTypeByDescription => "SearchTypeByDescription",
        })
    }
}

/// This indicates the time interval for historical price data records. It
/// can be one of the following values.
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum HistoricalDataIntervalEnum {
    IntervalTick = 0,
    Interval1Second = 1,
    Interval2Seconds = 2,
    Interval4Seconds = 4,
    Interval5Seconds = 5,
    Interval10Seconds = 10,
    Interval30Seconds = 30,
    Interval1Minute = 60,
    Interval5Minute = 300,
    Interval10Minute = 600,
    Interval15Minute = 900,
    Interval30Minute = 1800,
    Interval1Hour = 3600,
    Interval2Hours = 7200,
    Interval1Day = 86400,
    Interval1Week = 604800,
}

impl HistoricalDataIntervalEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for HistoricalDataIntervalEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::IntervalTick => "IntervalTick",
            Self::Interval1Second => "Interval1Second",
            Self::Interval2Seconds => "Interval2Seconds",
            Self::Interval4Seconds => "Interval4Seconds",
            Self::Interval5Seconds => "Interval5Seconds",
            Self::Interval10Seconds => "Interval10Seconds",
            Self::Interval30Seconds => "Interval30Seconds",
            Self::Interval1Minute => "Interval1Minute",
            Self::Interval5Minute => "Interval5Minute",
            Self::Interval10Minute => "Interval10Minute",
            Self::Interval15Minute => "Interval15Minute",
            Self::Interval30Minute => "Interval30Minute",
            Self::Interval1Hour => "Interval1Hour",
            Self::Interval2Hours => "Interval2Hours",
            Self::Interval1Day => "Interval1Day",
            Self::Interval1Week => "Interval1Week",
        })
    }
}

impl core::fmt::Debug for HistoricalDataIntervalEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::IntervalTick => "IntervalTick",
            Self::Interval1Second => "Interval1Second",
            Self::Interval2Seconds => "Interval2Seconds",
            Self::Interval4Seconds => "Interval4Seconds",
            Self::Interval5Seconds => "Interval5Seconds",
            Self::Interval10Seconds => "Interval10Seconds",
            Self::Interval30Seconds => "Interval30Seconds",
            Self::Interval1Minute => "Interval1Minute",
            Self::Interval5Minute => "Interval5Minute",
            Self::Interval10Minute => "Interval10Minute",
            Self::Interval15Minute => "Interval15Minute",
            Self::Interval30Minute => "Interval30Minute",
            Self::Interval1Hour => "Interval1Hour",
            Self::Interval2Hours => "Interval2Hours",
            Self::Interval1Day => "Interval1Day",
            Self::Interval1Week => "Interval1Week",
        })
    }
}

/// The following enumerations are for the Historical Price Data Reject message.
/// The following enumerations are for the Historical Price Data Reject message.
#[derive(Clone, Copy)]
#[repr(i16)]
pub enum HistoricalPriceDataRejectReasonCodeEnum {
    /// The historical price data reject code is unset.
    HpdrUnset = 0,
    /// The server is unable to serve the historical data request and the request
    /// should be retried in the specified number of seconds. A properly implemented
    /// high-performance server should never utilize this reject code.
    HpdrUnableToServeDataRetryInSpecifiedSeconds = 1,
    /// The server is unable to serve the historical data request and there should
    /// be no retry.
    HpdrUnableToServeDataDoNotRetry = 2,
    /// The Date-Time range of historical data requested is outside the bounds
    /// of the available data.
    HpdrDataRequestOutsideBoundsOfAvailableData = 3,
    /// There is another undocumented reason the server cannot accept the historical
    /// data request and it has been rejected.
    HpdrGeneralRejectError = 4,
}

impl HistoricalPriceDataRejectReasonCodeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i16).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i16::from_le(value as i16)) }
        }
    }
}

impl core::fmt::Display for HistoricalPriceDataRejectReasonCodeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::HpdrUnset => "HpdrUnset",
            Self::HpdrUnableToServeDataRetryInSpecifiedSeconds => {
                "HpdrUnableToServeDataRetryInSpecifiedSeconds"
            }
            Self::HpdrUnableToServeDataDoNotRetry => "HpdrUnableToServeDataDoNotRetry",
            Self::HpdrDataRequestOutsideBoundsOfAvailableData => {
                "HpdrDataRequestOutsideBoundsOfAvailableData"
            }
            Self::HpdrGeneralRejectError => "HpdrGeneralRejectError",
        })
    }
}

impl core::fmt::Debug for HistoricalPriceDataRejectReasonCodeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::HpdrUnset => "HpdrUnset",
            Self::HpdrUnableToServeDataRetryInSpecifiedSeconds => {
                "HpdrUnableToServeDataRetryInSpecifiedSeconds"
            }
            Self::HpdrUnableToServeDataDoNotRetry => "HpdrUnableToServeDataDoNotRetry",
            Self::HpdrDataRequestOutsideBoundsOfAvailableData => {
                "HpdrDataRequestOutsideBoundsOfAvailableData"
            }
            Self::HpdrGeneralRejectError => "HpdrGeneralRejectError",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i8)]
pub enum TradeConditionEnum {
    TradeConditionNone = 0,
    TradeConditionNonLastUpdateEquityTrade = 1,
    TradeConditionOddLotEquityTrade = 2,
}

impl TradeConditionEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

impl core::fmt::Display for TradeConditionEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TradeConditionNone => "TradeConditionNone",
            Self::TradeConditionNonLastUpdateEquityTrade => {
                "TradeConditionNonLastUpdateEquityTrade"
            }
            Self::TradeConditionOddLotEquityTrade => "TradeConditionOddLotEquityTrade",
        })
    }
}

impl core::fmt::Debug for TradeConditionEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TradeConditionNone => "TradeConditionNone",
            Self::TradeConditionNonLastUpdateEquityTrade => {
                "TradeConditionNonLastUpdateEquityTrade"
            }
            Self::TradeConditionOddLotEquityTrade => "TradeConditionOddLotEquityTrade",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i8)]
pub enum TradeModeEnum {
    TradeModeUnset = 0,
    TradeModeDemo = 1,
    TradeModeSimulated = 2,
    TradeModeLive = 3,
}

impl TradeModeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i8).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i8::from_le(value as i8)) }
        }
    }
}

impl core::fmt::Display for TradeModeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TradeModeUnset => "TradeModeUnset",
            Self::TradeModeDemo => "TradeModeDemo",
            Self::TradeModeSimulated => "TradeModeSimulated",
            Self::TradeModeLive => "TradeModeLive",
        })
    }
}

impl core::fmt::Debug for TradeModeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::TradeModeUnset => "TradeModeUnset",
            Self::TradeModeDemo => "TradeModeDemo",
            Self::TradeModeSimulated => "TradeModeSimulated",
            Self::TradeModeLive => "TradeModeLive",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i32)]
pub enum ReplayChartDataActionEnum {
    ReplayChartDataActionNone = 0,
    ReplayChartDataActionStop = 1,
    ReplayChartDataActionPause = 2,
    ReplayChartDataActionResume = 3,
    ReplayChartDataActionFinish = 4,
    ReplayChartDataActionChangeSpeed = 5,
}

impl ReplayChartDataActionEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for ReplayChartDataActionEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::ReplayChartDataActionNone => "ReplayChartDataActionNone",
            Self::ReplayChartDataActionStop => "ReplayChartDataActionStop",
            Self::ReplayChartDataActionPause => "ReplayChartDataActionPause",
            Self::ReplayChartDataActionResume => "ReplayChartDataActionResume",
            Self::ReplayChartDataActionFinish => "ReplayChartDataActionFinish",
            Self::ReplayChartDataActionChangeSpeed => "ReplayChartDataActionChangeSpeed",
        })
    }
}

impl core::fmt::Debug for ReplayChartDataActionEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::ReplayChartDataActionNone => "ReplayChartDataActionNone",
            Self::ReplayChartDataActionStop => "ReplayChartDataActionStop",
            Self::ReplayChartDataActionPause => "ReplayChartDataActionPause",
            Self::ReplayChartDataActionResume => "ReplayChartDataActionResume",
            Self::ReplayChartDataActionFinish => "ReplayChartDataActionFinish",
            Self::ReplayChartDataActionChangeSpeed => "ReplayChartDataActionChangeSpeed",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i32)]
pub enum ReplayChartDataStatusEnum {
    ReplayChartDataStatusUnset = 0,
    ReplayChartDataStatusStarted = 1,
    ReplayChartDataStatusError = 2,
    ReplayChartDataStatusComplete = 3,
}

impl ReplayChartDataStatusEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for ReplayChartDataStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::ReplayChartDataStatusUnset => "ReplayChartDataStatusUnset",
            Self::ReplayChartDataStatusStarted => "ReplayChartDataStatusStarted",
            Self::ReplayChartDataStatusError => "ReplayChartDataStatusError",
            Self::ReplayChartDataStatusComplete => "ReplayChartDataStatusComplete",
        })
    }
}

impl core::fmt::Debug for ReplayChartDataStatusEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::ReplayChartDataStatusUnset => "ReplayChartDataStatusUnset",
            Self::ReplayChartDataStatusStarted => "ReplayChartDataStatusStarted",
            Self::ReplayChartDataStatusError => "ReplayChartDataStatusError",
            Self::ReplayChartDataStatusComplete => "ReplayChartDataStatusComplete",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i32)]
pub enum UseCompressionEnum {
    UseCompressionDisabled = 0,
    UseCompressionBlockCompression = 1,
    UseCompressionStreamingCompression = 2,
}

impl UseCompressionEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for UseCompressionEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::UseCompressionDisabled => "UseCompressionDisabled",
            Self::UseCompressionBlockCompression => "UseCompressionBlockCompression",
            Self::UseCompressionStreamingCompression => "UseCompressionStreamingCompression",
        })
    }
}

impl core::fmt::Debug for UseCompressionEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::UseCompressionDisabled => "UseCompressionDisabled",
            Self::UseCompressionBlockCompression => "UseCompressionBlockCompression",
            Self::UseCompressionStreamingCompression => "UseCompressionStreamingCompression",
        })
    }
}

#[derive(Clone, Copy)]
#[repr(i32)]
pub enum WriteIntradayDataFileSessionValueTypeEnum {
    IntradayDataFileSessionValueUnset = 0,
    IntradayDataFileSessionValueDailyOpen = 1,
    IntradayDataFileSessionValueDailyHigh = 2,
    IntradayDataFileSessionValueDailyLow = 3,
    IntradayDataFileSessionValueDailyVolume = 4,
    IntradayDataFileSessionValueDailySettlementPrice = 5,
    IntradayDataFileSessionValueOpenInterest = 6,
    IntradayDataFileSessionValueOddLotTrade = 7,
    IntradayDataFileSessionValueNonLastUpdateEquityTrade = 8,
}

impl WriteIntradayDataFileSessionValueTypeEnum {
    #[inline]
    pub fn to_le(self) -> Self {
        #[cfg(target_endian = "little")]
        {
            self
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute((self as i32).to_le()) }
        }
    }

    #[inline]
    pub fn from_le(value: Self) -> Self {
        #[cfg(target_endian = "little")]
        {
            value
        }
        #[cfg(not(target_endian = "little"))]
        {
            unsafe { core::mem::transmute(i32::from_le(value as i32)) }
        }
    }
}

impl core::fmt::Display for WriteIntradayDataFileSessionValueTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::IntradayDataFileSessionValueUnset => "IntradayDataFileSessionValueUnset",
            Self::IntradayDataFileSessionValueDailyOpen => "IntradayDataFileSessionValueDailyOpen",
            Self::IntradayDataFileSessionValueDailyHigh => "IntradayDataFileSessionValueDailyHigh",
            Self::IntradayDataFileSessionValueDailyLow => "IntradayDataFileSessionValueDailyLow",
            Self::IntradayDataFileSessionValueDailyVolume => {
                "IntradayDataFileSessionValueDailyVolume"
            }
            Self::IntradayDataFileSessionValueDailySettlementPrice => {
                "IntradayDataFileSessionValueDailySettlementPrice"
            }
            Self::IntradayDataFileSessionValueOpenInterest => {
                "IntradayDataFileSessionValueOpenInterest"
            }
            Self::IntradayDataFileSessionValueOddLotTrade => {
                "IntradayDataFileSessionValueOddLotTrade"
            }
            Self::IntradayDataFileSessionValueNonLastUpdateEquityTrade => {
                "IntradayDataFileSessionValueNonLastUpdateEquityTrade"
            }
        })
    }
}

impl core::fmt::Debug for WriteIntradayDataFileSessionValueTypeEnum {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(match self {
            Self::IntradayDataFileSessionValueUnset => "IntradayDataFileSessionValueUnset",
            Self::IntradayDataFileSessionValueDailyOpen => "IntradayDataFileSessionValueDailyOpen",
            Self::IntradayDataFileSessionValueDailyHigh => "IntradayDataFileSessionValueDailyHigh",
            Self::IntradayDataFileSessionValueDailyLow => "IntradayDataFileSessionValueDailyLow",
            Self::IntradayDataFileSessionValueDailyVolume => {
                "IntradayDataFileSessionValueDailyVolume"
            }
            Self::IntradayDataFileSessionValueDailySettlementPrice => {
                "IntradayDataFileSessionValueDailySettlementPrice"
            }
            Self::IntradayDataFileSessionValueOpenInterest => {
                "IntradayDataFileSessionValueOpenInterest"
            }
            Self::IntradayDataFileSessionValueOddLotTrade => {
                "IntradayDataFileSessionValueOddLotTrade"
            }
            Self::IntradayDataFileSessionValueNonLastUpdateEquityTrade => {
                "IntradayDataFileSessionValueNonLastUpdateEquityTrade"
            }
        })
    }
}
