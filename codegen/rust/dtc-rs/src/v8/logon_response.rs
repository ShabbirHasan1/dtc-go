// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-25 15:25:42.126453 +0800 WITA m=+0.007296918
use super::*;

pub(crate) const LOGON_RESPONSE_VLS_SIZE: usize = 52;

pub(crate) const LOGON_RESPONSE_FIXED_SIZE: usize = 256;

/// size                                                  u16              = LogonResponseVLSSize  (52)
/// type                                                  u16              = LOGON_RESPONSE  (2)
/// base_size                                             u16              = LogonResponseVLSSize  (52)
/// protocol_version                                      i32              = CURRENT_VERSION  (8)
/// result                                                LogonStatusEnum  = 0
/// result_text                                           string           = ""
/// reconnect_address                                     string           = ""
/// integer1                                              i32              = 0
/// server_name                                           string           = ""
/// market_depth_updates_best_bid_and_ask                 u8               = 0
/// trading_is_supported                                  bool             = false
/// oco_orders_supported                                  bool             = false
/// order_cancel_replace_supported                        bool             = true
/// symbol_exchange_delimiter                             string           = ""
/// security_definitions_supported                        bool             = false
/// historical_price_data_supported                       bool             = false
/// resubscribe_when_market_data_feed_available           u8               = 0
/// market_depth_is_supported                             bool             = true
/// one_historical_price_data_request_per_connection      u8               = 0
/// bracket_orders_supported                              bool             = false
/// unused1                                               u8               = 0
/// uses_multiple_positions_per_symbol_and_trade_account  u8               = 0
/// market_data_supported                                 bool             = false
pub(crate) const LOGON_RESPONSE_VLS_DEFAULT: [u8; 52] = [
    52, 0, 2, 0, 52, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/// size                                                  u16              = LogonResponseFixedSize  (256)
/// type                                                  u16              = LOGON_RESPONSE  (2)
/// protocol_version                                      i32              = CURRENT_VERSION  (8)
/// result                                                LogonStatusEnum  = 0
/// result_text                                           string96         = ""
/// reconnect_address                                     string64         = ""
/// integer1                                              i32              = 0
/// server_name                                           string60         = ""
/// market_depth_updates_best_bid_and_ask                 u8               = 0
/// trading_is_supported                                  bool             = false
/// oco_orders_supported                                  bool             = false
/// order_cancel_replace_supported                        bool             = true
/// symbol_exchange_delimiter                             string4          = ""
/// security_definitions_supported                        bool             = false
/// historical_price_data_supported                       bool             = false
/// resubscribe_when_market_data_feed_available           u8               = 0
/// market_depth_is_supported                             bool             = true
/// one_historical_price_data_request_per_connection      u8               = 0
/// bracket_orders_supported                              bool             = false
/// unused1                                               u8               = 0
/// uses_multiple_positions_per_symbol_and_trade_account  u8               = 0
/// market_data_supported                                 bool             = true
pub(crate) const LOGON_RESPONSE_FIXED_DEFAULT: [u8; 256] = [
    0, 1, 2, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/// This is a response message indicating either success or an error logging
/// on to the Server.
pub trait LogonResponse: Message {
    type Safe: LogonResponse;
    type Unsafe: LogonResponse;

    /// This is automatically set by the constructor.
    fn protocol_version(&self) -> i32;

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn result(&self) -> LogonStatusEnum;

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn result_text(&self) -> &str;

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn reconnect_address(&self) -> &str;

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn integer1(&self) -> i32;

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn server_name(&self) -> &str;

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn market_depth_updates_best_bid_and_ask(&self) -> u8;

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn trading_is_supported(&self) -> bool;

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn oco_orders_supported(&self) -> bool;

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn order_cancel_replace_supported(&self) -> bool;

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn symbol_exchange_delimiter(&self) -> &str;

    /// Set to 1 if the Server supports Security Definition messages.
    fn security_definitions_supported(&self) -> bool;

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn historical_price_data_supported(&self) -> bool;

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn resubscribe_when_market_data_feed_available(&self) -> u8;

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn market_depth_is_supported(&self) -> bool;

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn one_historical_price_data_request_per_connection(&self) -> u8;

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn bracket_orders_supported(&self) -> bool;

    fn unused1(&self) -> u8;

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn uses_multiple_positions_per_symbol_and_trade_account(&self) -> u8;

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn market_data_supported(&self) -> bool;

    /// This is automatically set by the constructor.
    fn set_protocol_version(&mut self, value: i32) -> &mut Self;

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn set_result(&mut self, value: LogonStatusEnum) -> &mut Self;

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn set_result_text(&mut self, value: &str) -> &mut Self;

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn set_reconnect_address(&mut self, value: &str) -> &mut Self;

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn set_integer1(&mut self, value: i32) -> &mut Self;

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn set_server_name(&mut self, value: &str) -> &mut Self;

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn set_market_depth_updates_best_bid_and_ask(&mut self, value: u8) -> &mut Self;

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn set_trading_is_supported(&mut self, value: bool) -> &mut Self;

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn set_oco_orders_supported(&mut self, value: bool) -> &mut Self;

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn set_order_cancel_replace_supported(&mut self, value: bool) -> &mut Self;

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn set_symbol_exchange_delimiter(&mut self, value: &str) -> &mut Self;

    /// Set to 1 if the Server supports Security Definition messages.
    fn set_security_definitions_supported(&mut self, value: bool) -> &mut Self;

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn set_historical_price_data_supported(&mut self, value: bool) -> &mut Self;

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn set_resubscribe_when_market_data_feed_available(&mut self, value: u8) -> &mut Self;

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn set_market_depth_is_supported(&mut self, value: bool) -> &mut Self;

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn set_one_historical_price_data_request_per_connection(&mut self, value: u8) -> &mut Self;

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn set_bracket_orders_supported(&mut self, value: bool) -> &mut Self;

    fn set_unused1(&mut self, value: u8) -> &mut Self;

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn set_uses_multiple_positions_per_symbol_and_trade_account(&mut self, value: u8) -> &mut Self;

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn set_market_data_supported(&mut self, value: bool) -> &mut Self;

    fn clone_safe(&self) -> Self::Safe;

    fn to_safe(self) -> Self::Safe;

    fn copy_to(&self, to: &mut impl LogonResponse) {
        to.set_protocol_version(self.protocol_version());
        to.set_result(self.result());
        to.set_result_text(self.result_text());
        to.set_reconnect_address(self.reconnect_address());
        to.set_integer1(self.integer1());
        to.set_server_name(self.server_name());
        to.set_market_depth_updates_best_bid_and_ask(self.market_depth_updates_best_bid_and_ask());
        to.set_trading_is_supported(self.trading_is_supported());
        to.set_oco_orders_supported(self.oco_orders_supported());
        to.set_order_cancel_replace_supported(self.order_cancel_replace_supported());
        to.set_symbol_exchange_delimiter(self.symbol_exchange_delimiter());
        to.set_security_definitions_supported(self.security_definitions_supported());
        to.set_historical_price_data_supported(self.historical_price_data_supported());
        to.set_resubscribe_when_market_data_feed_available(
            self.resubscribe_when_market_data_feed_available(),
        );
        to.set_market_depth_is_supported(self.market_depth_is_supported());
        to.set_one_historical_price_data_request_per_connection(
            self.one_historical_price_data_request_per_connection(),
        );
        to.set_bracket_orders_supported(self.bracket_orders_supported());
        to.set_unused1(self.unused1());
        to.set_uses_multiple_positions_per_symbol_and_trade_account(
            self.uses_multiple_positions_per_symbol_and_trade_account(),
        );
        to.set_market_data_supported(self.market_data_supported());
    }
}

/// This is a response message indicating either success or an error logging
/// on to the Server.
pub struct LogonResponseVLS {
    data: *const LogonResponseVLSData,
    capacity: usize,
}

pub struct LogonResponseVLSUnsafe {
    data: *const LogonResponseVLSData,
    capacity: usize,
}

#[repr(packed(8), C)]
pub struct LogonResponseVLSData {
    size: u16,
    r#type: u16,
    base_size: u16,
    protocol_version: i32,
    result: LogonStatusEnum,
    result_text: VLS,
    reconnect_address: VLS,
    integer1: i32,
    server_name: VLS,
    market_depth_updates_best_bid_and_ask: u8,
    trading_is_supported: bool,
    oco_orders_supported: bool,
    order_cancel_replace_supported: bool,
    symbol_exchange_delimiter: VLS,
    security_definitions_supported: bool,
    historical_price_data_supported: bool,
    resubscribe_when_market_data_feed_available: u8,
    market_depth_is_supported: bool,
    one_historical_price_data_request_per_connection: u8,
    bracket_orders_supported: bool,
    unused1: u8,
    uses_multiple_positions_per_symbol_and_trade_account: u8,
    market_data_supported: bool,
}

/// This is a response message indicating either success or an error logging
/// on to the Server.
pub struct LogonResponseFixed {
    data: *const LogonResponseFixedData,
}

pub struct LogonResponseFixedUnsafe {
    data: *const LogonResponseFixedData,
}

#[repr(packed(8), C)]
pub struct LogonResponseFixedData {
    size: u16,
    r#type: u16,
    protocol_version: i32,
    result: LogonStatusEnum,
    result_text: [u8; 96],
    reconnect_address: [u8; 64],
    integer1: i32,
    server_name: [u8; 60],
    market_depth_updates_best_bid_and_ask: u8,
    trading_is_supported: bool,
    oco_orders_supported: bool,
    order_cancel_replace_supported: bool,
    symbol_exchange_delimiter: [u8; 4],
    security_definitions_supported: bool,
    historical_price_data_supported: bool,
    resubscribe_when_market_data_feed_available: u8,
    market_depth_is_supported: bool,
    one_historical_price_data_request_per_connection: u8,
    bracket_orders_supported: bool,
    unused1: u8,
    uses_multiple_positions_per_symbol_and_trade_account: u8,
    market_data_supported: bool,
}

impl LogonResponseVLSData {
    pub fn new() -> Self {
        Self {
            size: 52u16.to_le(),
            r#type: LOGON_RESPONSE.to_le(),
            base_size: 52u16.to_le(),
            protocol_version: CURRENT_VERSION.to_le(),
            result: LogonStatusEnum::LogonSuccess.to_le(),
            result_text: crate::message::VLS::new(),
            reconnect_address: crate::message::VLS::new(),
            integer1: 0i32,
            server_name: crate::message::VLS::new(),
            market_depth_updates_best_bid_and_ask: 0u8,
            trading_is_supported: false,
            oco_orders_supported: false,
            order_cancel_replace_supported: true,
            symbol_exchange_delimiter: crate::message::VLS::new(),
            security_definitions_supported: false,
            historical_price_data_supported: false,
            resubscribe_when_market_data_feed_available: 0u8,
            market_depth_is_supported: true,
            one_historical_price_data_request_per_connection: 0u8,
            bracket_orders_supported: false,
            unused1: 0u8,
            uses_multiple_positions_per_symbol_and_trade_account: 0u8,
            market_data_supported: false,
        }
    }
}

impl LogonResponseFixedData {
    pub fn new() -> Self {
        Self {
            size: 256u16.to_le(),
            r#type: LOGON_RESPONSE.to_le(),
            protocol_version: CURRENT_VERSION.to_le(),
            result: LogonStatusEnum::LogonSuccess.to_le(),
            result_text: [0; 96],
            reconnect_address: [0; 64],
            integer1: 0i32,
            server_name: [0; 60],
            market_depth_updates_best_bid_and_ask: 0u8,
            trading_is_supported: false,
            oco_orders_supported: false,
            order_cancel_replace_supported: true,
            symbol_exchange_delimiter: [0; 4],
            security_definitions_supported: false,
            historical_price_data_supported: false,
            resubscribe_when_market_data_feed_available: 0u8,
            market_depth_is_supported: true,
            one_historical_price_data_request_per_connection: 0u8,
            bracket_orders_supported: false,
            unused1: 0u8,
            uses_multiple_positions_per_symbol_and_trade_account: 0u8,
            market_data_supported: true,
        }
    }
}

unsafe impl Send for LogonResponseFixed {}
unsafe impl Send for LogonResponseFixedUnsafe {}
unsafe impl Send for LogonResponseFixedData {}
unsafe impl Send for LogonResponseVLS {}
unsafe impl Send for LogonResponseVLSUnsafe {}
unsafe impl Send for LogonResponseVLSData {}

impl Drop for LogonResponseFixed {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for LogonResponseFixedUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for LogonResponseVLS {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for LogonResponseVLSUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Clone for LogonResponseFixed {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for LogonResponseFixedUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for LogonResponseVLS {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for LogonResponseVLSUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Into<Vec<u8>> for LogonResponseFixed {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for LogonResponseFixedUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for LogonResponseVLS {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for LogonResponseVLSUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl core::ops::Deref for LogonResponseFixed {
    type Target = LogonResponseFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for LogonResponseFixed {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for LogonResponseFixedUnsafe {
    type Target = LogonResponseFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for LogonResponseFixedUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for LogonResponseVLS {
    type Target = LogonResponseVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for LogonResponseVLS {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for LogonResponseVLSUnsafe {
    type Target = LogonResponseVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for LogonResponseVLSUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl crate::Message for LogonResponseFixed {
    type Data = LogonResponseFixedData;

    const BASE_SIZE: usize = 256;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, LogonResponseFixedData::new()),
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const LogonResponseFixedData,
        }
    }
}
impl crate::Message for LogonResponseFixedUnsafe {
    type Data = LogonResponseFixedData;

    const BASE_SIZE: usize = 256;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, LogonResponseFixedData::new()),
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const LogonResponseFixedData,
        }
    }
}
impl crate::Message for LogonResponseVLS {
    type Data = LogonResponseVLSData;

    const BASE_SIZE: usize = 52;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, LogonResponseVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const LogonResponseVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for LogonResponseVLS {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const LogonResponseVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl crate::Message for LogonResponseVLSUnsafe {
    type Data = LogonResponseVLSData;

    const BASE_SIZE: usize = 52;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, LogonResponseVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const LogonResponseVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for LogonResponseVLSUnsafe {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const LogonResponseVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
/// This is a response message indicating either success or an error logging
/// on to the Server.
impl LogonResponse for LogonResponseVLS {
    type Safe = LogonResponseVLS;
    type Unsafe = LogonResponseVLSUnsafe;

    /// This is automatically set by the constructor.
    fn protocol_version(&self) -> i32 {
        i32::from_le(self.protocol_version)
    }

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn result(&self) -> LogonStatusEnum {
        LogonStatusEnum::from_le(self.result)
    }

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn result_text(&self) -> &str {
        get_vls(self, self.result_text)
    }

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn reconnect_address(&self) -> &str {
        get_vls(self, self.reconnect_address)
    }

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn integer1(&self) -> i32 {
        i32::from_le(self.integer1)
    }

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn server_name(&self) -> &str {
        get_vls(self, self.server_name)
    }

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn market_depth_updates_best_bid_and_ask(&self) -> u8 {
        self.market_depth_updates_best_bid_and_ask
    }

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn trading_is_supported(&self) -> bool {
        self.trading_is_supported
    }

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn oco_orders_supported(&self) -> bool {
        self.oco_orders_supported
    }

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn order_cancel_replace_supported(&self) -> bool {
        self.order_cancel_replace_supported
    }

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn symbol_exchange_delimiter(&self) -> &str {
        get_vls(self, self.symbol_exchange_delimiter)
    }

    /// Set to 1 if the Server supports Security Definition messages.
    fn security_definitions_supported(&self) -> bool {
        self.security_definitions_supported
    }

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn historical_price_data_supported(&self) -> bool {
        self.historical_price_data_supported
    }

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn resubscribe_when_market_data_feed_available(&self) -> u8 {
        self.resubscribe_when_market_data_feed_available
    }

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn market_depth_is_supported(&self) -> bool {
        self.market_depth_is_supported
    }

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn one_historical_price_data_request_per_connection(&self) -> u8 {
        self.one_historical_price_data_request_per_connection
    }

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn bracket_orders_supported(&self) -> bool {
        self.bracket_orders_supported
    }

    fn unused1(&self) -> u8 {
        self.unused1
    }

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn uses_multiple_positions_per_symbol_and_trade_account(&self) -> u8 {
        self.uses_multiple_positions_per_symbol_and_trade_account
    }

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn market_data_supported(&self) -> bool {
        self.market_data_supported
    }

    /// This is automatically set by the constructor.
    fn set_protocol_version(&mut self, value: i32) -> &mut Self {
        self.protocol_version = value.to_le();
        self
    }

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn set_result(&mut self, value: LogonStatusEnum) -> &mut Self {
        self.result = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn set_result_text(&mut self, value: &str) -> &mut Self {
        self.result_text = set_vls(self, self.result_text, value);
        self
    }

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn set_reconnect_address(&mut self, value: &str) -> &mut Self {
        self.reconnect_address = set_vls(self, self.reconnect_address, value);
        self
    }

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn set_integer1(&mut self, value: i32) -> &mut Self {
        self.integer1 = value.to_le();
        self
    }

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn set_server_name(&mut self, value: &str) -> &mut Self {
        self.server_name = set_vls(self, self.server_name, value);
        self
    }

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn set_market_depth_updates_best_bid_and_ask(&mut self, value: u8) -> &mut Self {
        self.market_depth_updates_best_bid_and_ask = value;
        self
    }

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn set_trading_is_supported(&mut self, value: bool) -> &mut Self {
        self.trading_is_supported = value;
        self
    }

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn set_oco_orders_supported(&mut self, value: bool) -> &mut Self {
        self.oco_orders_supported = value;
        self
    }

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn set_order_cancel_replace_supported(&mut self, value: bool) -> &mut Self {
        self.order_cancel_replace_supported = value;
        self
    }

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn set_symbol_exchange_delimiter(&mut self, value: &str) -> &mut Self {
        self.symbol_exchange_delimiter = set_vls(self, self.symbol_exchange_delimiter, value);
        self
    }

    /// Set to 1 if the Server supports Security Definition messages.
    fn set_security_definitions_supported(&mut self, value: bool) -> &mut Self {
        self.security_definitions_supported = value;
        self
    }

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn set_historical_price_data_supported(&mut self, value: bool) -> &mut Self {
        self.historical_price_data_supported = value;
        self
    }

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn set_resubscribe_when_market_data_feed_available(&mut self, value: u8) -> &mut Self {
        self.resubscribe_when_market_data_feed_available = value;
        self
    }

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn set_market_depth_is_supported(&mut self, value: bool) -> &mut Self {
        self.market_depth_is_supported = value;
        self
    }

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn set_one_historical_price_data_request_per_connection(&mut self, value: u8) -> &mut Self {
        self.one_historical_price_data_request_per_connection = value;
        self
    }

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn set_bracket_orders_supported(&mut self, value: bool) -> &mut Self {
        self.bracket_orders_supported = value;
        self
    }

    fn set_unused1(&mut self, value: u8) -> &mut Self {
        self.unused1 = value;
        self
    }

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn set_uses_multiple_positions_per_symbol_and_trade_account(&mut self, value: u8) -> &mut Self {
        self.uses_multiple_positions_per_symbol_and_trade_account = value;
        self
    }

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn set_market_data_supported(&mut self, value: bool) -> &mut Self {
        self.market_data_supported = value;
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

/// This is a response message indicating either success or an error logging
/// on to the Server.
impl LogonResponse for LogonResponseVLSUnsafe {
    type Safe = LogonResponseVLS;
    type Unsafe = LogonResponseVLSUnsafe;

    /// This is automatically set by the constructor.
    fn protocol_version(&self) -> i32 {
        if self.is_out_of_bounds(12) {
            CURRENT_VERSION.to_le()
        } else {
            i32::from_le(self.protocol_version)
        }
    }

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn result(&self) -> LogonStatusEnum {
        if self.is_out_of_bounds(16) {
            LogonStatusEnum::LogonSuccess.to_le()
        } else {
            LogonStatusEnum::from_le(self.result)
        }
    }

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn result_text(&self) -> &str {
        if self.is_out_of_bounds(20) {
            ""
        } else {
            get_vls(self, self.result_text)
        }
    }

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn reconnect_address(&self) -> &str {
        if self.is_out_of_bounds(24) {
            ""
        } else {
            get_vls(self, self.reconnect_address)
        }
    }

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn integer1(&self) -> i32 {
        if self.is_out_of_bounds(28) {
            0i32
        } else {
            i32::from_le(self.integer1)
        }
    }

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn server_name(&self) -> &str {
        if self.is_out_of_bounds(32) {
            ""
        } else {
            get_vls(self, self.server_name)
        }
    }

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn market_depth_updates_best_bid_and_ask(&self) -> u8 {
        if self.is_out_of_bounds(33) {
            0u8
        } else {
            self.market_depth_updates_best_bid_and_ask
        }
    }

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn trading_is_supported(&self) -> bool {
        if self.is_out_of_bounds(34) {
            false
        } else {
            self.trading_is_supported
        }
    }

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn oco_orders_supported(&self) -> bool {
        if self.is_out_of_bounds(35) {
            false
        } else {
            self.oco_orders_supported
        }
    }

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn order_cancel_replace_supported(&self) -> bool {
        if self.is_out_of_bounds(36) {
            true
        } else {
            self.order_cancel_replace_supported
        }
    }

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn symbol_exchange_delimiter(&self) -> &str {
        if self.is_out_of_bounds(40) {
            ""
        } else {
            get_vls(self, self.symbol_exchange_delimiter)
        }
    }

    /// Set to 1 if the Server supports Security Definition messages.
    fn security_definitions_supported(&self) -> bool {
        if self.is_out_of_bounds(41) {
            false
        } else {
            self.security_definitions_supported
        }
    }

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn historical_price_data_supported(&self) -> bool {
        if self.is_out_of_bounds(42) {
            false
        } else {
            self.historical_price_data_supported
        }
    }

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn resubscribe_when_market_data_feed_available(&self) -> u8 {
        if self.is_out_of_bounds(43) {
            0u8
        } else {
            self.resubscribe_when_market_data_feed_available
        }
    }

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn market_depth_is_supported(&self) -> bool {
        if self.is_out_of_bounds(44) {
            true
        } else {
            self.market_depth_is_supported
        }
    }

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn one_historical_price_data_request_per_connection(&self) -> u8 {
        if self.is_out_of_bounds(45) {
            0u8
        } else {
            self.one_historical_price_data_request_per_connection
        }
    }

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn bracket_orders_supported(&self) -> bool {
        if self.is_out_of_bounds(46) {
            false
        } else {
            self.bracket_orders_supported
        }
    }

    fn unused1(&self) -> u8 {
        if self.is_out_of_bounds(47) {
            0u8
        } else {
            self.unused1
        }
    }

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn uses_multiple_positions_per_symbol_and_trade_account(&self) -> u8 {
        if self.is_out_of_bounds(48) {
            0u8
        } else {
            self.uses_multiple_positions_per_symbol_and_trade_account
        }
    }

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn market_data_supported(&self) -> bool {
        if self.is_out_of_bounds(49) {
            false
        } else {
            self.market_data_supported
        }
    }

    /// This is automatically set by the constructor.
    fn set_protocol_version(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(12) {
            self.protocol_version = value.to_le();
        }
        self
    }

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn set_result(&mut self, value: LogonStatusEnum) -> &mut Self {
        if !self.is_out_of_bounds(16) {
            self.result = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn set_result_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(20) {
            self.result_text = set_vls(self, self.result_text, value);
        }
        self
    }

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn set_reconnect_address(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(24) {
            self.reconnect_address = set_vls(self, self.reconnect_address, value);
        }
        self
    }

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn set_integer1(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(28) {
            self.integer1 = value.to_le();
        }
        self
    }

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn set_server_name(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(32) {
            self.server_name = set_vls(self, self.server_name, value);
        }
        self
    }

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn set_market_depth_updates_best_bid_and_ask(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(33) {
            self.market_depth_updates_best_bid_and_ask = value;
        }
        self
    }

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn set_trading_is_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(34) {
            self.trading_is_supported = value;
        }
        self
    }

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn set_oco_orders_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(35) {
            self.oco_orders_supported = value;
        }
        self
    }

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn set_order_cancel_replace_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(36) {
            self.order_cancel_replace_supported = value;
        }
        self
    }

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn set_symbol_exchange_delimiter(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(40) {
            self.symbol_exchange_delimiter = set_vls(self, self.symbol_exchange_delimiter, value);
        }
        self
    }

    /// Set to 1 if the Server supports Security Definition messages.
    fn set_security_definitions_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(41) {
            self.security_definitions_supported = value;
        }
        self
    }

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn set_historical_price_data_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(42) {
            self.historical_price_data_supported = value;
        }
        self
    }

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn set_resubscribe_when_market_data_feed_available(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(43) {
            self.resubscribe_when_market_data_feed_available = value;
        }
        self
    }

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn set_market_depth_is_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(44) {
            self.market_depth_is_supported = value;
        }
        self
    }

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn set_one_historical_price_data_request_per_connection(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(45) {
            self.one_historical_price_data_request_per_connection = value;
        }
        self
    }

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn set_bracket_orders_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(46) {
            self.bracket_orders_supported = value;
        }
        self
    }

    fn set_unused1(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(47) {
            self.unused1 = value;
        }
        self
    }

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn set_uses_multiple_positions_per_symbol_and_trade_account(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(48) {
            self.uses_multiple_positions_per_symbol_and_trade_account = value;
        }
        self
    }

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn set_market_data_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(49) {
            self.market_data_supported = value;
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

/// This is a response message indicating either success or an error logging
/// on to the Server.
impl LogonResponse for LogonResponseFixed {
    type Safe = LogonResponseFixed;
    type Unsafe = LogonResponseFixedUnsafe;

    /// This is automatically set by the constructor.
    fn protocol_version(&self) -> i32 {
        i32::from_le(self.protocol_version)
    }

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn result(&self) -> LogonStatusEnum {
        LogonStatusEnum::from_le(self.result)
    }

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn result_text(&self) -> &str {
        get_fixed(&self.result_text[..])
    }

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn reconnect_address(&self) -> &str {
        get_fixed(&self.reconnect_address[..])
    }

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn integer1(&self) -> i32 {
        i32::from_le(self.integer1)
    }

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn server_name(&self) -> &str {
        get_fixed(&self.server_name[..])
    }

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn market_depth_updates_best_bid_and_ask(&self) -> u8 {
        self.market_depth_updates_best_bid_and_ask
    }

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn trading_is_supported(&self) -> bool {
        self.trading_is_supported
    }

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn oco_orders_supported(&self) -> bool {
        self.oco_orders_supported
    }

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn order_cancel_replace_supported(&self) -> bool {
        self.order_cancel_replace_supported
    }

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn symbol_exchange_delimiter(&self) -> &str {
        get_fixed(&self.symbol_exchange_delimiter[..])
    }

    /// Set to 1 if the Server supports Security Definition messages.
    fn security_definitions_supported(&self) -> bool {
        self.security_definitions_supported
    }

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn historical_price_data_supported(&self) -> bool {
        self.historical_price_data_supported
    }

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn resubscribe_when_market_data_feed_available(&self) -> u8 {
        self.resubscribe_when_market_data_feed_available
    }

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn market_depth_is_supported(&self) -> bool {
        self.market_depth_is_supported
    }

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn one_historical_price_data_request_per_connection(&self) -> u8 {
        self.one_historical_price_data_request_per_connection
    }

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn bracket_orders_supported(&self) -> bool {
        self.bracket_orders_supported
    }

    fn unused1(&self) -> u8 {
        self.unused1
    }

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn uses_multiple_positions_per_symbol_and_trade_account(&self) -> u8 {
        self.uses_multiple_positions_per_symbol_and_trade_account
    }

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn market_data_supported(&self) -> bool {
        self.market_data_supported
    }

    /// This is automatically set by the constructor.
    fn set_protocol_version(&mut self, value: i32) -> &mut Self {
        self.protocol_version = value.to_le();
        self
    }

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn set_result(&mut self, value: LogonStatusEnum) -> &mut Self {
        self.result = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn set_result_text(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.result_text[..], value);
        self
    }

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn set_reconnect_address(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.reconnect_address[..], value);
        self
    }

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn set_integer1(&mut self, value: i32) -> &mut Self {
        self.integer1 = value.to_le();
        self
    }

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn set_server_name(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.server_name[..], value);
        self
    }

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn set_market_depth_updates_best_bid_and_ask(&mut self, value: u8) -> &mut Self {
        self.market_depth_updates_best_bid_and_ask = value;
        self
    }

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn set_trading_is_supported(&mut self, value: bool) -> &mut Self {
        self.trading_is_supported = value;
        self
    }

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn set_oco_orders_supported(&mut self, value: bool) -> &mut Self {
        self.oco_orders_supported = value;
        self
    }

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn set_order_cancel_replace_supported(&mut self, value: bool) -> &mut Self {
        self.order_cancel_replace_supported = value;
        self
    }

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn set_symbol_exchange_delimiter(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.symbol_exchange_delimiter[..], value);
        self
    }

    /// Set to 1 if the Server supports Security Definition messages.
    fn set_security_definitions_supported(&mut self, value: bool) -> &mut Self {
        self.security_definitions_supported = value;
        self
    }

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn set_historical_price_data_supported(&mut self, value: bool) -> &mut Self {
        self.historical_price_data_supported = value;
        self
    }

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn set_resubscribe_when_market_data_feed_available(&mut self, value: u8) -> &mut Self {
        self.resubscribe_when_market_data_feed_available = value;
        self
    }

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn set_market_depth_is_supported(&mut self, value: bool) -> &mut Self {
        self.market_depth_is_supported = value;
        self
    }

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn set_one_historical_price_data_request_per_connection(&mut self, value: u8) -> &mut Self {
        self.one_historical_price_data_request_per_connection = value;
        self
    }

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn set_bracket_orders_supported(&mut self, value: bool) -> &mut Self {
        self.bracket_orders_supported = value;
        self
    }

    fn set_unused1(&mut self, value: u8) -> &mut Self {
        self.unused1 = value;
        self
    }

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn set_uses_multiple_positions_per_symbol_and_trade_account(&mut self, value: u8) -> &mut Self {
        self.uses_multiple_positions_per_symbol_and_trade_account = value;
        self
    }

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn set_market_data_supported(&mut self, value: bool) -> &mut Self {
        self.market_data_supported = value;
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

/// This is a response message indicating either success or an error logging
/// on to the Server.
impl LogonResponse for LogonResponseFixedUnsafe {
    type Safe = LogonResponseFixed;
    type Unsafe = LogonResponseFixedUnsafe;

    /// This is automatically set by the constructor.
    fn protocol_version(&self) -> i32 {
        if self.is_out_of_bounds(8) {
            CURRENT_VERSION.to_le()
        } else {
            i32::from_le(self.protocol_version)
        }
    }

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn result(&self) -> LogonStatusEnum {
        if self.is_out_of_bounds(12) {
            LogonStatusEnum::LogonSuccess.to_le()
        } else {
            LogonStatusEnum::from_le(self.result)
        }
    }

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn result_text(&self) -> &str {
        if self.is_out_of_bounds(108) {
            ""
        } else {
            get_fixed(&self.result_text[..])
        }
    }

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn reconnect_address(&self) -> &str {
        if self.is_out_of_bounds(172) {
            ""
        } else {
            get_fixed(&self.reconnect_address[..])
        }
    }

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn integer1(&self) -> i32 {
        if self.is_out_of_bounds(176) {
            0i32
        } else {
            i32::from_le(self.integer1)
        }
    }

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn server_name(&self) -> &str {
        if self.is_out_of_bounds(236) {
            ""
        } else {
            get_fixed(&self.server_name[..])
        }
    }

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn market_depth_updates_best_bid_and_ask(&self) -> u8 {
        if self.is_out_of_bounds(237) {
            0u8
        } else {
            self.market_depth_updates_best_bid_and_ask
        }
    }

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn trading_is_supported(&self) -> bool {
        if self.is_out_of_bounds(238) {
            false
        } else {
            self.trading_is_supported
        }
    }

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn oco_orders_supported(&self) -> bool {
        if self.is_out_of_bounds(239) {
            false
        } else {
            self.oco_orders_supported
        }
    }

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn order_cancel_replace_supported(&self) -> bool {
        if self.is_out_of_bounds(240) {
            true
        } else {
            self.order_cancel_replace_supported
        }
    }

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn symbol_exchange_delimiter(&self) -> &str {
        if self.is_out_of_bounds(244) {
            ""
        } else {
            get_fixed(&self.symbol_exchange_delimiter[..])
        }
    }

    /// Set to 1 if the Server supports Security Definition messages.
    fn security_definitions_supported(&self) -> bool {
        if self.is_out_of_bounds(245) {
            false
        } else {
            self.security_definitions_supported
        }
    }

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn historical_price_data_supported(&self) -> bool {
        if self.is_out_of_bounds(246) {
            false
        } else {
            self.historical_price_data_supported
        }
    }

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn resubscribe_when_market_data_feed_available(&self) -> u8 {
        if self.is_out_of_bounds(247) {
            0u8
        } else {
            self.resubscribe_when_market_data_feed_available
        }
    }

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn market_depth_is_supported(&self) -> bool {
        if self.is_out_of_bounds(248) {
            true
        } else {
            self.market_depth_is_supported
        }
    }

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn one_historical_price_data_request_per_connection(&self) -> u8 {
        if self.is_out_of_bounds(249) {
            0u8
        } else {
            self.one_historical_price_data_request_per_connection
        }
    }

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn bracket_orders_supported(&self) -> bool {
        if self.is_out_of_bounds(250) {
            false
        } else {
            self.bracket_orders_supported
        }
    }

    fn unused1(&self) -> u8 {
        if self.is_out_of_bounds(251) {
            0u8
        } else {
            self.unused1
        }
    }

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn uses_multiple_positions_per_symbol_and_trade_account(&self) -> u8 {
        if self.is_out_of_bounds(252) {
            0u8
        } else {
            self.uses_multiple_positions_per_symbol_and_trade_account
        }
    }

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn market_data_supported(&self) -> bool {
        if self.is_out_of_bounds(253) {
            true
        } else {
            self.market_data_supported
        }
    }

    /// This is automatically set by the constructor.
    fn set_protocol_version(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(8) {
            self.protocol_version = value.to_le();
        }
        self
    }

    /// This can be set to one of the following constants:
    ///
    /// LOGON_SUCCESS
    /// LOGON_ERROR
    /// LOGON_ERROR_NO_RECONNECT
    /// LOGON_RECONNECT_NEW_ADDRESS
    /// LOGON_ERROR_NO_RECONNECT means that there has been an error logging on
    /// and the Client should not try to reconnect.
    ///
    /// The Server can set this field to LOGON_RECONNECT_NEW_ADDRESS to instruct
    /// the Client to reconnect to the Server at a different address. The new
    /// address is specified through the ReconnectAddress field. This supports
    /// dynamic connections to a server farm.
    fn set_result(&mut self, value: LogonStatusEnum) -> &mut Self {
        if !self.is_out_of_bounds(12) {
            self.result = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// Optional freeform text to provide information related to a successful
    /// or unsuccessful logon. The Client will display this text to the user.
    fn set_result_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(108) {
            set_fixed(&mut self.result_text[..], value);
        }
        self
    }

    /// Server address/IP number and optional port number to reconnect to. Format:
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    /// [Server Address:Port Number]. Only used if Result is set to LOGON_RECONNECT_NEW_ADDRESS.
    fn set_reconnect_address(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(172) {
            set_fixed(&mut self.reconnect_address[..], value);
        }
        self
    }

    /// Optional. General-purpose integer for the Server to communicate to the
    /// Client an integer value on logon.
    fn set_integer1(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(176) {
            self.integer1 = value.to_le();
        }
        self
    }

    /// Optional free-form text for the Server to fill out.
    ///
    /// It is recommended that the Server fill this in with descriptive text identifying
    /// itself to the Client.
    ///
    /// The length of this text string is 60 characters when fixed length strings
    /// are used.
    fn set_server_name(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(236) {
            set_fixed(&mut self.server_name[..], value);
        }
        self
    }

    /// Set this to 1 to indicate that the Server will only be sending market
    /// depth updates and not best bid and ask updates. The Client will use depth
    /// at level 1 to update the best bid and ask prices.
    ///
    /// Some Clients will maintain separate best bid and ask prices from market
    /// depth data.
    fn set_market_depth_updates_best_bid_and_ask(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(237) {
            self.market_depth_updates_best_bid_and_ask = value;
        }
        self
    }

    /// Set this to 1 to indicate the Server supports trading. Otherwise, the
    /// Client will not send through any trading messages.
    fn set_trading_is_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(238) {
            self.trading_is_supported = value;
        }
        self
    }

    /// Set this to 1 to indicate the Server supports OCO orders.
    fn set_oco_orders_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(239) {
            self.oco_orders_supported = value;
        }
        self
    }

    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    /// Set this to 0 if Server does not support the CancelReplaceOrderVLS message.
    fn set_order_cancel_replace_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(240) {
            self.order_cancel_replace_supported = value;
        }
        self
    }

    /// Some Clients will usually consider the Symbol and Exchange fields as a
    /// single text string. If the Server will be using the Exchange field in
    /// DTC messages that have a Symbol and Exchange fields, it must specify the
    /// SymbolExchangeDelimiter field to provide a standard delimiter for the
    /// Client to use to combine the Symbol and the Exchange into a single text
    /// string.
    ///
    /// It is recommended to use a "-" or ".". Examples of how the Client will
    /// then combine the Symbol and exchange.
    ///
    /// Symbol-Exchange
    /// Symbol.Exchange
    /// If this field is unset, then this is an indication to the Client that
    /// the Exchange field in DTC Protocol messages are not used.
    ///
    /// Even if the symbols supported by a Server have an Exchange text string,
    /// does not mean the Server has to use the Exchange field in DTC messages.
    /// The Server can combine the Symbol and the Exchange in Security Definition
    /// responses into the Symbol field only.
    ///
    /// When a Client sees that the SymbolExchangeDelimiter field is set, then
    /// it can use this delimiter to combine the Symbol and Exchange into a single
    /// text string. When the Client is setting the Symbol and Exchange in DTC
    /// messages, it needs to separate out the Symbol and Exchange from the larger
    /// text string and set those fields separately.
    fn set_symbol_exchange_delimiter(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(244) {
            set_fixed(&mut self.symbol_exchange_delimiter[..], value);
        }
        self
    }

    /// Set to 1 if the Server supports Security Definition messages.
    fn set_security_definitions_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(245) {
            self.security_definitions_supported = value;
        }
        self
    }

    /// Set this to 1 if the Server supports the HistoricalPriceDataRequestVLS
    /// message.
    fn set_historical_price_data_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(246) {
            self.historical_price_data_supported = value;
        }
        self
    }

    /// Set this to 1, so that when the Client receives a MarketDataFeedStatusFixed
    /// indicating the market data feed is restored, it will resubscribe to market
    /// data and market depth for all of the symbols it was previously tracking.
    /// data and market depth for all of the symbols it was previously tracking.
    fn set_resubscribe_when_market_data_feed_available(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(247) {
            self.resubscribe_when_market_data_feed_available = value;
        }
        self
    }

    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDepthRequestVLS message.
    ///
    /// The default is 0.
    fn set_market_depth_is_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(248) {
            self.market_depth_is_supported = value;
        }
        self
    }

    /// The server can optionally set the OneHistoricalPriceDataRequestPerConnection
    /// field to 1 in the LogonResponseVLS message to indicate that it only will
    /// accept one historical price data request per network connection.
    ///
    /// After the first request is served or rejected, the network connection
    /// will be gracefully closed at the appropriate time by the Server. This
    /// method simplifies the serving of historical price data on the Server side
    /// and the implementation on the Client side when data compression is used.
    /// and the implementation on the Client side when data compression is used.
    fn set_one_historical_price_data_request_per_connection(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(249) {
            self.one_historical_price_data_request_per_connection = value;
        }
        self
    }

    /// Set this to 1 to indicate the Server supports bracket orders.
    fn set_bracket_orders_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(250) {
            self.bracket_orders_supported = value;
        }
        self
    }

    fn set_unused1(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(251) {
            self.unused1 = value;
        }
        self
    }

    /// If the Server can report more than one Trade Position for a specific Symbol
    /// and Trade Account, then it needs to set UsesMultiplePositionsPerSymbolAndTradeAccount
    /// to 1.
    ///
    /// When the server has set to 1, it must always set PositionIdentifier in
    /// the PositionUpdateVLS message to the identifier of the Trade Position.
    ///
    /// When the Client checks that this is set to 1, then it knows that it can
    /// expect there potentially can be more than one Trade Position for a specific
    /// Symbol and Trade Account being reported by the PositionUpdateVLS messages.
    /// The Client can then handle this appropriately.
    fn set_uses_multiple_positions_per_symbol_and_trade_account(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(252) {
            self.uses_multiple_positions_per_symbol_and_trade_account = value;
        }
        self
    }

    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    /// Set this to 1, if the Server supports the MarketDataRequestVLS message.
    ///
    /// The default is 1.
    fn set_market_data_supported(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(253) {
            self.market_data_supported = value;
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    #[test]
    pub(crate) fn layout() {
        unsafe {
            assert_eq!(
                256usize,
                core::mem::size_of::<LogonResponseFixedData>(),
                "LogonResponseFixedData sizeof expected {:} but was {:}",
                256usize,
                core::mem::size_of::<LogonResponseFixedData>()
            );
            assert_eq!(
                256u16,
                LogonResponseFixed::new().size(),
                "LogonResponseFixed sizeof expected {:} but was {:}",
                256u16,
                LogonResponseFixed::new().size(),
            );
            assert_eq!(
                LOGON_RESPONSE,
                LogonResponseFixed::new().r#type(),
                "LogonResponseFixed type expected {:} but was {:}",
                LOGON_RESPONSE,
                LogonResponseFixed::new().r#type(),
            );
            assert_eq!(
                2u16,
                LogonResponseFixed::new().r#type(),
                "LogonResponseFixed type expected {:} but was {:}",
                2u16,
                LogonResponseFixed::new().r#type(),
            );
            let d = LogonResponseFixedData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.protocol_version) as usize) - p,
                "protocol_version offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.protocol_version) as usize) - p,
            );
            assert_eq!(
                8usize,
                (core::ptr::addr_of!(d.result) as usize) - p,
                "result offset expected {:} but was {:}",
                8usize,
                (core::ptr::addr_of!(d.result) as usize) - p,
            );
            assert_eq!(
                12usize,
                (core::ptr::addr_of!(d.result_text) as usize) - p,
                "result_text offset expected {:} but was {:}",
                12usize,
                (core::ptr::addr_of!(d.result_text) as usize) - p,
            );
            assert_eq!(
                108usize,
                (core::ptr::addr_of!(d.reconnect_address) as usize) - p,
                "reconnect_address offset expected {:} but was {:}",
                108usize,
                (core::ptr::addr_of!(d.reconnect_address) as usize) - p,
            );
            assert_eq!(
                172usize,
                (core::ptr::addr_of!(d.integer1) as usize) - p,
                "integer1 offset expected {:} but was {:}",
                172usize,
                (core::ptr::addr_of!(d.integer1) as usize) - p,
            );
            assert_eq!(
                176usize,
                (core::ptr::addr_of!(d.server_name) as usize) - p,
                "server_name offset expected {:} but was {:}",
                176usize,
                (core::ptr::addr_of!(d.server_name) as usize) - p,
            );
            assert_eq!(
                236usize,
                (core::ptr::addr_of!(d.market_depth_updates_best_bid_and_ask) as usize) - p,
                "market_depth_updates_best_bid_and_ask offset expected {:} but was {:}",
                236usize,
                (core::ptr::addr_of!(d.market_depth_updates_best_bid_and_ask) as usize) - p,
            );
            assert_eq!(
                237usize,
                (core::ptr::addr_of!(d.trading_is_supported) as usize) - p,
                "trading_is_supported offset expected {:} but was {:}",
                237usize,
                (core::ptr::addr_of!(d.trading_is_supported) as usize) - p,
            );
            assert_eq!(
                238usize,
                (core::ptr::addr_of!(d.oco_orders_supported) as usize) - p,
                "oco_orders_supported offset expected {:} but was {:}",
                238usize,
                (core::ptr::addr_of!(d.oco_orders_supported) as usize) - p,
            );
            assert_eq!(
                239usize,
                (core::ptr::addr_of!(d.order_cancel_replace_supported) as usize) - p,
                "order_cancel_replace_supported offset expected {:} but was {:}",
                239usize,
                (core::ptr::addr_of!(d.order_cancel_replace_supported) as usize) - p,
            );
            assert_eq!(
                240usize,
                (core::ptr::addr_of!(d.symbol_exchange_delimiter) as usize) - p,
                "symbol_exchange_delimiter offset expected {:} but was {:}",
                240usize,
                (core::ptr::addr_of!(d.symbol_exchange_delimiter) as usize) - p,
            );
            assert_eq!(
                244usize,
                (core::ptr::addr_of!(d.security_definitions_supported) as usize) - p,
                "security_definitions_supported offset expected {:} but was {:}",
                244usize,
                (core::ptr::addr_of!(d.security_definitions_supported) as usize) - p,
            );
            assert_eq!(
                245usize,
                (core::ptr::addr_of!(d.historical_price_data_supported) as usize) - p,
                "historical_price_data_supported offset expected {:} but was {:}",
                245usize,
                (core::ptr::addr_of!(d.historical_price_data_supported) as usize) - p,
            );
            assert_eq!(
                246usize,
                (core::ptr::addr_of!(d.resubscribe_when_market_data_feed_available) as usize) - p,
                "resubscribe_when_market_data_feed_available offset expected {:} but was {:}",
                246usize,
                (core::ptr::addr_of!(d.resubscribe_when_market_data_feed_available) as usize) - p,
            );
            assert_eq!(
                247usize,
                (core::ptr::addr_of!(d.market_depth_is_supported) as usize) - p,
                "market_depth_is_supported offset expected {:} but was {:}",
                247usize,
                (core::ptr::addr_of!(d.market_depth_is_supported) as usize) - p,
            );
            assert_eq!(
                248usize,
                (core::ptr::addr_of!(d.one_historical_price_data_request_per_connection) as usize)
                    - p,
                "one_historical_price_data_request_per_connection offset expected {:} but was {:}",
                248usize,
                (core::ptr::addr_of!(d.one_historical_price_data_request_per_connection) as usize)
                    - p,
            );
            assert_eq!(
                249usize,
                (core::ptr::addr_of!(d.bracket_orders_supported) as usize) - p,
                "bracket_orders_supported offset expected {:} but was {:}",
                249usize,
                (core::ptr::addr_of!(d.bracket_orders_supported) as usize) - p,
            );
            assert_eq!(
                250usize,
                (core::ptr::addr_of!(d.unused1) as usize) - p,
                "unused1 offset expected {:} but was {:}",
                250usize,
                (core::ptr::addr_of!(d.unused1) as usize) - p,
            );
            assert_eq!(
                251usize,
                (core::ptr::addr_of!(d.uses_multiple_positions_per_symbol_and_trade_account) as usize) - p,
                "uses_multiple_positions_per_symbol_and_trade_account offset expected {:} but was {:}",
                251usize,
                (core::ptr::addr_of!(d.uses_multiple_positions_per_symbol_and_trade_account) as usize) - p,
            );
            assert_eq!(
                252usize,
                (core::ptr::addr_of!(d.market_data_supported) as usize) - p,
                "market_data_supported offset expected {:} but was {:}",
                252usize,
                (core::ptr::addr_of!(d.market_data_supported) as usize) - p,
            );
        }
        unsafe {
            assert_eq!(
                52usize,
                core::mem::size_of::<LogonResponseVLSData>(),
                "LogonResponseVLSData sizeof expected {:} but was {:}",
                52usize,
                core::mem::size_of::<LogonResponseVLSData>()
            );
            assert_eq!(
                52u16,
                LogonResponseVLS::new().size(),
                "LogonResponseVLS sizeof expected {:} but was {:}",
                52u16,
                LogonResponseVLS::new().size(),
            );
            assert_eq!(
                LOGON_RESPONSE,
                LogonResponseVLS::new().r#type(),
                "LogonResponseVLS type expected {:} but was {:}",
                LOGON_RESPONSE,
                LogonResponseVLS::new().r#type(),
            );
            assert_eq!(
                2u16,
                LogonResponseVLS::new().r#type(),
                "LogonResponseVLS type expected {:} but was {:}",
                2u16,
                LogonResponseVLS::new().r#type(),
            );
            let d = LogonResponseVLSData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
                "base_size offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
            );
            assert_eq!(
                8usize,
                (core::ptr::addr_of!(d.protocol_version) as usize) - p,
                "protocol_version offset expected {:} but was {:}",
                8usize,
                (core::ptr::addr_of!(d.protocol_version) as usize) - p,
            );
            assert_eq!(
                12usize,
                (core::ptr::addr_of!(d.result) as usize) - p,
                "result offset expected {:} but was {:}",
                12usize,
                (core::ptr::addr_of!(d.result) as usize) - p,
            );
            assert_eq!(
                16usize,
                (core::ptr::addr_of!(d.result_text) as usize) - p,
                "result_text offset expected {:} but was {:}",
                16usize,
                (core::ptr::addr_of!(d.result_text) as usize) - p,
            );
            assert_eq!(
                20usize,
                (core::ptr::addr_of!(d.reconnect_address) as usize) - p,
                "reconnect_address offset expected {:} but was {:}",
                20usize,
                (core::ptr::addr_of!(d.reconnect_address) as usize) - p,
            );
            assert_eq!(
                24usize,
                (core::ptr::addr_of!(d.integer1) as usize) - p,
                "integer1 offset expected {:} but was {:}",
                24usize,
                (core::ptr::addr_of!(d.integer1) as usize) - p,
            );
            assert_eq!(
                28usize,
                (core::ptr::addr_of!(d.server_name) as usize) - p,
                "server_name offset expected {:} but was {:}",
                28usize,
                (core::ptr::addr_of!(d.server_name) as usize) - p,
            );
            assert_eq!(
                32usize,
                (core::ptr::addr_of!(d.market_depth_updates_best_bid_and_ask) as usize) - p,
                "market_depth_updates_best_bid_and_ask offset expected {:} but was {:}",
                32usize,
                (core::ptr::addr_of!(d.market_depth_updates_best_bid_and_ask) as usize) - p,
            );
            assert_eq!(
                33usize,
                (core::ptr::addr_of!(d.trading_is_supported) as usize) - p,
                "trading_is_supported offset expected {:} but was {:}",
                33usize,
                (core::ptr::addr_of!(d.trading_is_supported) as usize) - p,
            );
            assert_eq!(
                34usize,
                (core::ptr::addr_of!(d.oco_orders_supported) as usize) - p,
                "oco_orders_supported offset expected {:} but was {:}",
                34usize,
                (core::ptr::addr_of!(d.oco_orders_supported) as usize) - p,
            );
            assert_eq!(
                35usize,
                (core::ptr::addr_of!(d.order_cancel_replace_supported) as usize) - p,
                "order_cancel_replace_supported offset expected {:} but was {:}",
                35usize,
                (core::ptr::addr_of!(d.order_cancel_replace_supported) as usize) - p,
            );
            assert_eq!(
                36usize,
                (core::ptr::addr_of!(d.symbol_exchange_delimiter) as usize) - p,
                "symbol_exchange_delimiter offset expected {:} but was {:}",
                36usize,
                (core::ptr::addr_of!(d.symbol_exchange_delimiter) as usize) - p,
            );
            assert_eq!(
                40usize,
                (core::ptr::addr_of!(d.security_definitions_supported) as usize) - p,
                "security_definitions_supported offset expected {:} but was {:}",
                40usize,
                (core::ptr::addr_of!(d.security_definitions_supported) as usize) - p,
            );
            assert_eq!(
                41usize,
                (core::ptr::addr_of!(d.historical_price_data_supported) as usize) - p,
                "historical_price_data_supported offset expected {:} but was {:}",
                41usize,
                (core::ptr::addr_of!(d.historical_price_data_supported) as usize) - p,
            );
            assert_eq!(
                42usize,
                (core::ptr::addr_of!(d.resubscribe_when_market_data_feed_available) as usize) - p,
                "resubscribe_when_market_data_feed_available offset expected {:} but was {:}",
                42usize,
                (core::ptr::addr_of!(d.resubscribe_when_market_data_feed_available) as usize) - p,
            );
            assert_eq!(
                43usize,
                (core::ptr::addr_of!(d.market_depth_is_supported) as usize) - p,
                "market_depth_is_supported offset expected {:} but was {:}",
                43usize,
                (core::ptr::addr_of!(d.market_depth_is_supported) as usize) - p,
            );
            assert_eq!(
                44usize,
                (core::ptr::addr_of!(d.one_historical_price_data_request_per_connection) as usize)
                    - p,
                "one_historical_price_data_request_per_connection offset expected {:} but was {:}",
                44usize,
                (core::ptr::addr_of!(d.one_historical_price_data_request_per_connection) as usize)
                    - p,
            );
            assert_eq!(
                45usize,
                (core::ptr::addr_of!(d.bracket_orders_supported) as usize) - p,
                "bracket_orders_supported offset expected {:} but was {:}",
                45usize,
                (core::ptr::addr_of!(d.bracket_orders_supported) as usize) - p,
            );
            assert_eq!(
                46usize,
                (core::ptr::addr_of!(d.unused1) as usize) - p,
                "unused1 offset expected {:} but was {:}",
                46usize,
                (core::ptr::addr_of!(d.unused1) as usize) - p,
            );
            assert_eq!(
                47usize,
                (core::ptr::addr_of!(d.uses_multiple_positions_per_symbol_and_trade_account) as usize) - p,
                "uses_multiple_positions_per_symbol_and_trade_account offset expected {:} but was {:}",
                47usize,
                (core::ptr::addr_of!(d.uses_multiple_positions_per_symbol_and_trade_account) as usize) - p,
            );
            assert_eq!(
                48usize,
                (core::ptr::addr_of!(d.market_data_supported) as usize) - p,
                "market_data_supported offset expected {:} but was {:}",
                48usize,
                (core::ptr::addr_of!(d.market_data_supported) as usize) - p,
            );
        }
    }
}
