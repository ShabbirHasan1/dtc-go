// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-27 08:32:53.747629 +0800 WITA m=+0.008238335
use super::*;

pub(crate) const TRADE_POSITION_CONSOLIDATED_VLS_SIZE: usize = 161;

/// size                                         u16     = TradePositionConsolidatedVLSSize  (161)
/// type                                         u16     = TRADE_POSITION_CONSOLIDATED  (10113)
/// base_size                                    u16     = TradePositionConsolidatedVLSSize  (161)
/// is_deleted                                   bool    = false
/// symbol                                       string  = ""
/// is_simulated                                 bool    = false
/// trade_account                                string  = ""
/// currency_code                                string  = ""
/// quantity                                     f64     = 0
/// average_price                                f64     = 0
/// open_profit_loss                             f64     = 0
/// daily_profit_loss                            f64     = 0
/// last_daily_profit_loss_reset_date_time_utc   i64     = 0
/// service_position_quantity                    f64     = 0
/// position_has_been_updated_by_service         u8      = 0
/// price_high_during_position                   f64     = 0
/// price_low_during_position                    f64     = 0
/// price_last_during_position                   f64     = 0
/// last_processed_time_and_sales_sequence       i64     = 0
/// total_margin_requirement                     f64     = 0.000000
/// initial_entry_date_time_utc                  i64     = 0
/// is_from_dtc_server_replay                    bool    = false
/// most_recent_position_increase_date_time_utc  i64     = 0
/// is_snapshot                                  bool    = false
/// is_first_message_in_batch                    bool    = false
/// is_last_message_in_batch                     bool    = false
/// margin_requirement_full                      f64     = 0
/// margin_requirement_full_positions_only       f64     = 0
/// max_potential_position_quantity              f64     = 0
/// quantity_at_end_of_day_capture_time          f64     = 0
pub(crate) const TRADE_POSITION_CONSOLIDATED_VLS_DEFAULT: [u8; 161] = [
    161, 0, 129, 39, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0,
];

pub trait TradePositionConsolidated: Message {
    type Safe: TradePositionConsolidated;
    type Unsafe: TradePositionConsolidated;

    fn is_deleted(&self) -> bool;

    fn symbol(&self) -> &str;

    fn is_simulated(&self) -> bool;

    fn trade_account(&self) -> &str;

    fn currency_code(&self) -> &str;

    fn quantity(&self) -> f64;

    fn average_price(&self) -> f64;

    fn open_profit_loss(&self) -> f64;

    fn daily_profit_loss(&self) -> f64;

    fn last_daily_profit_loss_reset_date_time_utc(&self) -> i64;

    fn service_position_quantity(&self) -> f64;

    fn position_has_been_updated_by_service(&self) -> u8;

    fn price_high_during_position(&self) -> f64;

    fn price_low_during_position(&self) -> f64;

    fn price_last_during_position(&self) -> f64;

    fn last_processed_time_and_sales_sequence(&self) -> i64;

    fn total_margin_requirement(&self) -> f64;

    fn initial_entry_date_time_utc(&self) -> i64;

    fn is_from_dtc_server_replay(&self) -> bool;

    fn most_recent_position_increase_date_time_utc(&self) -> i64;

    fn is_snapshot(&self) -> bool;

    fn is_first_message_in_batch(&self) -> bool;

    fn is_last_message_in_batch(&self) -> bool;

    fn margin_requirement_full(&self) -> f64;

    fn margin_requirement_full_positions_only(&self) -> f64;

    fn max_potential_position_quantity(&self) -> f64;

    fn quantity_at_end_of_day_capture_time(&self) -> f64;

    fn set_is_deleted(&mut self, value: bool) -> &mut Self;

    fn set_symbol(&mut self, value: &str) -> &mut Self;

    fn set_is_simulated(&mut self, value: bool) -> &mut Self;

    fn set_trade_account(&mut self, value: &str) -> &mut Self;

    fn set_currency_code(&mut self, value: &str) -> &mut Self;

    fn set_quantity(&mut self, value: f64) -> &mut Self;

    fn set_average_price(&mut self, value: f64) -> &mut Self;

    fn set_open_profit_loss(&mut self, value: f64) -> &mut Self;

    fn set_daily_profit_loss(&mut self, value: f64) -> &mut Self;

    fn set_last_daily_profit_loss_reset_date_time_utc(&mut self, value: i64) -> &mut Self;

    fn set_service_position_quantity(&mut self, value: f64) -> &mut Self;

    fn set_position_has_been_updated_by_service(&mut self, value: u8) -> &mut Self;

    fn set_price_high_during_position(&mut self, value: f64) -> &mut Self;

    fn set_price_low_during_position(&mut self, value: f64) -> &mut Self;

    fn set_price_last_during_position(&mut self, value: f64) -> &mut Self;

    fn set_last_processed_time_and_sales_sequence(&mut self, value: i64) -> &mut Self;

    fn set_total_margin_requirement(&mut self, value: f64) -> &mut Self;

    fn set_initial_entry_date_time_utc(&mut self, value: i64) -> &mut Self;

    fn set_is_from_dtc_server_replay(&mut self, value: bool) -> &mut Self;

    fn set_most_recent_position_increase_date_time_utc(&mut self, value: i64) -> &mut Self;

    fn set_is_snapshot(&mut self, value: bool) -> &mut Self;

    fn set_is_first_message_in_batch(&mut self, value: bool) -> &mut Self;

    fn set_is_last_message_in_batch(&mut self, value: bool) -> &mut Self;

    fn set_margin_requirement_full(&mut self, value: f64) -> &mut Self;

    fn set_margin_requirement_full_positions_only(&mut self, value: f64) -> &mut Self;

    fn set_max_potential_position_quantity(&mut self, value: f64) -> &mut Self;

    fn set_quantity_at_end_of_day_capture_time(&mut self, value: f64) -> &mut Self;

    fn clone_safe(&self) -> Self::Safe;

    fn to_safe(self) -> Self::Safe;

    fn copy_to(&self, to: &mut impl TradePositionConsolidated) {
        to.set_is_deleted(self.is_deleted());
        to.set_symbol(self.symbol());
        to.set_is_simulated(self.is_simulated());
        to.set_trade_account(self.trade_account());
        to.set_currency_code(self.currency_code());
        to.set_quantity(self.quantity());
        to.set_average_price(self.average_price());
        to.set_open_profit_loss(self.open_profit_loss());
        to.set_daily_profit_loss(self.daily_profit_loss());
        to.set_last_daily_profit_loss_reset_date_time_utc(
            self.last_daily_profit_loss_reset_date_time_utc(),
        );
        to.set_service_position_quantity(self.service_position_quantity());
        to.set_position_has_been_updated_by_service(self.position_has_been_updated_by_service());
        to.set_price_high_during_position(self.price_high_during_position());
        to.set_price_low_during_position(self.price_low_during_position());
        to.set_price_last_during_position(self.price_last_during_position());
        to.set_last_processed_time_and_sales_sequence(
            self.last_processed_time_and_sales_sequence(),
        );
        to.set_total_margin_requirement(self.total_margin_requirement());
        to.set_initial_entry_date_time_utc(self.initial_entry_date_time_utc());
        to.set_is_from_dtc_server_replay(self.is_from_dtc_server_replay());
        to.set_most_recent_position_increase_date_time_utc(
            self.most_recent_position_increase_date_time_utc(),
        );
        to.set_is_snapshot(self.is_snapshot());
        to.set_is_first_message_in_batch(self.is_first_message_in_batch());
        to.set_is_last_message_in_batch(self.is_last_message_in_batch());
        to.set_margin_requirement_full(self.margin_requirement_full());
        to.set_margin_requirement_full_positions_only(
            self.margin_requirement_full_positions_only(),
        );
        to.set_max_potential_position_quantity(self.max_potential_position_quantity());
        to.set_quantity_at_end_of_day_capture_time(self.quantity_at_end_of_day_capture_time());
    }

    #[inline]
    fn parse<F: Fn(Parsed<Self::Safe, Self::Unsafe>) -> Result<(), crate::Error>>(
        data: &[u8],
        f: F,
    ) -> Result<(), crate::Error> {
        if data.len() < 6 {
            return Err(crate::Error::Malformed("need more data"));
        }
        let size = unsafe { u16::from_le(*(data.as_ptr() as *const u16)) };
        let base_size = if Self::BASE_SIZE_OFFSET == 0 {
            size
        } else {
            let base_size = unsafe {
                u16::from_le(*(data.as_ptr().offset(Self::BASE_SIZE_OFFSET) as *const u16))
            };
            if base_size > size {
                return Err(crate::Error::Malformed("base_size is greater than size"));
            }
            base_size
        };
        if (base_size as usize) >= Self::BASE_SIZE {
            let msg = unsafe { Self::Safe::from_raw_parts(data.as_ptr(), size as usize) };
            let r = f(Parsed::Safe(&msg));
            core::mem::forget(msg);
            r
        } else {
            let msg = unsafe { Self::Unsafe::from_raw_parts(data.as_ptr(), size as usize) };
            let r = f(Parsed::Unsafe(&msg));
            core::mem::forget(msg);
            r
        }
    }
}

pub struct TradePositionConsolidatedVLS {
    data: *const TradePositionConsolidatedVLSData,
    capacity: usize,
}

pub struct TradePositionConsolidatedVLSUnsafe {
    data: *const TradePositionConsolidatedVLSData,
    capacity: usize,
}

#[repr(packed(1), C)]
pub struct TradePositionConsolidatedVLSData {
    size: u16,
    r#type: u16,
    base_size: u16,
    is_deleted: bool,
    symbol: VLS,
    is_simulated: bool,
    trade_account: VLS,
    currency_code: VLS,
    quantity: f64,
    average_price: f64,
    open_profit_loss: f64,
    daily_profit_loss: f64,
    last_daily_profit_loss_reset_date_time_utc: i64,
    service_position_quantity: f64,
    position_has_been_updated_by_service: u8,
    price_high_during_position: f64,
    price_low_during_position: f64,
    price_last_during_position: f64,
    last_processed_time_and_sales_sequence: i64,
    total_margin_requirement: f64,
    initial_entry_date_time_utc: i64,
    is_from_dtc_server_replay: bool,
    most_recent_position_increase_date_time_utc: i64,
    is_snapshot: bool,
    is_first_message_in_batch: bool,
    is_last_message_in_batch: bool,
    margin_requirement_full: f64,
    margin_requirement_full_positions_only: f64,
    max_potential_position_quantity: f64,
    quantity_at_end_of_day_capture_time: f64,
}

impl TradePositionConsolidatedVLSData {
    pub fn new() -> Self {
        Self {
            size: 161u16.to_le(),
            r#type: TRADE_POSITION_CONSOLIDATED.to_le(),
            base_size: 161u16.to_le(),
            is_deleted: false,
            symbol: crate::message::VLS::new(),
            is_simulated: false,
            trade_account: crate::message::VLS::new(),
            currency_code: crate::message::VLS::new(),
            quantity: 0.0f64,
            average_price: 0.0,
            open_profit_loss: 0.0,
            daily_profit_loss: 0.0,
            last_daily_profit_loss_reset_date_time_utc: 0i64.to_le(),
            service_position_quantity: 0.0,
            position_has_been_updated_by_service: 0,
            price_high_during_position: 0.0,
            price_low_during_position: 0.0,
            price_last_during_position: 0.0,
            last_processed_time_and_sales_sequence: 0i64.to_le(),
            total_margin_requirement: 0.0,
            initial_entry_date_time_utc: 0i64.to_le(),
            is_from_dtc_server_replay: false,
            most_recent_position_increase_date_time_utc: 0i64.to_le(),
            is_snapshot: false,
            is_first_message_in_batch: false,
            is_last_message_in_batch: false,
            margin_requirement_full: 0.0,
            margin_requirement_full_positions_only: 0.0,
            max_potential_position_quantity: 0.0,
            quantity_at_end_of_day_capture_time: 0.0,
        }
    }
}

unsafe impl Send for TradePositionConsolidatedVLS {}
unsafe impl Send for TradePositionConsolidatedVLSUnsafe {}
unsafe impl Send for TradePositionConsolidatedVLSData {}

impl Drop for TradePositionConsolidatedVLS {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for TradePositionConsolidatedVLSUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Clone for TradePositionConsolidatedVLS {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for TradePositionConsolidatedVLSUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Into<Vec<u8>> for TradePositionConsolidatedVLS {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for TradePositionConsolidatedVLSUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl core::ops::Deref for TradePositionConsolidatedVLS {
    type Target = TradePositionConsolidatedVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for TradePositionConsolidatedVLS {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for TradePositionConsolidatedVLSUnsafe {
    type Target = TradePositionConsolidatedVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for TradePositionConsolidatedVLSUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::fmt::Display for TradePositionConsolidatedVLS {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(format!("TradePositionConsolidatedVLS(size: {}, type: {}, base_size: {}, is_deleted: {}, symbol: \"{}\", is_simulated: {}, trade_account: \"{}\", currency_code: \"{}\", quantity: {}, average_price: {}, open_profit_loss: {}, daily_profit_loss: {}, last_daily_profit_loss_reset_date_time_utc: {}, service_position_quantity: {}, position_has_been_updated_by_service: {}, price_high_during_position: {}, price_low_during_position: {}, price_last_during_position: {}, last_processed_time_and_sales_sequence: {}, total_margin_requirement: {}, initial_entry_date_time_utc: {}, is_from_dtc_server_replay: {}, most_recent_position_increase_date_time_utc: {}, is_snapshot: {}, is_first_message_in_batch: {}, is_last_message_in_batch: {}, margin_requirement_full: {}, margin_requirement_full_positions_only: {}, max_potential_position_quantity: {}, quantity_at_end_of_day_capture_time: {})", self.size(), self.r#type(), self.base_size(), self.is_deleted(), self.symbol(), self.is_simulated(), self.trade_account(), self.currency_code(), self.quantity(), self.average_price(), self.open_profit_loss(), self.daily_profit_loss(), self.last_daily_profit_loss_reset_date_time_utc(), self.service_position_quantity(), self.position_has_been_updated_by_service(), self.price_high_during_position(), self.price_low_during_position(), self.price_last_during_position(), self.last_processed_time_and_sales_sequence(), self.total_margin_requirement(), self.initial_entry_date_time_utc(), self.is_from_dtc_server_replay(), self.most_recent_position_increase_date_time_utc(), self.is_snapshot(), self.is_first_message_in_batch(), self.is_last_message_in_batch(), self.margin_requirement_full(), self.margin_requirement_full_positions_only(), self.max_potential_position_quantity(), self.quantity_at_end_of_day_capture_time()).as_str())
    }
}

impl core::fmt::Debug for TradePositionConsolidatedVLS {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(format!("TradePositionConsolidatedVLS(size: {}, type: {}, base_size: {}, is_deleted: {}, symbol: \"{}\", is_simulated: {}, trade_account: \"{}\", currency_code: \"{}\", quantity: {}, average_price: {}, open_profit_loss: {}, daily_profit_loss: {}, last_daily_profit_loss_reset_date_time_utc: {}, service_position_quantity: {}, position_has_been_updated_by_service: {}, price_high_during_position: {}, price_low_during_position: {}, price_last_during_position: {}, last_processed_time_and_sales_sequence: {}, total_margin_requirement: {}, initial_entry_date_time_utc: {}, is_from_dtc_server_replay: {}, most_recent_position_increase_date_time_utc: {}, is_snapshot: {}, is_first_message_in_batch: {}, is_last_message_in_batch: {}, margin_requirement_full: {}, margin_requirement_full_positions_only: {}, max_potential_position_quantity: {}, quantity_at_end_of_day_capture_time: {})", self.size(), self.r#type(), self.base_size(), self.is_deleted(), self.symbol(), self.is_simulated(), self.trade_account(), self.currency_code(), self.quantity(), self.average_price(), self.open_profit_loss(), self.daily_profit_loss(), self.last_daily_profit_loss_reset_date_time_utc(), self.service_position_quantity(), self.position_has_been_updated_by_service(), self.price_high_during_position(), self.price_low_during_position(), self.price_last_during_position(), self.last_processed_time_and_sales_sequence(), self.total_margin_requirement(), self.initial_entry_date_time_utc(), self.is_from_dtc_server_replay(), self.most_recent_position_increase_date_time_utc(), self.is_snapshot(), self.is_first_message_in_batch(), self.is_last_message_in_batch(), self.margin_requirement_full(), self.margin_requirement_full_positions_only(), self.max_potential_position_quantity(), self.quantity_at_end_of_day_capture_time()).as_str())
    }
}

impl core::fmt::Display for TradePositionConsolidatedVLSUnsafe {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(format!("TradePositionConsolidatedVLSUnsafe(size: {}, type: {}, base_size: {}, is_deleted: {}, symbol: \"{}\", is_simulated: {}, trade_account: \"{}\", currency_code: \"{}\", quantity: {}, average_price: {}, open_profit_loss: {}, daily_profit_loss: {}, last_daily_profit_loss_reset_date_time_utc: {}, service_position_quantity: {}, position_has_been_updated_by_service: {}, price_high_during_position: {}, price_low_during_position: {}, price_last_during_position: {}, last_processed_time_and_sales_sequence: {}, total_margin_requirement: {}, initial_entry_date_time_utc: {}, is_from_dtc_server_replay: {}, most_recent_position_increase_date_time_utc: {}, is_snapshot: {}, is_first_message_in_batch: {}, is_last_message_in_batch: {}, margin_requirement_full: {}, margin_requirement_full_positions_only: {}, max_potential_position_quantity: {}, quantity_at_end_of_day_capture_time: {})", self.size(), self.r#type(), self.base_size(), self.is_deleted(), self.symbol(), self.is_simulated(), self.trade_account(), self.currency_code(), self.quantity(), self.average_price(), self.open_profit_loss(), self.daily_profit_loss(), self.last_daily_profit_loss_reset_date_time_utc(), self.service_position_quantity(), self.position_has_been_updated_by_service(), self.price_high_during_position(), self.price_low_during_position(), self.price_last_during_position(), self.last_processed_time_and_sales_sequence(), self.total_margin_requirement(), self.initial_entry_date_time_utc(), self.is_from_dtc_server_replay(), self.most_recent_position_increase_date_time_utc(), self.is_snapshot(), self.is_first_message_in_batch(), self.is_last_message_in_batch(), self.margin_requirement_full(), self.margin_requirement_full_positions_only(), self.max_potential_position_quantity(), self.quantity_at_end_of_day_capture_time()).as_str())
    }
}

impl core::fmt::Debug for TradePositionConsolidatedVLSUnsafe {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(format!("TradePositionConsolidatedVLSUnsafe(size: {}, type: {}, base_size: {}, is_deleted: {}, symbol: \"{}\", is_simulated: {}, trade_account: \"{}\", currency_code: \"{}\", quantity: {}, average_price: {}, open_profit_loss: {}, daily_profit_loss: {}, last_daily_profit_loss_reset_date_time_utc: {}, service_position_quantity: {}, position_has_been_updated_by_service: {}, price_high_during_position: {}, price_low_during_position: {}, price_last_during_position: {}, last_processed_time_and_sales_sequence: {}, total_margin_requirement: {}, initial_entry_date_time_utc: {}, is_from_dtc_server_replay: {}, most_recent_position_increase_date_time_utc: {}, is_snapshot: {}, is_first_message_in_batch: {}, is_last_message_in_batch: {}, margin_requirement_full: {}, margin_requirement_full_positions_only: {}, max_potential_position_quantity: {}, quantity_at_end_of_day_capture_time: {})", self.size(), self.r#type(), self.base_size(), self.is_deleted(), self.symbol(), self.is_simulated(), self.trade_account(), self.currency_code(), self.quantity(), self.average_price(), self.open_profit_loss(), self.daily_profit_loss(), self.last_daily_profit_loss_reset_date_time_utc(), self.service_position_quantity(), self.position_has_been_updated_by_service(), self.price_high_during_position(), self.price_low_during_position(), self.price_last_during_position(), self.last_processed_time_and_sales_sequence(), self.total_margin_requirement(), self.initial_entry_date_time_utc(), self.is_from_dtc_server_replay(), self.most_recent_position_increase_date_time_utc(), self.is_snapshot(), self.is_first_message_in_batch(), self.is_last_message_in_batch(), self.margin_requirement_full(), self.margin_requirement_full_positions_only(), self.max_potential_position_quantity(), self.quantity_at_end_of_day_capture_time()).as_str())
    }
}

impl crate::Message for TradePositionConsolidatedVLS {
    type Data = TradePositionConsolidatedVLSData;

    const TYPE: u16 = TRADE_POSITION_CONSOLIDATED;
    const BASE_SIZE: usize = 161;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, TradePositionConsolidatedVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const TradePositionConsolidatedVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for TradePositionConsolidatedVLS {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const TradePositionConsolidatedVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl crate::Message for TradePositionConsolidatedVLSUnsafe {
    type Data = TradePositionConsolidatedVLSData;

    const TYPE: u16 = TRADE_POSITION_CONSOLIDATED;
    const BASE_SIZE: usize = 161;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, TradePositionConsolidatedVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const TradePositionConsolidatedVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for TradePositionConsolidatedVLSUnsafe {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const TradePositionConsolidatedVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl TradePositionConsolidated for TradePositionConsolidatedVLS {
    type Safe = TradePositionConsolidatedVLS;
    type Unsafe = TradePositionConsolidatedVLSUnsafe;

    fn is_deleted(&self) -> bool {
        self.is_deleted
    }

    fn symbol(&self) -> &str {
        get_vls(self, self.symbol)
    }

    fn is_simulated(&self) -> bool {
        self.is_simulated
    }

    fn trade_account(&self) -> &str {
        get_vls(self, self.trade_account)
    }

    fn currency_code(&self) -> &str {
        get_vls(self, self.currency_code)
    }

    fn quantity(&self) -> f64 {
        f64_le(self.quantity)
    }

    fn average_price(&self) -> f64 {
        f64_le(self.average_price)
    }

    fn open_profit_loss(&self) -> f64 {
        f64_le(self.open_profit_loss)
    }

    fn daily_profit_loss(&self) -> f64 {
        f64_le(self.daily_profit_loss)
    }

    fn last_daily_profit_loss_reset_date_time_utc(&self) -> i64 {
        i64::from_le(self.last_daily_profit_loss_reset_date_time_utc)
    }

    fn service_position_quantity(&self) -> f64 {
        f64_le(self.service_position_quantity)
    }

    fn position_has_been_updated_by_service(&self) -> u8 {
        self.position_has_been_updated_by_service
    }

    fn price_high_during_position(&self) -> f64 {
        f64_le(self.price_high_during_position)
    }

    fn price_low_during_position(&self) -> f64 {
        f64_le(self.price_low_during_position)
    }

    fn price_last_during_position(&self) -> f64 {
        f64_le(self.price_last_during_position)
    }

    fn last_processed_time_and_sales_sequence(&self) -> i64 {
        i64::from_le(self.last_processed_time_and_sales_sequence)
    }

    fn total_margin_requirement(&self) -> f64 {
        f64_le(self.total_margin_requirement)
    }

    fn initial_entry_date_time_utc(&self) -> i64 {
        i64::from_le(self.initial_entry_date_time_utc)
    }

    fn is_from_dtc_server_replay(&self) -> bool {
        self.is_from_dtc_server_replay
    }

    fn most_recent_position_increase_date_time_utc(&self) -> i64 {
        i64::from_le(self.most_recent_position_increase_date_time_utc)
    }

    fn is_snapshot(&self) -> bool {
        self.is_snapshot
    }

    fn is_first_message_in_batch(&self) -> bool {
        self.is_first_message_in_batch
    }

    fn is_last_message_in_batch(&self) -> bool {
        self.is_last_message_in_batch
    }

    fn margin_requirement_full(&self) -> f64 {
        f64_le(self.margin_requirement_full)
    }

    fn margin_requirement_full_positions_only(&self) -> f64 {
        f64_le(self.margin_requirement_full_positions_only)
    }

    fn max_potential_position_quantity(&self) -> f64 {
        f64_le(self.max_potential_position_quantity)
    }

    fn quantity_at_end_of_day_capture_time(&self) -> f64 {
        f64_le(self.quantity_at_end_of_day_capture_time)
    }

    fn set_is_deleted(&mut self, value: bool) -> &mut Self {
        self.is_deleted = value;
        self
    }

    fn set_symbol(&mut self, value: &str) -> &mut Self {
        self.symbol = set_vls(self, self.symbol, value);
        self
    }

    fn set_is_simulated(&mut self, value: bool) -> &mut Self {
        self.is_simulated = value;
        self
    }

    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        self.trade_account = set_vls(self, self.trade_account, value);
        self
    }

    fn set_currency_code(&mut self, value: &str) -> &mut Self {
        self.currency_code = set_vls(self, self.currency_code, value);
        self
    }

    fn set_quantity(&mut self, value: f64) -> &mut Self {
        self.quantity = f64_le(value);
        self
    }

    fn set_average_price(&mut self, value: f64) -> &mut Self {
        self.average_price = f64_le(value);
        self
    }

    fn set_open_profit_loss(&mut self, value: f64) -> &mut Self {
        self.open_profit_loss = f64_le(value);
        self
    }

    fn set_daily_profit_loss(&mut self, value: f64) -> &mut Self {
        self.daily_profit_loss = f64_le(value);
        self
    }

    fn set_last_daily_profit_loss_reset_date_time_utc(&mut self, value: i64) -> &mut Self {
        self.last_daily_profit_loss_reset_date_time_utc = value.to_le();
        self
    }

    fn set_service_position_quantity(&mut self, value: f64) -> &mut Self {
        self.service_position_quantity = f64_le(value);
        self
    }

    fn set_position_has_been_updated_by_service(&mut self, value: u8) -> &mut Self {
        self.position_has_been_updated_by_service = value;
        self
    }

    fn set_price_high_during_position(&mut self, value: f64) -> &mut Self {
        self.price_high_during_position = f64_le(value);
        self
    }

    fn set_price_low_during_position(&mut self, value: f64) -> &mut Self {
        self.price_low_during_position = f64_le(value);
        self
    }

    fn set_price_last_during_position(&mut self, value: f64) -> &mut Self {
        self.price_last_during_position = f64_le(value);
        self
    }

    fn set_last_processed_time_and_sales_sequence(&mut self, value: i64) -> &mut Self {
        self.last_processed_time_and_sales_sequence = value.to_le();
        self
    }

    fn set_total_margin_requirement(&mut self, value: f64) -> &mut Self {
        self.total_margin_requirement = f64_le(value);
        self
    }

    fn set_initial_entry_date_time_utc(&mut self, value: i64) -> &mut Self {
        self.initial_entry_date_time_utc = value.to_le();
        self
    }

    fn set_is_from_dtc_server_replay(&mut self, value: bool) -> &mut Self {
        self.is_from_dtc_server_replay = value;
        self
    }

    fn set_most_recent_position_increase_date_time_utc(&mut self, value: i64) -> &mut Self {
        self.most_recent_position_increase_date_time_utc = value.to_le();
        self
    }

    fn set_is_snapshot(&mut self, value: bool) -> &mut Self {
        self.is_snapshot = value;
        self
    }

    fn set_is_first_message_in_batch(&mut self, value: bool) -> &mut Self {
        self.is_first_message_in_batch = value;
        self
    }

    fn set_is_last_message_in_batch(&mut self, value: bool) -> &mut Self {
        self.is_last_message_in_batch = value;
        self
    }

    fn set_margin_requirement_full(&mut self, value: f64) -> &mut Self {
        self.margin_requirement_full = f64_le(value);
        self
    }

    fn set_margin_requirement_full_positions_only(&mut self, value: f64) -> &mut Self {
        self.margin_requirement_full_positions_only = f64_le(value);
        self
    }

    fn set_max_potential_position_quantity(&mut self, value: f64) -> &mut Self {
        self.max_potential_position_quantity = f64_le(value);
        self
    }

    fn set_quantity_at_end_of_day_capture_time(&mut self, value: f64) -> &mut Self {
        self.quantity_at_end_of_day_capture_time = f64_le(value);
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

impl TradePositionConsolidated for TradePositionConsolidatedVLSUnsafe {
    type Safe = TradePositionConsolidatedVLS;
    type Unsafe = TradePositionConsolidatedVLSUnsafe;

    fn is_deleted(&self) -> bool {
        if self.is_out_of_bounds(7) {
            false
        } else {
            self.is_deleted
        }
    }

    fn symbol(&self) -> &str {
        if self.is_out_of_bounds(11) {
            ""
        } else {
            get_vls(self, self.symbol)
        }
    }

    fn is_simulated(&self) -> bool {
        if self.is_out_of_bounds(12) {
            false
        } else {
            self.is_simulated
        }
    }

    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(16) {
            ""
        } else {
            get_vls(self, self.trade_account)
        }
    }

    fn currency_code(&self) -> &str {
        if self.is_out_of_bounds(20) {
            ""
        } else {
            get_vls(self, self.currency_code)
        }
    }

    fn quantity(&self) -> f64 {
        if self.is_out_of_bounds(28) {
            0.0f64
        } else {
            f64_le(self.quantity)
        }
    }

    fn average_price(&self) -> f64 {
        if self.is_out_of_bounds(36) {
            0.0
        } else {
            f64_le(self.average_price)
        }
    }

    fn open_profit_loss(&self) -> f64 {
        if self.is_out_of_bounds(44) {
            0.0
        } else {
            f64_le(self.open_profit_loss)
        }
    }

    fn daily_profit_loss(&self) -> f64 {
        if self.is_out_of_bounds(52) {
            0.0
        } else {
            f64_le(self.daily_profit_loss)
        }
    }

    fn last_daily_profit_loss_reset_date_time_utc(&self) -> i64 {
        if self.is_out_of_bounds(60) {
            0i64.to_le()
        } else {
            i64::from_le(self.last_daily_profit_loss_reset_date_time_utc)
        }
    }

    fn service_position_quantity(&self) -> f64 {
        if self.is_out_of_bounds(68) {
            0.0
        } else {
            f64_le(self.service_position_quantity)
        }
    }

    fn position_has_been_updated_by_service(&self) -> u8 {
        if self.is_out_of_bounds(69) {
            0
        } else {
            self.position_has_been_updated_by_service
        }
    }

    fn price_high_during_position(&self) -> f64 {
        if self.is_out_of_bounds(77) {
            0.0
        } else {
            f64_le(self.price_high_during_position)
        }
    }

    fn price_low_during_position(&self) -> f64 {
        if self.is_out_of_bounds(85) {
            0.0
        } else {
            f64_le(self.price_low_during_position)
        }
    }

    fn price_last_during_position(&self) -> f64 {
        if self.is_out_of_bounds(93) {
            0.0
        } else {
            f64_le(self.price_last_during_position)
        }
    }

    fn last_processed_time_and_sales_sequence(&self) -> i64 {
        if self.is_out_of_bounds(101) {
            0i64.to_le()
        } else {
            i64::from_le(self.last_processed_time_and_sales_sequence)
        }
    }

    fn total_margin_requirement(&self) -> f64 {
        if self.is_out_of_bounds(109) {
            0.0
        } else {
            f64_le(self.total_margin_requirement)
        }
    }

    fn initial_entry_date_time_utc(&self) -> i64 {
        if self.is_out_of_bounds(117) {
            0i64.to_le()
        } else {
            i64::from_le(self.initial_entry_date_time_utc)
        }
    }

    fn is_from_dtc_server_replay(&self) -> bool {
        if self.is_out_of_bounds(118) {
            false
        } else {
            self.is_from_dtc_server_replay
        }
    }

    fn most_recent_position_increase_date_time_utc(&self) -> i64 {
        if self.is_out_of_bounds(126) {
            0i64.to_le()
        } else {
            i64::from_le(self.most_recent_position_increase_date_time_utc)
        }
    }

    fn is_snapshot(&self) -> bool {
        if self.is_out_of_bounds(127) {
            false
        } else {
            self.is_snapshot
        }
    }

    fn is_first_message_in_batch(&self) -> bool {
        if self.is_out_of_bounds(128) {
            false
        } else {
            self.is_first_message_in_batch
        }
    }

    fn is_last_message_in_batch(&self) -> bool {
        if self.is_out_of_bounds(129) {
            false
        } else {
            self.is_last_message_in_batch
        }
    }

    fn margin_requirement_full(&self) -> f64 {
        if self.is_out_of_bounds(137) {
            0.0
        } else {
            f64_le(self.margin_requirement_full)
        }
    }

    fn margin_requirement_full_positions_only(&self) -> f64 {
        if self.is_out_of_bounds(145) {
            0.0
        } else {
            f64_le(self.margin_requirement_full_positions_only)
        }
    }

    fn max_potential_position_quantity(&self) -> f64 {
        if self.is_out_of_bounds(153) {
            0.0
        } else {
            f64_le(self.max_potential_position_quantity)
        }
    }

    fn quantity_at_end_of_day_capture_time(&self) -> f64 {
        if self.is_out_of_bounds(161) {
            0.0
        } else {
            f64_le(self.quantity_at_end_of_day_capture_time)
        }
    }

    fn set_is_deleted(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(7) {
            self.is_deleted = value;
        }
        self
    }

    fn set_symbol(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(11) {
            self.symbol = set_vls(self, self.symbol, value);
        }
        self
    }

    fn set_is_simulated(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(12) {
            self.is_simulated = value;
        }
        self
    }

    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(16) {
            self.trade_account = set_vls(self, self.trade_account, value);
        }
        self
    }

    fn set_currency_code(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(20) {
            self.currency_code = set_vls(self, self.currency_code, value);
        }
        self
    }

    fn set_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(28) {
            self.quantity = f64_le(value);
        }
        self
    }

    fn set_average_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(36) {
            self.average_price = f64_le(value);
        }
        self
    }

    fn set_open_profit_loss(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(44) {
            self.open_profit_loss = f64_le(value);
        }
        self
    }

    fn set_daily_profit_loss(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(52) {
            self.daily_profit_loss = f64_le(value);
        }
        self
    }

    fn set_last_daily_profit_loss_reset_date_time_utc(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(60) {
            self.last_daily_profit_loss_reset_date_time_utc = value.to_le();
        }
        self
    }

    fn set_service_position_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(68) {
            self.service_position_quantity = f64_le(value);
        }
        self
    }

    fn set_position_has_been_updated_by_service(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(69) {
            self.position_has_been_updated_by_service = value;
        }
        self
    }

    fn set_price_high_during_position(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(77) {
            self.price_high_during_position = f64_le(value);
        }
        self
    }

    fn set_price_low_during_position(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(85) {
            self.price_low_during_position = f64_le(value);
        }
        self
    }

    fn set_price_last_during_position(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(93) {
            self.price_last_during_position = f64_le(value);
        }
        self
    }

    fn set_last_processed_time_and_sales_sequence(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(101) {
            self.last_processed_time_and_sales_sequence = value.to_le();
        }
        self
    }

    fn set_total_margin_requirement(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(109) {
            self.total_margin_requirement = f64_le(value);
        }
        self
    }

    fn set_initial_entry_date_time_utc(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(117) {
            self.initial_entry_date_time_utc = value.to_le();
        }
        self
    }

    fn set_is_from_dtc_server_replay(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(118) {
            self.is_from_dtc_server_replay = value;
        }
        self
    }

    fn set_most_recent_position_increase_date_time_utc(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(126) {
            self.most_recent_position_increase_date_time_utc = value.to_le();
        }
        self
    }

    fn set_is_snapshot(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(127) {
            self.is_snapshot = value;
        }
        self
    }

    fn set_is_first_message_in_batch(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(128) {
            self.is_first_message_in_batch = value;
        }
        self
    }

    fn set_is_last_message_in_batch(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(129) {
            self.is_last_message_in_batch = value;
        }
        self
    }

    fn set_margin_requirement_full(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(137) {
            self.margin_requirement_full = f64_le(value);
        }
        self
    }

    fn set_margin_requirement_full_positions_only(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(145) {
            self.margin_requirement_full_positions_only = f64_le(value);
        }
        self
    }

    fn set_max_potential_position_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(153) {
            self.max_potential_position_quantity = f64_le(value);
        }
        self
    }

    fn set_quantity_at_end_of_day_capture_time(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(161) {
            self.quantity_at_end_of_day_capture_time = f64_le(value);
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    #[test]
    pub(crate) fn layout() {
        unsafe {
            assert_eq!(
                161usize,
                core::mem::size_of::<TradePositionConsolidatedVLSData>(),
                "TradePositionConsolidatedVLSData sizeof expected {:} but was {:}",
                161usize,
                core::mem::size_of::<TradePositionConsolidatedVLSData>()
            );
            assert_eq!(
                161u16,
                TradePositionConsolidatedVLS::new().size(),
                "TradePositionConsolidatedVLS sizeof expected {:} but was {:}",
                161u16,
                TradePositionConsolidatedVLS::new().size(),
            );
            assert_eq!(
                TRADE_POSITION_CONSOLIDATED,
                TradePositionConsolidatedVLS::new().r#type(),
                "TradePositionConsolidatedVLS type expected {:} but was {:}",
                TRADE_POSITION_CONSOLIDATED,
                TradePositionConsolidatedVLS::new().r#type(),
            );
            assert_eq!(
                10113u16,
                TradePositionConsolidatedVLS::new().r#type(),
                "TradePositionConsolidatedVLS type expected {:} but was {:}",
                10113u16,
                TradePositionConsolidatedVLS::new().r#type(),
            );
            let d = TradePositionConsolidatedVLSData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
                "base_size offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
            );
            assert_eq!(
                6usize,
                (core::ptr::addr_of!(d.is_deleted) as usize) - p,
                "is_deleted offset expected {:} but was {:}",
                6usize,
                (core::ptr::addr_of!(d.is_deleted) as usize) - p,
            );
            assert_eq!(
                7usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
                "symbol offset expected {:} but was {:}",
                7usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
            );
            assert_eq!(
                11usize,
                (core::ptr::addr_of!(d.is_simulated) as usize) - p,
                "is_simulated offset expected {:} but was {:}",
                11usize,
                (core::ptr::addr_of!(d.is_simulated) as usize) - p,
            );
            assert_eq!(
                12usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
                "trade_account offset expected {:} but was {:}",
                12usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
            );
            assert_eq!(
                16usize,
                (core::ptr::addr_of!(d.currency_code) as usize) - p,
                "currency_code offset expected {:} but was {:}",
                16usize,
                (core::ptr::addr_of!(d.currency_code) as usize) - p,
            );
            assert_eq!(
                20usize,
                (core::ptr::addr_of!(d.quantity) as usize) - p,
                "quantity offset expected {:} but was {:}",
                20usize,
                (core::ptr::addr_of!(d.quantity) as usize) - p,
            );
            assert_eq!(
                28usize,
                (core::ptr::addr_of!(d.average_price) as usize) - p,
                "average_price offset expected {:} but was {:}",
                28usize,
                (core::ptr::addr_of!(d.average_price) as usize) - p,
            );
            assert_eq!(
                36usize,
                (core::ptr::addr_of!(d.open_profit_loss) as usize) - p,
                "open_profit_loss offset expected {:} but was {:}",
                36usize,
                (core::ptr::addr_of!(d.open_profit_loss) as usize) - p,
            );
            assert_eq!(
                44usize,
                (core::ptr::addr_of!(d.daily_profit_loss) as usize) - p,
                "daily_profit_loss offset expected {:} but was {:}",
                44usize,
                (core::ptr::addr_of!(d.daily_profit_loss) as usize) - p,
            );
            assert_eq!(
                52usize,
                (core::ptr::addr_of!(d.last_daily_profit_loss_reset_date_time_utc) as usize) - p,
                "last_daily_profit_loss_reset_date_time_utc offset expected {:} but was {:}",
                52usize,
                (core::ptr::addr_of!(d.last_daily_profit_loss_reset_date_time_utc) as usize) - p,
            );
            assert_eq!(
                60usize,
                (core::ptr::addr_of!(d.service_position_quantity) as usize) - p,
                "service_position_quantity offset expected {:} but was {:}",
                60usize,
                (core::ptr::addr_of!(d.service_position_quantity) as usize) - p,
            );
            assert_eq!(
                68usize,
                (core::ptr::addr_of!(d.position_has_been_updated_by_service) as usize) - p,
                "position_has_been_updated_by_service offset expected {:} but was {:}",
                68usize,
                (core::ptr::addr_of!(d.position_has_been_updated_by_service) as usize) - p,
            );
            assert_eq!(
                69usize,
                (core::ptr::addr_of!(d.price_high_during_position) as usize) - p,
                "price_high_during_position offset expected {:} but was {:}",
                69usize,
                (core::ptr::addr_of!(d.price_high_during_position) as usize) - p,
            );
            assert_eq!(
                77usize,
                (core::ptr::addr_of!(d.price_low_during_position) as usize) - p,
                "price_low_during_position offset expected {:} but was {:}",
                77usize,
                (core::ptr::addr_of!(d.price_low_during_position) as usize) - p,
            );
            assert_eq!(
                85usize,
                (core::ptr::addr_of!(d.price_last_during_position) as usize) - p,
                "price_last_during_position offset expected {:} but was {:}",
                85usize,
                (core::ptr::addr_of!(d.price_last_during_position) as usize) - p,
            );
            assert_eq!(
                93usize,
                (core::ptr::addr_of!(d.last_processed_time_and_sales_sequence) as usize) - p,
                "last_processed_time_and_sales_sequence offset expected {:} but was {:}",
                93usize,
                (core::ptr::addr_of!(d.last_processed_time_and_sales_sequence) as usize) - p,
            );
            assert_eq!(
                101usize,
                (core::ptr::addr_of!(d.total_margin_requirement) as usize) - p,
                "total_margin_requirement offset expected {:} but was {:}",
                101usize,
                (core::ptr::addr_of!(d.total_margin_requirement) as usize) - p,
            );
            assert_eq!(
                109usize,
                (core::ptr::addr_of!(d.initial_entry_date_time_utc) as usize) - p,
                "initial_entry_date_time_utc offset expected {:} but was {:}",
                109usize,
                (core::ptr::addr_of!(d.initial_entry_date_time_utc) as usize) - p,
            );
            assert_eq!(
                117usize,
                (core::ptr::addr_of!(d.is_from_dtc_server_replay) as usize) - p,
                "is_from_dtc_server_replay offset expected {:} but was {:}",
                117usize,
                (core::ptr::addr_of!(d.is_from_dtc_server_replay) as usize) - p,
            );
            assert_eq!(
                118usize,
                (core::ptr::addr_of!(d.most_recent_position_increase_date_time_utc) as usize) - p,
                "most_recent_position_increase_date_time_utc offset expected {:} but was {:}",
                118usize,
                (core::ptr::addr_of!(d.most_recent_position_increase_date_time_utc) as usize) - p,
            );
            assert_eq!(
                126usize,
                (core::ptr::addr_of!(d.is_snapshot) as usize) - p,
                "is_snapshot offset expected {:} but was {:}",
                126usize,
                (core::ptr::addr_of!(d.is_snapshot) as usize) - p,
            );
            assert_eq!(
                127usize,
                (core::ptr::addr_of!(d.is_first_message_in_batch) as usize) - p,
                "is_first_message_in_batch offset expected {:} but was {:}",
                127usize,
                (core::ptr::addr_of!(d.is_first_message_in_batch) as usize) - p,
            );
            assert_eq!(
                128usize,
                (core::ptr::addr_of!(d.is_last_message_in_batch) as usize) - p,
                "is_last_message_in_batch offset expected {:} but was {:}",
                128usize,
                (core::ptr::addr_of!(d.is_last_message_in_batch) as usize) - p,
            );
            assert_eq!(
                129usize,
                (core::ptr::addr_of!(d.margin_requirement_full) as usize) - p,
                "margin_requirement_full offset expected {:} but was {:}",
                129usize,
                (core::ptr::addr_of!(d.margin_requirement_full) as usize) - p,
            );
            assert_eq!(
                137usize,
                (core::ptr::addr_of!(d.margin_requirement_full_positions_only) as usize) - p,
                "margin_requirement_full_positions_only offset expected {:} but was {:}",
                137usize,
                (core::ptr::addr_of!(d.margin_requirement_full_positions_only) as usize) - p,
            );
            assert_eq!(
                145usize,
                (core::ptr::addr_of!(d.max_potential_position_quantity) as usize) - p,
                "max_potential_position_quantity offset expected {:} but was {:}",
                145usize,
                (core::ptr::addr_of!(d.max_potential_position_quantity) as usize) - p,
            );
            assert_eq!(
                153usize,
                (core::ptr::addr_of!(d.quantity_at_end_of_day_capture_time) as usize) - p,
                "quantity_at_end_of_day_capture_time offset expected {:} but was {:}",
                153usize,
                (core::ptr::addr_of!(d.quantity_at_end_of_day_capture_time) as usize) - p,
            );
        }
    }
}
