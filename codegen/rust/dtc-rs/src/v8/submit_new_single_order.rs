// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-25 15:25:42.126453 +0800 WITA m=+0.007296918
use super::*;

pub(crate) const SUBMIT_NEW_SINGLE_ORDER_VLS_SIZE: usize = 104;

pub(crate) const SUBMIT_NEW_SINGLE_ORDER_FIXED_SIZE: usize = 296;

/// size                 u16                 = SubmitNewSingleOrderVLSSize  (104)
/// type                 u16                 = SUBMIT_NEW_SINGLE_ORDER  (208)
/// base_size            u16                 = SubmitNewSingleOrderVLSSize  (104)
/// symbol               string              = ""
/// exchange             string              = ""
/// trade_account        string              = ""
/// client_order_id      string              = ""
/// order_type           OrderTypeEnum       = ORDER_TYPE_UNSET  (0)
/// buy_sell             BuySellEnum         = BUY_SELL_UNSET  (0)
/// price1               f64                 = 0
/// price2               f64                 = 0
/// quantity             f64                 = 0
/// time_in_force        TimeInForceEnum     = TIF_UNSET  (0)
/// good_till_date_time  DateTime            = 0
/// is_automated_order   bool                = false
/// is_parent_order      bool                = false
/// free_form_text       string              = ""
/// open_or_close        OpenCloseTradeEnum  = TRADE_UNSET  (0)
/// max_show_quantity    f64                 = 0
/// price1_as_string     string              = ""
/// price2_as_string     string              = ""
pub(crate) const SUBMIT_NEW_SINGLE_ORDER_VLS_DEFAULT: [u8; 104] = [
    104, 0, 208, 0, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/// size                 u16                 = SubmitNewSingleOrderFixedSize  (296)
/// type                 u16                 = SUBMIT_NEW_SINGLE_ORDER  (208)
/// symbol               string64            = ""
/// exchange             string16            = ""
/// trade_account        string32            = ""
/// client_order_id      string32            = ""
/// order_type           OrderTypeEnum       = ORDER_TYPE_UNSET  (0)
/// buy_sell             BuySellEnum         = BUY_SELL_UNSET  (0)
/// price1               f64                 = 0
/// price2               f64                 = 0
/// quantity             f64                 = 0
/// time_in_force        TimeInForceEnum     = TIF_UNSET  (0)
/// good_till_date_time  DateTime            = 0
/// is_automated_order   bool                = false
/// is_parent_order      bool                = false
/// free_form_text       string48            = ""
/// open_or_close        OpenCloseTradeEnum  = TRADE_UNSET  (0)
/// max_show_quantity    f64                 = 0
/// price1_as_string     string16            = ""
/// price2_as_string     string16            = ""
pub(crate) const SUBMIT_NEW_SINGLE_ORDER_FIXED_DEFAULT: [u8; 296] = [
    40, 1, 208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/// This message is used to submit a new single order into the market from
/// the Client to the Server.
pub trait SubmitNewSingleOrder: Message {
    type Safe: SubmitNewSingleOrder;
    type Unsafe: SubmitNewSingleOrder;

    /// The symbol for the order.
    fn symbol(&self) -> &str;

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str;

    /// This is the trade account as a text string that the order belongs to.
    fn trade_account(&self) -> &str;

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn client_order_id(&self) -> &str;

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn order_type(&self) -> OrderTypeEnum;

    /// The side of the order. Either Buy or Sell.
    fn buy_sell(&self) -> BuySellEnum;

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn price1(&self) -> f64;

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn price2(&self) -> f64;

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn quantity(&self) -> f64;

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn time_in_force(&self) -> TimeInForceEnum;

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn good_till_date_time(&self) -> DateTime;

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn is_automated_order(&self) -> bool;

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn is_parent_order(&self) -> bool;

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn free_form_text(&self) -> &str;

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum;

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn max_show_quantity(&self) -> f64;

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn price1_as_string(&self) -> &str;

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn price2_as_string(&self) -> &str;

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self;

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self;

    /// This is the trade account as a text string that the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self;

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self;

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self;

    /// The side of the order. Either Buy or Sell.
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self;

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn set_price1(&mut self, value: f64) -> &mut Self;

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn set_price2(&mut self, value: f64) -> &mut Self;

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn set_quantity(&mut self, value: f64) -> &mut Self;

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self;

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self;

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn set_is_automated_order(&mut self, value: bool) -> &mut Self;

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn set_is_parent_order(&mut self, value: bool) -> &mut Self;

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self;

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self;

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn set_max_show_quantity(&mut self, value: f64) -> &mut Self;

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn set_price1_as_string(&mut self, value: &str) -> &mut Self;

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn set_price2_as_string(&mut self, value: &str) -> &mut Self;

    fn clone_safe(&self) -> Self::Safe;

    fn to_safe(self) -> Self::Safe;

    fn copy_to(&self, to: &mut impl SubmitNewSingleOrder) {
        to.set_symbol(self.symbol());
        to.set_exchange(self.exchange());
        to.set_trade_account(self.trade_account());
        to.set_client_order_id(self.client_order_id());
        to.set_order_type(self.order_type());
        to.set_buy_sell(self.buy_sell());
        to.set_price1(self.price1());
        to.set_price2(self.price2());
        to.set_quantity(self.quantity());
        to.set_time_in_force(self.time_in_force());
        to.set_good_till_date_time(self.good_till_date_time());
        to.set_is_automated_order(self.is_automated_order());
        to.set_is_parent_order(self.is_parent_order());
        to.set_free_form_text(self.free_form_text());
        to.set_open_or_close(self.open_or_close());
        to.set_max_show_quantity(self.max_show_quantity());
        to.set_price1_as_string(self.price1_as_string());
        to.set_price2_as_string(self.price2_as_string());
    }
}

/// This message is used to submit a new single order into the market from
/// the Client to the Server.
pub struct SubmitNewSingleOrderVLS {
    data: *const SubmitNewSingleOrderVLSData,
    capacity: usize,
}

pub struct SubmitNewSingleOrderVLSUnsafe {
    data: *const SubmitNewSingleOrderVLSData,
    capacity: usize,
}

#[repr(packed(8), C)]
pub struct SubmitNewSingleOrderVLSData {
    size: u16,
    r#type: u16,
    base_size: u16,
    symbol: VLS,
    exchange: VLS,
    trade_account: VLS,
    client_order_id: VLS,
    order_type: OrderTypeEnum,
    buy_sell: BuySellEnum,
    price1: f64,
    price2: f64,
    quantity: f64,
    time_in_force: TimeInForceEnum,
    good_till_date_time: DateTime,
    is_automated_order: bool,
    is_parent_order: bool,
    free_form_text: VLS,
    open_or_close: OpenCloseTradeEnum,
    max_show_quantity: f64,
    price1_as_string: VLS,
    price2_as_string: VLS,
}

/// This message is used to submit a new single order into the market from
/// the Client to the Server.
pub struct SubmitNewSingleOrderFixed {
    data: *const SubmitNewSingleOrderFixedData,
}

pub struct SubmitNewSingleOrderFixedUnsafe {
    data: *const SubmitNewSingleOrderFixedData,
}

#[repr(packed(8), C)]
pub struct SubmitNewSingleOrderFixedData {
    size: u16,
    r#type: u16,
    symbol: [u8; 64],
    exchange: [u8; 16],
    trade_account: [u8; 32],
    client_order_id: [u8; 32],
    order_type: OrderTypeEnum,
    buy_sell: BuySellEnum,
    price1: f64,
    price2: f64,
    quantity: f64,
    time_in_force: TimeInForceEnum,
    good_till_date_time: DateTime,
    is_automated_order: bool,
    is_parent_order: bool,
    free_form_text: [u8; 48],
    open_or_close: OpenCloseTradeEnum,
    max_show_quantity: f64,
    price1_as_string: [u8; 16],
    price2_as_string: [u8; 16],
}

impl SubmitNewSingleOrderVLSData {
    pub fn new() -> Self {
        Self {
            size: 104u16.to_le(),
            r#type: SUBMIT_NEW_SINGLE_ORDER.to_le(),
            base_size: 104u16.to_le(),
            symbol: crate::message::VLS::new(),
            exchange: crate::message::VLS::new(),
            trade_account: crate::message::VLS::new(),
            client_order_id: crate::message::VLS::new(),
            order_type: OrderTypeEnum::OrderTypeUnset.to_le(),
            buy_sell: BuySellEnum::BuySellUnset.to_le(),
            price1: 0.0f64,
            price2: 0.0f64,
            quantity: 0.0f64,
            time_in_force: TimeInForceEnum::TifUnset.to_le(),
            good_till_date_time: 0i64,
            is_automated_order: false,
            is_parent_order: false,
            free_form_text: crate::message::VLS::new(),
            open_or_close: OpenCloseTradeEnum::TradeUnset.to_le(),
            max_show_quantity: 0.0f64,
            price1_as_string: crate::message::VLS::new(),
            price2_as_string: crate::message::VLS::new(),
        }
    }
}

impl SubmitNewSingleOrderFixedData {
    pub fn new() -> Self {
        Self {
            size: 296u16.to_le(),
            r#type: SUBMIT_NEW_SINGLE_ORDER.to_le(),
            symbol: [0; 64],
            exchange: [0; 16],
            trade_account: [0; 32],
            client_order_id: [0; 32],
            order_type: OrderTypeEnum::OrderTypeUnset.to_le(),
            buy_sell: BuySellEnum::BuySellUnset.to_le(),
            price1: 0.0f64,
            price2: 0.0f64,
            quantity: 0.0f64,
            time_in_force: TimeInForceEnum::TifUnset.to_le(),
            good_till_date_time: 0i64,
            is_automated_order: false,
            is_parent_order: false,
            free_form_text: [0; 48],
            open_or_close: OpenCloseTradeEnum::TradeUnset.to_le(),
            max_show_quantity: 0.0f64,
            price1_as_string: [0; 16],
            price2_as_string: [0; 16],
        }
    }
}

unsafe impl Send for SubmitNewSingleOrderFixed {}
unsafe impl Send for SubmitNewSingleOrderFixedUnsafe {}
unsafe impl Send for SubmitNewSingleOrderFixedData {}
unsafe impl Send for SubmitNewSingleOrderVLS {}
unsafe impl Send for SubmitNewSingleOrderVLSUnsafe {}
unsafe impl Send for SubmitNewSingleOrderVLSData {}

impl Drop for SubmitNewSingleOrderFixed {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for SubmitNewSingleOrderFixedUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for SubmitNewSingleOrderVLS {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for SubmitNewSingleOrderVLSUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Clone for SubmitNewSingleOrderFixed {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for SubmitNewSingleOrderFixedUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for SubmitNewSingleOrderVLS {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for SubmitNewSingleOrderVLSUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Into<Vec<u8>> for SubmitNewSingleOrderFixed {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for SubmitNewSingleOrderFixedUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for SubmitNewSingleOrderVLS {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for SubmitNewSingleOrderVLSUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl core::ops::Deref for SubmitNewSingleOrderFixed {
    type Target = SubmitNewSingleOrderFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for SubmitNewSingleOrderFixed {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for SubmitNewSingleOrderFixedUnsafe {
    type Target = SubmitNewSingleOrderFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for SubmitNewSingleOrderFixedUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for SubmitNewSingleOrderVLS {
    type Target = SubmitNewSingleOrderVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for SubmitNewSingleOrderVLS {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for SubmitNewSingleOrderVLSUnsafe {
    type Target = SubmitNewSingleOrderVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for SubmitNewSingleOrderVLSUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl crate::Message for SubmitNewSingleOrderFixed {
    type Data = SubmitNewSingleOrderFixedData;

    const BASE_SIZE: usize = 296;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, SubmitNewSingleOrderFixedData::new()),
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const SubmitNewSingleOrderFixedData,
        }
    }
}
impl crate::Message for SubmitNewSingleOrderFixedUnsafe {
    type Data = SubmitNewSingleOrderFixedData;

    const BASE_SIZE: usize = 296;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, SubmitNewSingleOrderFixedData::new()),
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const SubmitNewSingleOrderFixedData,
        }
    }
}
impl crate::Message for SubmitNewSingleOrderVLS {
    type Data = SubmitNewSingleOrderVLSData;

    const BASE_SIZE: usize = 104;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, SubmitNewSingleOrderVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const SubmitNewSingleOrderVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for SubmitNewSingleOrderVLS {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const SubmitNewSingleOrderVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl crate::Message for SubmitNewSingleOrderVLSUnsafe {
    type Data = SubmitNewSingleOrderVLSData;

    const BASE_SIZE: usize = 104;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, SubmitNewSingleOrderVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const SubmitNewSingleOrderVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for SubmitNewSingleOrderVLSUnsafe {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const SubmitNewSingleOrderVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
/// This message is used to submit a new single order into the market from
/// the Client to the Server.
impl SubmitNewSingleOrder for SubmitNewSingleOrderVLS {
    type Safe = SubmitNewSingleOrderVLS;
    type Unsafe = SubmitNewSingleOrderVLSUnsafe;

    /// The symbol for the order.
    fn symbol(&self) -> &str {
        get_vls(self, self.symbol)
    }

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str {
        get_vls(self, self.exchange)
    }

    /// This is the trade account as a text string that the order belongs to.
    fn trade_account(&self) -> &str {
        get_vls(self, self.trade_account)
    }

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn client_order_id(&self) -> &str {
        get_vls(self, self.client_order_id)
    }

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn order_type(&self) -> OrderTypeEnum {
        OrderTypeEnum::from_le(self.order_type)
    }

    /// The side of the order. Either Buy or Sell.
    fn buy_sell(&self) -> BuySellEnum {
        BuySellEnum::from_le(self.buy_sell)
    }

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn price1(&self) -> f64 {
        f64_le(self.price1)
    }

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn price2(&self) -> f64 {
        f64_le(self.price2)
    }

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn quantity(&self) -> f64 {
        f64_le(self.quantity)
    }

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn time_in_force(&self) -> TimeInForceEnum {
        TimeInForceEnum::from_le(self.time_in_force)
    }

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn good_till_date_time(&self) -> DateTime {
        i64::from_le(self.good_till_date_time)
    }

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn is_automated_order(&self) -> bool {
        self.is_automated_order
    }

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn is_parent_order(&self) -> bool {
        self.is_parent_order
    }

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn free_form_text(&self) -> &str {
        get_vls(self, self.free_form_text)
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum {
        OpenCloseTradeEnum::from_le(self.open_or_close)
    }

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn max_show_quantity(&self) -> f64 {
        f64_le(self.max_show_quantity)
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn price1_as_string(&self) -> &str {
        get_vls(self, self.price1_as_string)
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn price2_as_string(&self) -> &str {
        get_vls(self, self.price2_as_string)
    }

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self {
        self.symbol = set_vls(self, self.symbol, value);
        self
    }

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self {
        self.exchange = set_vls(self, self.exchange, value);
        self
    }

    /// This is the trade account as a text string that the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        self.trade_account = set_vls(self, self.trade_account, value);
        self
    }

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self {
        self.client_order_id = set_vls(self, self.client_order_id, value);
        self
    }

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self {
        self.order_type = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// The side of the order. Either Buy or Sell.
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self {
        self.buy_sell = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn set_price1(&mut self, value: f64) -> &mut Self {
        self.price1 = f64_le(value);
        self
    }

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn set_price2(&mut self, value: f64) -> &mut Self {
        self.price2 = f64_le(value);
        self
    }

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn set_quantity(&mut self, value: f64) -> &mut Self {
        self.quantity = f64_le(value);
        self
    }

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self {
        self.time_in_force = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self {
        self.good_till_date_time = value.to_le();
        self
    }

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn set_is_automated_order(&mut self, value: bool) -> &mut Self {
        self.is_automated_order = value;
        self
    }

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn set_is_parent_order(&mut self, value: bool) -> &mut Self {
        self.is_parent_order = value;
        self
    }

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self {
        self.free_form_text = set_vls(self, self.free_form_text, value);
        self
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self {
        self.open_or_close = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn set_max_show_quantity(&mut self, value: f64) -> &mut Self {
        self.max_show_quantity = f64_le(value);
        self
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn set_price1_as_string(&mut self, value: &str) -> &mut Self {
        self.price1_as_string = set_vls(self, self.price1_as_string, value);
        self
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn set_price2_as_string(&mut self, value: &str) -> &mut Self {
        self.price2_as_string = set_vls(self, self.price2_as_string, value);
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

/// This message is used to submit a new single order into the market from
/// the Client to the Server.
impl SubmitNewSingleOrder for SubmitNewSingleOrderVLSUnsafe {
    type Safe = SubmitNewSingleOrderVLS;
    type Unsafe = SubmitNewSingleOrderVLSUnsafe;

    /// The symbol for the order.
    fn symbol(&self) -> &str {
        if self.is_out_of_bounds(10) {
            ""
        } else {
            get_vls(self, self.symbol)
        }
    }

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str {
        if self.is_out_of_bounds(14) {
            ""
        } else {
            get_vls(self, self.exchange)
        }
    }

    /// This is the trade account as a text string that the order belongs to.
    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(18) {
            ""
        } else {
            get_vls(self, self.trade_account)
        }
    }

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn client_order_id(&self) -> &str {
        if self.is_out_of_bounds(22) {
            ""
        } else {
            get_vls(self, self.client_order_id)
        }
    }

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn order_type(&self) -> OrderTypeEnum {
        if self.is_out_of_bounds(28) {
            OrderTypeEnum::OrderTypeUnset.to_le()
        } else {
            OrderTypeEnum::from_le(self.order_type)
        }
    }

    /// The side of the order. Either Buy or Sell.
    fn buy_sell(&self) -> BuySellEnum {
        if self.is_out_of_bounds(32) {
            BuySellEnum::BuySellUnset.to_le()
        } else {
            BuySellEnum::from_le(self.buy_sell)
        }
    }

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn price1(&self) -> f64 {
        if self.is_out_of_bounds(40) {
            0.0f64
        } else {
            f64_le(self.price1)
        }
    }

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn price2(&self) -> f64 {
        if self.is_out_of_bounds(48) {
            0.0f64
        } else {
            f64_le(self.price2)
        }
    }

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn quantity(&self) -> f64 {
        if self.is_out_of_bounds(56) {
            0.0f64
        } else {
            f64_le(self.quantity)
        }
    }

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn time_in_force(&self) -> TimeInForceEnum {
        if self.is_out_of_bounds(60) {
            TimeInForceEnum::TifUnset.to_le()
        } else {
            TimeInForceEnum::from_le(self.time_in_force)
        }
    }

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn good_till_date_time(&self) -> DateTime {
        if self.is_out_of_bounds(72) {
            0i64
        } else {
            i64::from_le(self.good_till_date_time)
        }
    }

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn is_automated_order(&self) -> bool {
        if self.is_out_of_bounds(73) {
            false
        } else {
            self.is_automated_order
        }
    }

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn is_parent_order(&self) -> bool {
        if self.is_out_of_bounds(74) {
            false
        } else {
            self.is_parent_order
        }
    }

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn free_form_text(&self) -> &str {
        if self.is_out_of_bounds(78) {
            ""
        } else {
            get_vls(self, self.free_form_text)
        }
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum {
        if self.is_out_of_bounds(84) {
            OpenCloseTradeEnum::TradeUnset.to_le()
        } else {
            OpenCloseTradeEnum::from_le(self.open_or_close)
        }
    }

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn max_show_quantity(&self) -> f64 {
        if self.is_out_of_bounds(96) {
            0.0f64
        } else {
            f64_le(self.max_show_quantity)
        }
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn price1_as_string(&self) -> &str {
        if self.is_out_of_bounds(100) {
            ""
        } else {
            get_vls(self, self.price1_as_string)
        }
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn price2_as_string(&self) -> &str {
        if self.is_out_of_bounds(104) {
            ""
        } else {
            get_vls(self, self.price2_as_string)
        }
    }

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(10) {
            self.symbol = set_vls(self, self.symbol, value);
        }
        self
    }

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(14) {
            self.exchange = set_vls(self, self.exchange, value);
        }
        self
    }

    /// This is the trade account as a text string that the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(18) {
            self.trade_account = set_vls(self, self.trade_account, value);
        }
        self
    }

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(22) {
            self.client_order_id = set_vls(self, self.client_order_id, value);
        }
        self
    }

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self {
        if !self.is_out_of_bounds(28) {
            self.order_type = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// The side of the order. Either Buy or Sell.
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self {
        if !self.is_out_of_bounds(32) {
            self.buy_sell = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn set_price1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(40) {
            self.price1 = f64_le(value);
        }
        self
    }

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn set_price2(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(48) {
            self.price2 = f64_le(value);
        }
        self
    }

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn set_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(56) {
            self.quantity = f64_le(value);
        }
        self
    }

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self {
        if !self.is_out_of_bounds(60) {
            self.time_in_force = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self {
        if !self.is_out_of_bounds(72) {
            self.good_till_date_time = value.to_le();
        }
        self
    }

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn set_is_automated_order(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(73) {
            self.is_automated_order = value;
        }
        self
    }

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn set_is_parent_order(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(74) {
            self.is_parent_order = value;
        }
        self
    }

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(78) {
            self.free_form_text = set_vls(self, self.free_form_text, value);
        }
        self
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self {
        if !self.is_out_of_bounds(84) {
            self.open_or_close = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn set_max_show_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(96) {
            self.max_show_quantity = f64_le(value);
        }
        self
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn set_price1_as_string(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(100) {
            self.price1_as_string = set_vls(self, self.price1_as_string, value);
        }
        self
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn set_price2_as_string(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(104) {
            self.price2_as_string = set_vls(self, self.price2_as_string, value);
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

/// This message is used to submit a new single order into the market from
/// the Client to the Server.
impl SubmitNewSingleOrder for SubmitNewSingleOrderFixed {
    type Safe = SubmitNewSingleOrderFixed;
    type Unsafe = SubmitNewSingleOrderFixedUnsafe;

    /// The symbol for the order.
    fn symbol(&self) -> &str {
        get_fixed(&self.symbol[..])
    }

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str {
        get_fixed(&self.exchange[..])
    }

    /// This is the trade account as a text string that the order belongs to.
    fn trade_account(&self) -> &str {
        get_fixed(&self.trade_account[..])
    }

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn client_order_id(&self) -> &str {
        get_fixed(&self.client_order_id[..])
    }

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn order_type(&self) -> OrderTypeEnum {
        OrderTypeEnum::from_le(self.order_type)
    }

    /// The side of the order. Either Buy or Sell.
    fn buy_sell(&self) -> BuySellEnum {
        BuySellEnum::from_le(self.buy_sell)
    }

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn price1(&self) -> f64 {
        f64_le(self.price1)
    }

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn price2(&self) -> f64 {
        f64_le(self.price2)
    }

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn quantity(&self) -> f64 {
        f64_le(self.quantity)
    }

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn time_in_force(&self) -> TimeInForceEnum {
        TimeInForceEnum::from_le(self.time_in_force)
    }

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn good_till_date_time(&self) -> DateTime {
        i64::from_le(self.good_till_date_time)
    }

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn is_automated_order(&self) -> bool {
        self.is_automated_order
    }

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn is_parent_order(&self) -> bool {
        self.is_parent_order
    }

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn free_form_text(&self) -> &str {
        get_fixed(&self.free_form_text[..])
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum {
        OpenCloseTradeEnum::from_le(self.open_or_close)
    }

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn max_show_quantity(&self) -> f64 {
        f64_le(self.max_show_quantity)
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn price1_as_string(&self) -> &str {
        get_fixed(&self.price1_as_string[..])
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn price2_as_string(&self) -> &str {
        get_fixed(&self.price2_as_string[..])
    }

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.symbol[..], value);
        self
    }

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.exchange[..], value);
        self
    }

    /// This is the trade account as a text string that the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.trade_account[..], value);
        self
    }

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.client_order_id[..], value);
        self
    }

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self {
        self.order_type = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// The side of the order. Either Buy or Sell.
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self {
        self.buy_sell = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn set_price1(&mut self, value: f64) -> &mut Self {
        self.price1 = f64_le(value);
        self
    }

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn set_price2(&mut self, value: f64) -> &mut Self {
        self.price2 = f64_le(value);
        self
    }

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn set_quantity(&mut self, value: f64) -> &mut Self {
        self.quantity = f64_le(value);
        self
    }

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self {
        self.time_in_force = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self {
        self.good_till_date_time = value.to_le();
        self
    }

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn set_is_automated_order(&mut self, value: bool) -> &mut Self {
        self.is_automated_order = value;
        self
    }

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn set_is_parent_order(&mut self, value: bool) -> &mut Self {
        self.is_parent_order = value;
        self
    }

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.free_form_text[..], value);
        self
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self {
        self.open_or_close = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn set_max_show_quantity(&mut self, value: f64) -> &mut Self {
        self.max_show_quantity = f64_le(value);
        self
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn set_price1_as_string(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.price1_as_string[..], value);
        self
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn set_price2_as_string(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.price2_as_string[..], value);
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

/// This message is used to submit a new single order into the market from
/// the Client to the Server.
impl SubmitNewSingleOrder for SubmitNewSingleOrderFixedUnsafe {
    type Safe = SubmitNewSingleOrderFixed;
    type Unsafe = SubmitNewSingleOrderFixedUnsafe;

    /// The symbol for the order.
    fn symbol(&self) -> &str {
        if self.is_out_of_bounds(68) {
            ""
        } else {
            get_fixed(&self.symbol[..])
        }
    }

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str {
        if self.is_out_of_bounds(84) {
            ""
        } else {
            get_fixed(&self.exchange[..])
        }
    }

    /// This is the trade account as a text string that the order belongs to.
    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(116) {
            ""
        } else {
            get_fixed(&self.trade_account[..])
        }
    }

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn client_order_id(&self) -> &str {
        if self.is_out_of_bounds(148) {
            ""
        } else {
            get_fixed(&self.client_order_id[..])
        }
    }

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn order_type(&self) -> OrderTypeEnum {
        if self.is_out_of_bounds(152) {
            OrderTypeEnum::OrderTypeUnset.to_le()
        } else {
            OrderTypeEnum::from_le(self.order_type)
        }
    }

    /// The side of the order. Either Buy or Sell.
    fn buy_sell(&self) -> BuySellEnum {
        if self.is_out_of_bounds(156) {
            BuySellEnum::BuySellUnset.to_le()
        } else {
            BuySellEnum::from_le(self.buy_sell)
        }
    }

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn price1(&self) -> f64 {
        if self.is_out_of_bounds(168) {
            0.0f64
        } else {
            f64_le(self.price1)
        }
    }

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn price2(&self) -> f64 {
        if self.is_out_of_bounds(176) {
            0.0f64
        } else {
            f64_le(self.price2)
        }
    }

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn quantity(&self) -> f64 {
        if self.is_out_of_bounds(184) {
            0.0f64
        } else {
            f64_le(self.quantity)
        }
    }

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn time_in_force(&self) -> TimeInForceEnum {
        if self.is_out_of_bounds(188) {
            TimeInForceEnum::TifUnset.to_le()
        } else {
            TimeInForceEnum::from_le(self.time_in_force)
        }
    }

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn good_till_date_time(&self) -> DateTime {
        if self.is_out_of_bounds(200) {
            0i64
        } else {
            i64::from_le(self.good_till_date_time)
        }
    }

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn is_automated_order(&self) -> bool {
        if self.is_out_of_bounds(201) {
            false
        } else {
            self.is_automated_order
        }
    }

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn is_parent_order(&self) -> bool {
        if self.is_out_of_bounds(202) {
            false
        } else {
            self.is_parent_order
        }
    }

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn free_form_text(&self) -> &str {
        if self.is_out_of_bounds(250) {
            ""
        } else {
            get_fixed(&self.free_form_text[..])
        }
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum {
        if self.is_out_of_bounds(256) {
            OpenCloseTradeEnum::TradeUnset.to_le()
        } else {
            OpenCloseTradeEnum::from_le(self.open_or_close)
        }
    }

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn max_show_quantity(&self) -> f64 {
        if self.is_out_of_bounds(264) {
            0.0f64
        } else {
            f64_le(self.max_show_quantity)
        }
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn price1_as_string(&self) -> &str {
        if self.is_out_of_bounds(280) {
            ""
        } else {
            get_fixed(&self.price1_as_string[..])
        }
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn price2_as_string(&self) -> &str {
        if self.is_out_of_bounds(296) {
            ""
        } else {
            get_fixed(&self.price2_as_string[..])
        }
    }

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(68) {
            set_fixed(&mut self.symbol[..], value);
        }
        self
    }

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(84) {
            set_fixed(&mut self.exchange[..], value);
        }
        self
    }

    /// This is the trade account as a text string that the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(116) {
            set_fixed(&mut self.trade_account[..], value);
        }
        self
    }

    /// This is the Client supplied order identifier. The Server will maintain
    /// this order identifier throughout the life of the order and always provide
    /// it back through the ClientOrderID field in the OrderUpdateVLS messages
    /// for the order.
    ///
    /// This identifier cannot be an identifier used for a currently open order
    /// and it cannot be an identifier previously used in the current trading
    /// session. The trading session typically will be a 24-hour period defined
    /// by the Server. The Server shall reject an order with a client order identifier
    /// that is for a currently open order or which has already been used during
    /// the current trading session.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(148) {
            set_fixed(&mut self.client_order_id[..], value);
        }
        self
    }

    /// The order type. For list of order types, refer to OrderTypeEnum.
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self {
        if !self.is_out_of_bounds(152) {
            self.order_type = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// The side of the order. Either Buy or Sell.
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self {
        if !self.is_out_of_bounds(156) {
            self.buy_sell = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// This is the price of the order. This is the limit price for a Limit order,
    /// the stop price for a Stop order, or the trigger price for a Market if
    /// Touched order.
    fn set_price1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(168) {
            self.price1 = f64_le(value);
        }
        self
    }

    /// For a Stop-Limit order, this is the limit price. This only applies to
    /// Stop-Limit orders.
    fn set_price2(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(176) {
            self.price2 = f64_le(value);
        }
        self
    }

    /// The quantity of the order. The exact meaning of this will be specified
    /// by the Server implementation.
    fn set_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(184) {
            self.quantity = f64_le(value);
        }
        self
    }

    /// The Time in Force for the order or orders (in the case of an OCO order).
    /// The Time in Force for the order or orders (in the case of an OCO order).
    ///
    /// For more information, refer to TimeInForceEnum.
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self {
        if !self.is_out_of_bounds(188) {
            self.time_in_force = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// In the case of when the TimeInForce is TIF_GOOD_TILL_DATE_TIME, this specifies
    /// the expiration Date-Time of the order.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self {
        if !self.is_out_of_bounds(200) {
            self.good_till_date_time = value.to_le();
        }
        self
    }

    /// This is set 1 to signify the order has been submitted by an automated
    /// trading process.
    fn set_is_automated_order(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(201) {
            self.is_automated_order = value;
        }
        self
    }

    /// The Client will set this to 1 when the order is part of a bracket order.
    /// This indicates that this is the parent order. A bracket order will consist
    /// of a SubmitNewSingleOrderVLS message followed by a SubmitNewOCOOrderVLS
    /// message. The Server will use IsParentOrder as a flag to know that this
    /// message is a parent order. The Server will hold onto this order until
    /// it receives the subsequent SubmitNewOCOOrderVLS message and then process
    /// all of the orders as one complete set.
    fn set_is_parent_order(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(202) {
            self.is_parent_order = value;
        }
        self
    }

    /// Optional: This is an optional text string which can be set by the Client
    /// to associate text with the order. The Server is not under any obligation
    /// to use this text and it may place a limitation on the length of this text.
    /// to use this text and it may place a limitation on the length of this text.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(250) {
            set_fixed(&mut self.free_form_text[..], value);
        }
        self
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self {
        if !self.is_out_of_bounds(256) {
            self.open_or_close = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// This field is provided to the exchange and represents the maximum quantity
    /// to show in the limit order book for the order.
    fn set_max_show_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(264) {
            self.max_show_quantity = f64_le(value);
        }
        self
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 1 as a string.
    fn set_price1_as_string(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(280) {
            set_fixed(&mut self.price1_as_string[..], value);
        }
        self
    }

    /// This is an optional field which may be used by the Server.
    ///
    /// This field is the order price 2 as a string.
    fn set_price2_as_string(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(296) {
            set_fixed(&mut self.price2_as_string[..], value);
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    #[test]
    pub(crate) fn layout() {
        unsafe {
            assert_eq!(
                296usize,
                core::mem::size_of::<SubmitNewSingleOrderFixedData>(),
                "SubmitNewSingleOrderFixedData sizeof expected {:} but was {:}",
                296usize,
                core::mem::size_of::<SubmitNewSingleOrderFixedData>()
            );
            assert_eq!(
                296u16,
                SubmitNewSingleOrderFixed::new().size(),
                "SubmitNewSingleOrderFixed sizeof expected {:} but was {:}",
                296u16,
                SubmitNewSingleOrderFixed::new().size(),
            );
            assert_eq!(
                SUBMIT_NEW_SINGLE_ORDER,
                SubmitNewSingleOrderFixed::new().r#type(),
                "SubmitNewSingleOrderFixed type expected {:} but was {:}",
                SUBMIT_NEW_SINGLE_ORDER,
                SubmitNewSingleOrderFixed::new().r#type(),
            );
            assert_eq!(
                208u16,
                SubmitNewSingleOrderFixed::new().r#type(),
                "SubmitNewSingleOrderFixed type expected {:} but was {:}",
                208u16,
                SubmitNewSingleOrderFixed::new().r#type(),
            );
            let d = SubmitNewSingleOrderFixedData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
                "symbol offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
            );
            assert_eq!(
                68usize,
                (core::ptr::addr_of!(d.exchange) as usize) - p,
                "exchange offset expected {:} but was {:}",
                68usize,
                (core::ptr::addr_of!(d.exchange) as usize) - p,
            );
            assert_eq!(
                84usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
                "trade_account offset expected {:} but was {:}",
                84usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
            );
            assert_eq!(
                116usize,
                (core::ptr::addr_of!(d.client_order_id) as usize) - p,
                "client_order_id offset expected {:} but was {:}",
                116usize,
                (core::ptr::addr_of!(d.client_order_id) as usize) - p,
            );
            assert_eq!(
                148usize,
                (core::ptr::addr_of!(d.order_type) as usize) - p,
                "order_type offset expected {:} but was {:}",
                148usize,
                (core::ptr::addr_of!(d.order_type) as usize) - p,
            );
            assert_eq!(
                152usize,
                (core::ptr::addr_of!(d.buy_sell) as usize) - p,
                "buy_sell offset expected {:} but was {:}",
                152usize,
                (core::ptr::addr_of!(d.buy_sell) as usize) - p,
            );
            assert_eq!(
                160usize,
                (core::ptr::addr_of!(d.price1) as usize) - p,
                "price1 offset expected {:} but was {:}",
                160usize,
                (core::ptr::addr_of!(d.price1) as usize) - p,
            );
            assert_eq!(
                168usize,
                (core::ptr::addr_of!(d.price2) as usize) - p,
                "price2 offset expected {:} but was {:}",
                168usize,
                (core::ptr::addr_of!(d.price2) as usize) - p,
            );
            assert_eq!(
                176usize,
                (core::ptr::addr_of!(d.quantity) as usize) - p,
                "quantity offset expected {:} but was {:}",
                176usize,
                (core::ptr::addr_of!(d.quantity) as usize) - p,
            );
            assert_eq!(
                184usize,
                (core::ptr::addr_of!(d.time_in_force) as usize) - p,
                "time_in_force offset expected {:} but was {:}",
                184usize,
                (core::ptr::addr_of!(d.time_in_force) as usize) - p,
            );
            assert_eq!(
                192usize,
                (core::ptr::addr_of!(d.good_till_date_time) as usize) - p,
                "good_till_date_time offset expected {:} but was {:}",
                192usize,
                (core::ptr::addr_of!(d.good_till_date_time) as usize) - p,
            );
            assert_eq!(
                200usize,
                (core::ptr::addr_of!(d.is_automated_order) as usize) - p,
                "is_automated_order offset expected {:} but was {:}",
                200usize,
                (core::ptr::addr_of!(d.is_automated_order) as usize) - p,
            );
            assert_eq!(
                201usize,
                (core::ptr::addr_of!(d.is_parent_order) as usize) - p,
                "is_parent_order offset expected {:} but was {:}",
                201usize,
                (core::ptr::addr_of!(d.is_parent_order) as usize) - p,
            );
            assert_eq!(
                202usize,
                (core::ptr::addr_of!(d.free_form_text) as usize) - p,
                "free_form_text offset expected {:} but was {:}",
                202usize,
                (core::ptr::addr_of!(d.free_form_text) as usize) - p,
            );
            assert_eq!(
                252usize,
                (core::ptr::addr_of!(d.open_or_close) as usize) - p,
                "open_or_close offset expected {:} but was {:}",
                252usize,
                (core::ptr::addr_of!(d.open_or_close) as usize) - p,
            );
            assert_eq!(
                256usize,
                (core::ptr::addr_of!(d.max_show_quantity) as usize) - p,
                "max_show_quantity offset expected {:} but was {:}",
                256usize,
                (core::ptr::addr_of!(d.max_show_quantity) as usize) - p,
            );
            assert_eq!(
                264usize,
                (core::ptr::addr_of!(d.price1_as_string) as usize) - p,
                "price1_as_string offset expected {:} but was {:}",
                264usize,
                (core::ptr::addr_of!(d.price1_as_string) as usize) - p,
            );
            assert_eq!(
                280usize,
                (core::ptr::addr_of!(d.price2_as_string) as usize) - p,
                "price2_as_string offset expected {:} but was {:}",
                280usize,
                (core::ptr::addr_of!(d.price2_as_string) as usize) - p,
            );
        }
        unsafe {
            assert_eq!(
                104usize,
                core::mem::size_of::<SubmitNewSingleOrderVLSData>(),
                "SubmitNewSingleOrderVLSData sizeof expected {:} but was {:}",
                104usize,
                core::mem::size_of::<SubmitNewSingleOrderVLSData>()
            );
            assert_eq!(
                104u16,
                SubmitNewSingleOrderVLS::new().size(),
                "SubmitNewSingleOrderVLS sizeof expected {:} but was {:}",
                104u16,
                SubmitNewSingleOrderVLS::new().size(),
            );
            assert_eq!(
                SUBMIT_NEW_SINGLE_ORDER,
                SubmitNewSingleOrderVLS::new().r#type(),
                "SubmitNewSingleOrderVLS type expected {:} but was {:}",
                SUBMIT_NEW_SINGLE_ORDER,
                SubmitNewSingleOrderVLS::new().r#type(),
            );
            assert_eq!(
                208u16,
                SubmitNewSingleOrderVLS::new().r#type(),
                "SubmitNewSingleOrderVLS type expected {:} but was {:}",
                208u16,
                SubmitNewSingleOrderVLS::new().r#type(),
            );
            let d = SubmitNewSingleOrderVLSData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
                "base_size offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
            );
            assert_eq!(
                6usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
                "symbol offset expected {:} but was {:}",
                6usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
            );
            assert_eq!(
                10usize,
                (core::ptr::addr_of!(d.exchange) as usize) - p,
                "exchange offset expected {:} but was {:}",
                10usize,
                (core::ptr::addr_of!(d.exchange) as usize) - p,
            );
            assert_eq!(
                14usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
                "trade_account offset expected {:} but was {:}",
                14usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
            );
            assert_eq!(
                18usize,
                (core::ptr::addr_of!(d.client_order_id) as usize) - p,
                "client_order_id offset expected {:} but was {:}",
                18usize,
                (core::ptr::addr_of!(d.client_order_id) as usize) - p,
            );
            assert_eq!(
                24usize,
                (core::ptr::addr_of!(d.order_type) as usize) - p,
                "order_type offset expected {:} but was {:}",
                24usize,
                (core::ptr::addr_of!(d.order_type) as usize) - p,
            );
            assert_eq!(
                28usize,
                (core::ptr::addr_of!(d.buy_sell) as usize) - p,
                "buy_sell offset expected {:} but was {:}",
                28usize,
                (core::ptr::addr_of!(d.buy_sell) as usize) - p,
            );
            assert_eq!(
                32usize,
                (core::ptr::addr_of!(d.price1) as usize) - p,
                "price1 offset expected {:} but was {:}",
                32usize,
                (core::ptr::addr_of!(d.price1) as usize) - p,
            );
            assert_eq!(
                40usize,
                (core::ptr::addr_of!(d.price2) as usize) - p,
                "price2 offset expected {:} but was {:}",
                40usize,
                (core::ptr::addr_of!(d.price2) as usize) - p,
            );
            assert_eq!(
                48usize,
                (core::ptr::addr_of!(d.quantity) as usize) - p,
                "quantity offset expected {:} but was {:}",
                48usize,
                (core::ptr::addr_of!(d.quantity) as usize) - p,
            );
            assert_eq!(
                56usize,
                (core::ptr::addr_of!(d.time_in_force) as usize) - p,
                "time_in_force offset expected {:} but was {:}",
                56usize,
                (core::ptr::addr_of!(d.time_in_force) as usize) - p,
            );
            assert_eq!(
                64usize,
                (core::ptr::addr_of!(d.good_till_date_time) as usize) - p,
                "good_till_date_time offset expected {:} but was {:}",
                64usize,
                (core::ptr::addr_of!(d.good_till_date_time) as usize) - p,
            );
            assert_eq!(
                72usize,
                (core::ptr::addr_of!(d.is_automated_order) as usize) - p,
                "is_automated_order offset expected {:} but was {:}",
                72usize,
                (core::ptr::addr_of!(d.is_automated_order) as usize) - p,
            );
            assert_eq!(
                73usize,
                (core::ptr::addr_of!(d.is_parent_order) as usize) - p,
                "is_parent_order offset expected {:} but was {:}",
                73usize,
                (core::ptr::addr_of!(d.is_parent_order) as usize) - p,
            );
            assert_eq!(
                74usize,
                (core::ptr::addr_of!(d.free_form_text) as usize) - p,
                "free_form_text offset expected {:} but was {:}",
                74usize,
                (core::ptr::addr_of!(d.free_form_text) as usize) - p,
            );
            assert_eq!(
                80usize,
                (core::ptr::addr_of!(d.open_or_close) as usize) - p,
                "open_or_close offset expected {:} but was {:}",
                80usize,
                (core::ptr::addr_of!(d.open_or_close) as usize) - p,
            );
            assert_eq!(
                88usize,
                (core::ptr::addr_of!(d.max_show_quantity) as usize) - p,
                "max_show_quantity offset expected {:} but was {:}",
                88usize,
                (core::ptr::addr_of!(d.max_show_quantity) as usize) - p,
            );
            assert_eq!(
                96usize,
                (core::ptr::addr_of!(d.price1_as_string) as usize) - p,
                "price1_as_string offset expected {:} but was {:}",
                96usize,
                (core::ptr::addr_of!(d.price1_as_string) as usize) - p,
            );
            assert_eq!(
                100usize,
                (core::ptr::addr_of!(d.price2_as_string) as usize) - p,
                "price2_as_string offset expected {:} but was {:}",
                100usize,
                (core::ptr::addr_of!(d.price2_as_string) as usize) - p,
            );
        }
    }
}
