// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-25 15:25:42.126453 +0800 WITA m=+0.007296918

use super::*;
use crate::{message::parse, Connection, Error, Parsed};
use async_trait::async_trait;

#[async_trait]
pub trait Handler: Send + 'static {
    /// Requirements: Not required for Servers. Required for Clients if the Client
    /// needs to discover the encoding the Server uses.
    ///
    /// The EncodingRequestFixed message is a message requesting to change the
    /// DTC encoding for messages.
    ///
    /// For the procedure to work with this message, refer to Encoding Request
    /// Sequence.
    fn on_encoding_request(
        &self,
        conn: &Connection,
        msg: &impl EncodingRequest,
    ) -> Result<(), Error>;

    /// Requirements: Not required for Servers. Required for Clients if the Client
    /// needs to discover the encoding the Server uses.
    ///
    /// The EncodingRequestFixed message is a message requesting to change the
    /// DTC encoding for messages.
    ///
    /// For the procedure to work with this message, refer to Encoding Request
    /// Sequence.
    fn on_encoding_request_extended(
        &self,
        conn: &Connection,
        msg: &impl EncodingRequestExtended,
    ) -> Result<(), Error>;

    /// Requirements: Required for Servers. Required for Clients if the Client
    /// needs to discover the encoding the Server uses.
    ///
    /// The EncodingResponseFixed is a message from the Server to the Client,
    /// telling the Client what message encoding it must use to communicate with
    /// the Server.
    ///
    /// For the procedure to work with this message, refer to Encoding Request
    /// Sequence.
    fn on_encoding_response(
        &self,
        conn: &Connection,
        msg: &impl EncodingResponse,
    ) -> Result<(), Error>;

    /// The LogonRequestVLS message is sent from the Client to the Server requesting
    /// to logon to the Server.
    ///
    /// This is the very first message the Client sends to the Server before being
    /// allowed to send any other message other than the EncodingRequestFixed.
    fn on_logon_request(&self, conn: &Connection, msg: &impl LogonRequest) -> Result<(), Error>;

    /// This is a response message indicating either success or an error logging
    /// on to the Server.
    fn on_logon_response(&self, conn: &Connection, msg: &impl LogonResponse) -> Result<(), Error>;

    /// A LogoffVLS is a message which can be sent either by the Client or the
    /// Server to the other side. It indicates that the Client or the Server is
    /// logging off and going to be closing the connection.
    ///
    /// When one side receives this message, it should expect the connection will
    /// be closed. It should not be expected that any messages will follow the
    /// LogoffVLS message, and it should close the network connection and consider
    /// it finished. The side receiving this message can send a LogoffVLS message
    /// to the other side before closing the connection.
    fn on_logoff(&self, conn: &Connection, msg: &impl Logoff) -> Result<(), Error>;

    /// Both the Client and the Server need to send to the other side a heartbeat
    /// at the interval specified by the HeartbeatIntervalInSeconds member in
    /// the LogonRequestVLS.
    ///
    /// There are no required member fields to set in this message. The purpose
    /// of the HeartbeatFixed message is so that the Client or the Server can
    /// determine whether the other side is still connected.
    ///
    /// It is recommended that if there is a loss of HeartbeatFixed messages from
    /// the other side, for twice the amount of the HeartbeatIntervalInSeconds
    /// time that it is safe to assume that the other side is no longer present
    /// and the network socket should be then gracefully closed.
    ///
    /// The Server may choose to send a heartbeat message every second to the
    /// Client. In this particular case, it is recommended the Client use a minimum
    /// time of about 5 to 10 seconds without a heartbeat to determine the loss
    /// of the connection rather than the standard of twice the amount of the
    /// heartbeat time interval.
    fn on_heartbeat(&self, conn: &Connection, msg: &impl Heartbeat) -> Result<(), Error>;

    /// Both the Client and the Server need to send to the other side a heartbeat
    /// at the interval specified by the HeartbeatIntervalInSeconds member in
    /// the LogonRequestVLS.
    ///
    /// There are no required member fields to set in this message. The purpose
    /// of the HeartbeatFixed message is so that the Client or the Server can
    /// determine whether the other side is still connected.
    ///
    /// It is recommended that if there is a loss of HeartbeatFixed messages from
    /// the other side, for twice the amount of the HeartbeatIntervalInSeconds
    /// time that it is safe to assume that the other side is no longer present
    /// and the network socket should be then gracefully closed.
    ///
    /// The Server may choose to send a heartbeat message every second to the
    /// Client. In this particular case, it is recommended the Client use a minimum
    /// time of about 5 to 10 seconds without a heartbeat to determine the loss
    /// of the connection rather than the standard of twice the amount of the
    /// heartbeat time interval.
    fn on_heartbeat_extended(
        &self,
        conn: &Connection,
        msg: &impl HeartbeatExtended,
    ) -> Result<(), Error>;

    /// The s_MarketDataFeed_STATUS message is an optional message sent by the
    /// Server to indicate the overall status of the market data feed. This status
    /// applies to all symbols that have been subscribed to for market data.
    fn on_market_data_feed_status(
        &self,
        conn: &Connection,
        msg: &impl MarketDataFeedStatus,
    ) -> Result<(), Error>;

    fn on_market_data_feed_symbol_status(
        &self,
        conn: &Connection,
        msg: &impl MarketDataFeedSymbolStatus,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to indicate the status of the symbol
    /// in regards to whether trading is open or closed or some other intermediate
    /// state.
    fn on_trading_symbol_status(
        &self,
        conn: &Connection,
        msg: &impl TradingSymbolStatus,
    ) -> Result<(), Error>;

    /// The MarketDataRequestVLS message will subscribe to market data for a particular
    /// Symbol or request a market data snapshot.
    ///
    /// The Server can also send market depth data in response to this message
    /// and not require a MarketDepthRequestVLS.
    fn on_market_data_request(
        &self,
        conn: &Connection,
        msg: &impl MarketDataRequest,
    ) -> Result<(), Error>;

    fn on_market_depth_request(
        &self,
        conn: &Connection,
        msg: &impl MarketDepthRequest,
    ) -> Result<(), Error>;

    /// The MarketDataRejectVLS message is sent by the Server to the Client to
    /// reject a MarketDataRequestVLS message for any reason.
    fn on_market_data_reject(
        &self,
        conn: &Connection,
        msg: &impl MarketDataReject,
    ) -> Result<(), Error>;

    /// The Server sends the MarketDataSnapshotFixed message to the Client immediately
    /// after a successful MarketDataRequestVLS message has been received from
    /// the Client and it has indicated to subscribe to the symbol or requested
    /// the snapshot of data.
    ///
    /// Any changes to the data fields within the MarketDataSnapshotFixed message
    /// during the trading session will be sent by the Server to the Client through
    /// the corresponding MARKET_DATA_UPDATE_* messages.
    ///
    /// It is recommended that the MarketDataSnapshotFixed be sent by the Server
    /// at the start of a new trading session.
    ///
    /// This message can be sent more often, however it is not intended to be
    /// sent frequently.
    ///
    /// This message type does not signify a trade has occurred. It should never
    /// be interpreted by the Client in that way.
    ///
    /// There is no need to send this when there is a new High or Low during the
    /// trading session. The Server should use the MarketDataUpdateSessionHighFixed
    /// or MarketDataUpdateSessionLowFixed messages instead.
    fn on_market_data_snapshot(
        &self,
        conn: &Connection,
        msg: &impl MarketDataSnapshot,
    ) -> Result<(), Error>;

    /// This is a message sent by Server to provide the initial market depth data
    /// entries to the Client after the Client subscribes to market data or separately
    /// subscribes to market depth data. The Client will need to separately subscribe
    /// to market depth data if the Server requires it.
    ///
    /// Each message provides a single entry of depth data. Therefore, the Server
    /// will send multiple MarketDepthSnapshotLevelFixed messages in a series
    /// in order for the Client to build up its initial market depth book.
    ///
    /// The first message will be identified by the IsFirstMessageInBatch field
    /// being set to 1. The last message will be identified by the IsLastMessageInBatch
    /// field being set to 1.
    ///
    /// In the case where the market depth book is empty, the Server still needs
    /// to send through one single message with the SymbolID set, IsFirstMessageInBatch
    /// equal to 1 and IsLastMessageInBatch equal to 1. All other members will
    /// be at the default values. The Client will understand this as an empty
    /// book.
    fn on_market_depth_snapshot_level(
        &self,
        conn: &Connection,
        msg: &impl MarketDepthSnapshotLevel,
    ) -> Result<(), Error>;

    /// This is a message sent by Server to provide the initial market depth data
    /// entries to the Client after the Client subscribes to market data or separately
    /// subscribes to market depth data. The Client will need to separately subscribe
    /// to market depth data if the Server requires it.
    ///
    /// Each message provides a single entry of depth data. Therefore, the Server
    /// will send multiple MarketDepthSnapshotLevelFixedFloat messages in a series
    /// in order for the Client to build up its initial market depth book.
    ///
    /// The first message will be identified by the IsFirstMessageInBatch field
    /// being set to 1. The last message will be identified by the IsLastMessageInBatch
    /// field being set to 1.
    ///
    /// In the case where the market depth book is empty, the Server still needs
    /// to send through one single message with the SymbolID set, IsFirstMessageInBatch
    /// equal to 1 and IsLastMessageInBatch equal to 1. All other members will
    /// be at the default values. The Client will understand this as an empty
    /// book.
    fn on_market_depth_snapshot_level_float(
        &self,
        conn: &Connection,
        msg: &impl MarketDepthSnapshotLevelFloat,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to Update/Insert or Delete a particular
    /// market depth price level in the market depth book maintained by the Client.
    /// market depth price level in the market depth book maintained by the Client.
    ///
    /// Each MarketDepthUpdateLevelFixed message updates one level of market depth
    /// on one side. An insert/update/delete model is used for market depth.
    ///
    /// The Client will need to determine the based upon the price, what particular
    /// market depth level is being updated, inserted or deleted.
    ///
    /// It is for this reason, that an insert/update is considered as one update
    /// type since it is possible to determine whether it is an insert or update
    /// based upon the existence of the price level in the existing market depth
    /// book on the Client side.
    ///
    /// What this means is that when the UpdateType field is MARKET_DEPTH_INSERT_UPDATE_LEVEL,
    /// it is considered an insert if the price level is not found on the particular
    /// side of the market depth being updated. It is considered an update, if
    /// the price level is found on the particular side of market depth being
    /// updated.
    ///
    /// This message uses a double datatype for the Price field. There is no level
    /// index. It is the responsibility of the Client to determine where in its
    /// market depth array it is maintaining where the insert/update/delete operation
    /// needs to occur.
    ///
    /// Since floating-point comparisons are not always precise, there should
    /// be a comparison made only to the number of decimal places the symbol specifies
    /// in its security definition. This can be determined through the SecurityDefinitionResponseVLS::PriceDisplayFormat
    /// field.
    fn on_market_depth_update_level(
        &self,
        conn: &Connection,
        msg: &impl MarketDepthUpdateLevel,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to Update/Insert or Delete a particular
    /// market depth price level in the market depth book maintained by the Client.
    /// market depth price level in the market depth book maintained by the Client.
    ///
    /// This message is a more compact version of the MarketDepthUpdateLevelFixed
    /// message. For the Price and Quantity fields, it uses a 4 byte float for
    /// compactness. It also supports millisecond precision for the timestamp.
    fn on_market_depth_update_level_float_with_milliseconds(
        &self,
        conn: &Connection,
        msg: &impl MarketDepthUpdateLevelFloatWithMilliseconds,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to Update/Insert or Delete a particular
    /// market depth price level in the market depth book maintained by the Client.
    /// market depth price level in the market depth book maintained by the Client.
    ///
    /// This message is identical to the MarketDepthUpdateLevelFixed message except
    /// it has no timestamp field. It needs to be sent when there is no change
    /// with the timestamp for the market depth update as compared to the prior
    /// update.
    ///
    /// When the Server sends this message to the Client, the Client needs to
    /// use the prior received market depth update timestamp to know what the
    /// timestamp is for this message.
    fn on_market_depth_update_level_no_timestamp(
        &self,
        conn: &Connection,
        msg: &impl MarketDepthUpdateLevelNoTimestamp,
    ) -> Result<(), Error>;

    /// This message is optional.
    ///
    /// Sent by the Server to the Client when a trade occurs. This message is
    /// identical to the MarketDataUpdateTradeFixed_WITH_UNBUNDLED_INDICATOR_2
    /// message except it does not have a timestamp. It needs to be sent when
    /// there is no change with the timestamp for the trade as compared to the
    /// prior trade.
    ///
    /// When the Server sends this message to the Client, the Client needs to
    /// use the prior received trade timestamp to know what the timestamp is for
    /// this message.
    fn on_market_data_update_trade_no_timestamp(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateTradeNoTimestamp,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to update the session settlement price
    /// when the session settlement price changes.
    fn on_market_data_update_session_settlement(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateSessionSettlement,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to update the session Open.
    fn on_market_data_update_session_open(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateSessionOpen,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to update the trading session number
    /// of trades.
    fn on_market_data_update_session_num_trades(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateSessionNumTrades,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to update the trading session Date.
    fn on_market_data_update_trading_session_date(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateTradingSessionDate,
    ) -> Result<(), Error>;

    /// The MarketDepthRejectVLS message is sent by the Server to the Client to
    /// reject a MarketDepthRequestVLS message for any reason.
    fn on_market_depth_reject(
        &self,
        conn: &Connection,
        msg: &impl MarketDepthReject,
    ) -> Result<(), Error>;

    /// The Server sends this market data feed message to the Client when a trade
    /// occurs.
    fn on_market_data_update_trade(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateTrade,
    ) -> Result<(), Error>;

    fn on_market_data_update_trade_with_unbundled_indicator(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateTradeWithUnbundledIndicator,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client when a trade occurs. This message has
    /// additional fields as compared to the MarketDataUpdateTradeFixed message
    /// and also supports microsecond time stamping.
    fn on_market_data_update_trade_with_unbundled_indicator2(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateTradeWithUnbundledIndicator2,
    ) -> Result<(), Error>;

    /// The Server sends this market data feed message to the Client when the
    /// best bid or ask price or size changes.
    fn on_market_data_update_bid_ask(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateBidAsk,
    ) -> Result<(), Error>;

    fn on_market_data_update_bid_ask_compact(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateBidAskCompact,
    ) -> Result<(), Error>;

    /// This message is optional.
    ///
    /// Sent by the Server to the Client when there is an update to the Bid Ask
    /// prices and/or quantities. This message is identical to the MarketDataUpdateBidAskFixed
    /// message except it does not have a timestamp. It needs to be sent when
    /// there is no change with the timestamp for the Bid Ask update as compared
    /// to the prior update.
    ///
    /// When the Server sends this message to the Client, the Client needs to
    /// use the prior received Bid Ask update timestamp to know what the timestamp
    /// is for this message.
    fn on_market_data_update_bid_ask_float_with_microseconds(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateBidAskFloatWithMicroseconds,
    ) -> Result<(), Error>;

    /// This message is optional.
    ///
    /// Sent by the Server to the Client when there is an update to the Bid Ask
    /// prices and/or quantities. This message is identical to the MarketDataUpdateBidAskFixed
    /// message except it does not have a timestamp. It needs to be sent when
    /// there is no change with the timestamp for the Bid Ask update as compared
    /// to the prior update.
    ///
    /// When the Server sends this message to the Client, the Client needs to
    /// use the prior received Bid Ask update timestamp to know what the timestamp
    /// is for this message.
    fn on_market_data_update_bid_ask_no_time_stamp(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateBidAskNoTimeStamp,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client when a trade occurs. This message is
    /// a more compact MarketDataUpdateTradeFixed. For the price it uses a 4 byte
    /// float.
    fn on_market_data_update_trade_compact(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateTradeCompact,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client when the session trade Volume needs to
    /// be updated.
    ///
    /// The recommended rule for the Server to notify the Client of a change with
    /// the session trade volume to maintain bandwidth efficiency, is as follows:
    /// When a trade occurs for a symbol subscribed to, the Server will send a
    /// MarketDataUpdateTradeFixed message to the Client. The Client should then
    /// increment its session trade volume value for the symbol by the value in
    /// the Volume field in this message.
    ///
    /// The Server will assume the Client is doing this. Therefore, when a trade
    /// occurs and the session trade volume does not equal the prior session trade
    /// volume plus the Volume for the most recent trade sent to the Client, then
    /// the Server must send out a MarketDataUpdateSessionVolumeFixed message
    /// to the client since the client calculation of the session trade volume
    /// is no longer correct.
    ///
    /// It is assumed that the reason for this inconsistency is due to trades
    /// included within the session trade volume which have not been sent out
    /// as normal trades.
    ///
    /// The Server should also send this message out at the frequency that the
    /// Server determines, such as every minute if there also has been a trade
    /// at that time.
    fn on_market_data_update_session_volume(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateSessionVolume,
    ) -> Result<(), Error>;

    /// The MarketDataUpdateOpenInterestFixed message is sent by the Server to
    /// the Client to update the OpenInterest field previously sent through the
    /// MarketDataSnapshotFixed message.
    fn on_market_data_update_open_interest(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateOpenInterest,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to update the session High as the High
    /// price changes throughout the session.
    fn on_market_data_update_session_high(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateSessionHigh,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to update the session Low as the Low
    /// price changes throughout the session.
    fn on_market_data_update_session_low(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateSessionLow,
    ) -> Result<(), Error>;

    /// Sent by the Server to the Client to update the last trade price, volume
    /// and date-time fields under conditions when there is not a trade.
    ///
    /// This message type does not signify a trade has occurred. It should never
    /// be interpreted by the Client in that way.
    fn on_market_data_update_last_trade_snapshot(
        &self,
        conn: &Connection,
        msg: &impl MarketDataUpdateLastTradeSnapshot,
    ) -> Result<(), Error>;

    fn on_market_orders_request(
        &self,
        conn: &Connection,
        msg: &impl MarketOrdersRequest,
    ) -> Result<(), Error>;

    fn on_market_orders_reject(
        &self,
        conn: &Connection,
        msg: &impl MarketOrdersReject,
    ) -> Result<(), Error>;

    fn on_market_orders_add(
        &self,
        conn: &Connection,
        msg: &impl MarketOrdersAdd,
    ) -> Result<(), Error>;

    fn on_market_orders_modify(
        &self,
        conn: &Connection,
        msg: &impl MarketOrdersModify,
    ) -> Result<(), Error>;

    fn on_market_orders_remove(
        &self,
        conn: &Connection,
        msg: &impl MarketOrdersRemove,
    ) -> Result<(), Error>;

    fn on_market_orders_snapshot_message_boundary(
        &self,
        conn: &Connection,
        msg: &impl MarketOrdersSnapshotMessageBoundary,
    ) -> Result<(), Error>;

    /// This message is used to submit a new single order into the market from
    /// the Client to the Server.
    fn on_submit_new_single_order(
        &self,
        conn: &Connection,
        msg: &impl SubmitNewSingleOrder,
    ) -> Result<(), Error>;

    fn on_submit_flatten_position_order(
        &self,
        conn: &Connection,
        msg: &impl SubmitFlattenPositionOrder,
    ) -> Result<(), Error>;

    /// This message is sent by the Client to the Server to cancel and replace
    /// an existing order. This is also known as an order modification.
    ///
    /// When the cancel and replace operation is completed, an OrderUpdate message
    /// is sent by the Server with the OrderUpdateReasonfield set to ORDER_CANCEL_REPLACE_COMPLETE.
    /// If the cancel and replace operation cannot be completed, an OrderUpdate
    /// message is sent by the Server with the OrderUpdateReason set to ORDER_CANCEL_REPLACE_REJECTED.
    /// message is sent by the Server with the OrderUpdateReason set to ORDER_CANCEL_REPLACE_REJECTED.
    fn on_cancel_replace_order(
        &self,
        conn: &Connection,
        msg: &impl CancelReplaceOrder,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server requesting a previously
    /// sent order to be canceled.
    fn on_cancel_order(&self, conn: &Connection, msg: &impl CancelOrder) -> Result<(), Error>;

    /// This is a message from the Client to the Server for submitting an order
    /// cancels order (OCO) pair into the market. What this means is when one
    /// of the orders is filled or canceled, the other order will be canceled.
    /// If one order partially fills, the other order will be reduced in quantity
    /// by the fill amount of the order that partially filled.
    ///
    /// A service provider must implement OCO orders on the server so that they
    /// can independently be modified (Cancel/Replace) and canceled independently
    /// using each order's distinct ServerOrderID. Although, if one of the orders
    /// is canceled by the Client, the other order will be canceled as well unless
    /// they have a parent order, as specified through the ParentTriggerClientOrderID
    /// field, in which case the other order should remain open.
    ///
    /// If the OCO order pair is rejected, this must be communicated through two
    /// separate OrderUpdateVLS messages, 1 for each order, with the OrderUpdateReason
    /// set to NEW_ORDER_REJECTED.
    fn on_submit_new_oco_order(
        &self,
        conn: &Connection,
        msg: &impl SubmitNewOCOOrder,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server requesting the currently
    /// open orders.
    ///
    /// The Server will send open/working orders in response to this request through
    /// OrderUpdateVLS messages.
    ///
    /// The Server will not return canceled or filled orders.
    ///
    /// When the Server responds to this request, it needs to respond with a separate
    /// OrderUpdateVLS for each order.
    ///
    /// When the Server responds to this request, OrderUpdateReason in the OrderUpdateVLS
    /// message must be set to OpenOrdersRequestVLS_RESPONSE indicating the orders
    /// are being restated.
    ///
    /// If there are no Open orders, the Server will send back 1 OrderUpdateVLS
    /// message with only the TotalNumberMessages, MessageNumber, RequestID, OrderUpdateReason,
    /// NoOrders = 1 fields set in the OrderUpdateVLS message.
    fn on_open_orders_request(
        &self,
        conn: &Connection,
        msg: &impl OpenOrdersRequest,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server to request order fills/executions
    /// for an order or orders.
    fn on_historical_order_fills_request(
        &self,
        conn: &Connection,
        msg: &impl HistoricalOrderFillsRequest,
    ) -> Result<(), Error>;

    /// If the Server is unable to serve the request for a HistoricalOrderFillsRequestVLS
    /// message received, for a reason other than there not being any historical
    /// order fills, then send this message to the Client.
    fn on_historical_order_fills_reject(
        &self,
        conn: &Connection,
        msg: &impl HistoricalOrderFillsReject,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server to request the current
    /// open Trade Positions.
    fn on_current_positions_request(
        &self,
        conn: &Connection,
        msg: &impl CurrentPositionsRequest,
    ) -> Result<(), Error>;

    /// If the Server is unable to serve the request for an CurrentPositionsRequestVLS
    /// message received, for a reason other than there not being any current
    /// Trade positions, then send this message to the Client.
    ///
    /// This must never be sent when there are actually no Trade Positions in
    /// the account or accounts requested.
    fn on_current_positions_reject(
        &self,
        conn: &Connection,
        msg: &impl CurrentPositionsReject,
    ) -> Result<(), Error>;

    /// The OrderUpdateVLS is a unified message from the Server to the Client
    /// which communicates the complete details of an order, the Order Status,
    /// and the reason for sending the message (OrderUpdateReason).
    ///
    /// DTC uses this single unified message to provide an update for an order.
    /// The OrderUpdateReason field provides a clear indication for each reason
    /// this message is being sent.
    fn on_order_update(&self, conn: &Connection, msg: &impl OrderUpdate) -> Result<(), Error>;

    /// If the Server is unable to serve the request for an OpenOrdersRequestVLS
    /// message received, for a reason other than there not being any open orders,
    /// then send this message to the Client.
    fn on_open_orders_reject(
        &self,
        conn: &Connection,
        msg: &impl OpenOrdersReject,
    ) -> Result<(), Error>;

    /// This is a message from the Server to the Client providing an individual
    /// historical order fill in response to a HistoricalOrderFillsRequestVLS
    /// message.
    ///
    /// The Server is expected to send this message to the Client in response
    /// to a HistoricalOrderFillsRequestVLS message even when there are no order
    /// fills to return. If there are no order fills to return, it needs to set
    /// the NoOrderFills field to 1.
    fn on_historical_order_fill_response(
        &self,
        conn: &Connection,
        msg: &impl HistoricalOrderFillResponse,
    ) -> Result<(), Error>;

    /// This is a message from the Server to the Client to report a Trade Position
    /// for a symbol in any Trade Account for the logged in Username.
    ///
    /// The Position Update message can either be solicited, in response to CurrentPositionsRequestVLS.
    /// Or unsolicited as a Trade Position for a symbol changes during the connection
    /// to the Server. Each Trade Position is contained within a single message.
    /// to the Server. Each Trade Position is contained within a single message.
    ///
    /// When the server is responding with one or more PositionUpdateVLS messages
    /// in response to a CurrentPositionsRequestVLS message, it must not send
    /// any unsolicited PositionUpdateVLS messages interleaved with the solicited
    /// PositionUpdateVLS messages in response to the CurrentPositionsRequestVLS
    /// message.
    fn on_position_update(&self, conn: &Connection, msg: &impl PositionUpdate)
        -> Result<(), Error>;

    fn on_add_correcting_order_fill(
        &self,
        conn: &Connection,
        msg: &impl AddCorrectingOrderFill,
    ) -> Result<(), Error>;

    fn on_correcting_order_fill_response(
        &self,
        conn: &Connection,
        msg: &impl CorrectingOrderFillResponse,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server to request all of the
    /// account identifiers for the logged in Username.
    ///
    /// If there are no accounts available, then the Server needs to respond with
    /// at least one TradeAccountResponseVLS message containing an empty Trade
    /// Account.
    fn on_trade_accounts_request(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountsRequest,
    ) -> Result<(), Error>;

    /// This is a message from the Server to the Client in response to a TradeAccountsRequestFixed
    /// message, providing a single trade account. There is one message for each
    /// trade account.
    fn on_trade_account_response(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountResponse,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server to request a list of all
    /// available exchanges from the Server.
    ///
    /// The server will respond with a separate ExchangeListResponseVLS message
    /// for each exchange.
    ///
    /// In the case where the Server does not specify an exchange with its symbols,
    /// then the Server should provide a single response with an empty Exchange.
    /// then the Server should provide a single response with an empty Exchange.
    fn on_exchange_list_request(
        &self,
        conn: &Connection,
        msg: &impl ExchangeListRequest,
    ) -> Result<(), Error>;

    /// The server will return this message for each supported exchange.
    ///
    /// If there are no exchanges to return in response to a request, send through
    /// one of these messages with the RequestID set and IsFinalMessage = 1. Leave
    /// all other members in the default state and the Client will recognize there
    /// are no Exchanges.
    fn on_exchange_list_response(
        &self,
        conn: &Connection,
        msg: &impl ExchangeListResponse,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server to request all of the
    /// Symbols for a particular Exchange.
    ///
    /// The server will return a SecurityDefinitionResponseVLS message to the
    /// Client for each Symbol returned.
    ///
    /// If the Server is rejecting this request, then it needs to send a SecurityDefinitionRejectVLS
    /// message to the Client.
    fn on_symbols_for_exchange_request(
        &self,
        conn: &Connection,
        msg: &impl SymbolsForExchangeRequest,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server to request all of the
    /// underlying symbols on a particular Exchange. For example, all of the underlying
    /// futures symbols on a particular Exchange.
    ///
    /// The server will return a SecurityDefinitionResponseVLS message to the
    /// Client for each Symbol returned.
    ///
    /// If the Server is rejecting this request, then it needs to send a SecurityDefinitionRejectVLS
    /// message to the Client.
    fn on_underlying_symbols_for_exchange_request(
        &self,
        conn: &Connection,
        msg: &impl UnderlyingSymbolsForExchangeRequest,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server for requesting all of
    /// the symbols for a particular underlying symbol.
    ///
    /// For example, all of the futures contracts for a particular underlying
    /// futures symbol or all of the option symbols for a specific futures or
    /// stock symbol.
    ///
    /// The server will return a SecurityDefinitionResponseVLS message to the
    /// Client for each Symbol returned.
    ///
    /// If the Server is rejecting this request, then it needs to send a SecurityDefinitionRejectVLS
    /// message to the Client.
    fn on_symbols_for_underlying_request(
        &self,
        conn: &Connection,
        msg: &impl SymbolsForUnderlyingRequest,
    ) -> Result<(), Error>;

    /// The SymbolSearchRequestVLS message is sent by the Client to the Server
    /// to return Security Definitions matching the specified SecurityType and
    /// Exchange and where the Symbol or Description contains the specified SearchText.
    /// Exchange and where the Symbol or Description contains the specified SearchText.
    ///
    /// The SearchText can search either the Symbol or the Description field in
    /// the SecurityDefinitionResponseVLS message.
    ///
    /// In either case there does not need to be an exact match. The SearchText
    /// only needs to be contained within the Symbol or the Description depending
    /// upon which field is being searched.
    ///
    /// The Server returns SecurityDefinitionResponseVLS messages for all Symbols
    /// which match.
    ///
    /// If there are no matches, the Server needs to send a SecurityDefinitionResponseVLS
    /// message to the Client with with all fields at their default values except
    /// for the RequestID and IsFinalMessage fields set. This will be a clear
    /// indication to the Client that the request returned no matches.
    ///
    /// If the Server is rejecting this request, then it needs to send a SecurityDefinitionRejectVLS
    /// message to the Client.
    fn on_symbol_search_request(
        &self,
        conn: &Connection,
        msg: &impl SymbolSearchRequest,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server for requesting Security
    /// Definition data for a specific symbol.
    ///
    /// The Server will return a single SecurityDefinitionResponseVLS message
    /// in response to this request.
    ///
    /// The Client must always send a SecurityDefinitionForSymbolRequestVLS message
    /// to the Server in order to obtain the IntegerToFloatPriceDivisor value
    /// in case the Server uses the integer market data messages.
    ///
    /// If the Server is rejecting this request, then it needs to send a SecurityDefinitionRejectVLS
    /// message to the Client.
    fn on_security_definition_for_symbol_request(
        &self,
        conn: &Connection,
        msg: &impl SecurityDefinitionForSymbolRequest,
    ) -> Result<(), Error>;

    /// This is a response from the Server in response to a SymbolsForExchangeRequestVLS,
    /// UNDERLYING_SymbolsForExchangeRequestVLS, SymbolsForUnderlyingRequestVLS,
    /// SecurityDefinitionForSymbolRequestVLS, SymbolSearchRequestVLS message.
    ///
    /// If there are no symbols to return in response to a request, the Server
    /// needs to send through one of these messages with the RequestID set to
    /// the same RequestID value that the request message set it to, and IsFinalMessage
    /// = 1. Leave all other member fields in the default state and the Client
    /// will recognize there are no symbols.
    ///
    /// The Client must always send a SecurityDefinitionForSymbolRequestVLS message
    /// to the Server to obtain the IntegerToFloatPriceDivisor and FloatToIntPriceMultiplier
    /// values in the Security Definition Response message when the Server uses
    /// the integer market data and order messages.
    fn on_security_definition_response(
        &self,
        conn: &Connection,
        msg: &impl SecurityDefinitionResponse,
    ) -> Result<(), Error>;

    /// This is a message from the Server to the Client indicating the Server
    /// is rejecting one of the following messages: SymbolsForExchangeRequestVLS,
    /// UnderlyingSymbolsForExchangeRequestVLS, SymbolsForUnderlyingRequestVLS,
    /// SecurityDefinitionForSymbolRequestVLS, SymbolSearchRequestVLS.
    ///
    /// If there are no symbols to send in response to one of these messages above,
    /// then the Server should not send a SecurityDefinitionRejectVLS message
    /// and instead send a SecurityDefinitionResponseVLS with only the RequestID
    /// and IsFinalMessage fields set. This will be a clear indication to the
    /// Client that the request returned no Symbols.
    fn on_security_definition_reject(
        &self,
        conn: &Connection,
        msg: &impl SecurityDefinitionReject,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server to request Trade Account
    /// Balance data.
    ///
    /// The Server will respond with an AccountBalanceUpdateVLS or reject the
    /// request.
    ///
    /// The Server will set the RequestID in the AccountBalanceUpdateVLS message
    /// to match the RequestID in the AccountBalanceRequestVLS.
    ///
    /// The Server will periodically send AccountBalanceUpdateVLS messages as
    /// the Account Balance data changes. The frequency of the updates is determined
    /// by the Server. Account Balance updates are considered automatically subscribed
    /// to. When unsolicited AccountBalanceUpdateVLS messages are sent by the
    /// Server, the RequestID will be 0.
    fn on_account_balance_request(
        &self,
        conn: &Connection,
        msg: &impl AccountBalanceRequest,
    ) -> Result<(), Error>;

    fn on_account_balance_reject(
        &self,
        conn: &Connection,
        msg: &impl AccountBalanceReject,
    ) -> Result<(), Error>;

    /// This is an optional message from the Server to Client to provide Account
    /// Balance information for a particular Trade Account. The server needs to
    /// provide a separate message for each Trade Account associated with the
    /// logged in username if it supports Account Balance updates.
    ///
    /// The Server will respond with an AccountBalanceUpdateVLS in response to
    /// a AccountBalanceRequestVLS message. The Server will set the RequestID
    /// in the AccountBalanceUpdateVLS message to match the RequestID in the AccountBalanceRequestVLS
    /// message.
    ///
    /// The Server will periodically send AccountBalanceUpdateVLS messages as
    /// the Account Balance data changes. The frequency of the updates is determined
    /// by the Server. Account Balance updates are considered automatically subscribed
    /// to. When an unsolicited AccountBalanceUpdateVLS message is sent, the RequestID
    /// field will be 0.
    ///
    /// When the server is responding with one or more AccountBalanceUpdateVLS
    /// messages in response to a AccountBalanceRequestVLS message, it must not
    /// send any unsolicited AccountBalanceUpdateVLS messages interleaved with
    /// the solicited AccountBalanceUpdateVLS messages in response to the AccountBalanceRequestVLS
    /// message.
    fn on_account_balance_update(
        &self,
        conn: &Connection,
        msg: &impl AccountBalanceUpdate,
    ) -> Result<(), Error>;

    fn on_account_balance_adjustment(
        &self,
        conn: &Connection,
        msg: &impl AccountBalanceAdjustment,
    ) -> Result<(), Error>;

    fn on_account_balance_adjustment_reject(
        &self,
        conn: &Connection,
        msg: &impl AccountBalanceAdjustmentReject,
    ) -> Result<(), Error>;

    fn on_account_balance_adjustment_complete(
        &self,
        conn: &Connection,
        msg: &impl AccountBalanceAdjustmentComplete,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server to request a history of
    /// Cash Balance changes for the specified Trade Account.
    ///
    /// The Server will respond with multiple HISTORICAL_ACCOUNT_BALANCE_RESPONSE
    /// messages or reject he request with a message.
    ///
    /// The Server will set the RequestID in the HISTORICAL_ACCOUNT_BALANCE_RESPONSE
    /// message to match the RequestID in the HistoricalAccountBalancesRequestVLS.
    /// message to match the RequestID in the HistoricalAccountBalancesRequestVLS.
    fn on_historical_account_balances_request(
        &self,
        conn: &Connection,
        msg: &impl HistoricalAccountBalancesRequest,
    ) -> Result<(), Error>;

    /// This is a message from the Server to the Client to reject a HistoricalAccountBalancesRequestVLS
    /// request.
    fn on_historical_account_balances_reject(
        &self,
        conn: &Connection,
        msg: &impl HistoricalAccountBalancesReject,
    ) -> Result<(), Error>;

    fn on_historical_account_balance_response(
        &self,
        conn: &Connection,
        msg: &impl HistoricalAccountBalanceResponse,
    ) -> Result<(), Error>;

    /// This message from the Server to the Client is for providing a message
    /// to the user.
    ///
    /// This message can be sent even before a LogonResponseVLS.
    fn on_user_message(&self, conn: &Connection, msg: &impl UserMessage) -> Result<(), Error>;

    /// This message from the Server to the Client is a message which is to be
    /// added to a log file indicating information from the server. For example,
    /// if there are informational messages to provide during the process of a
    /// logon, this can be used to send those messages to a Client. A Client should
    /// never implement this message as a pop-up type message. Instead, it should
    /// be treated as a lower-level log type message.
    ///
    /// This message can be sent even before a LogonResponseVLS is given.
    fn on_general_log_message(
        &self,
        conn: &Connection,
        msg: &impl GeneralLogMessage,
    ) -> Result<(), Error>;

    fn on_alert_message(&self, conn: &Connection, msg: &impl AlertMessage) -> Result<(), Error>;

    fn on_journal_entry_add(
        &self,
        conn: &Connection,
        msg: &impl JournalEntryAdd,
    ) -> Result<(), Error>;

    fn on_journal_entries_request(
        &self,
        conn: &Connection,
        msg: &impl JournalEntriesRequest,
    ) -> Result<(), Error>;

    fn on_journal_entries_reject(
        &self,
        conn: &Connection,
        msg: &impl JournalEntriesReject,
    ) -> Result<(), Error>;

    fn on_journal_entry_response(
        &self,
        conn: &Connection,
        msg: &impl JournalEntryResponse,
    ) -> Result<(), Error>;

    /// This is a message from the Client to the Server for requesting historical
    /// price data.
    ///
    /// This request can be on the same or a separate network socket connection
    /// compared to the streaming market data. This is going to be specified by
    /// the Server.
    fn on_historical_price_data_request(
        &self,
        conn: &Connection,
        msg: &impl HistoricalPriceDataRequest,
    ) -> Result<(), Error>;

    /// When a historical price data request is not rejected, this message header
    /// will begin the historical price data response from the Server. There will
    /// be one HistoricalPriceDataResponseHeaderFixed message sent ahead of the
    /// HistoricalPriceDataRecordResponseFixed / HistoricalPriceDataTickRecordResponseFixed
    /// messages. If the NoRecordsToReturn field is nonzero, then there are no
    /// further records that will be sent by the Server in response to the request
    /// by the Client.
    ///
    /// This message is never compressed.
    fn on_historical_price_data_response_header(
        &self,
        conn: &Connection,
        msg: &impl HistoricalPriceDataResponseHeader,
    ) -> Result<(), Error>;

    /// When the Server rejects a historical price data request from the Client,
    /// a HistoricalPriceDataRejectVLS message will be sent.
    ///
    /// This message is never compressed.
    fn on_historical_price_data_reject(
        &self,
        conn: &Connection,
        msg: &impl HistoricalPriceDataReject,
    ) -> Result<(), Error>;

    /// The HistoricalPriceDataTickRecordResponseFixed message is used when the
    /// RecordInterval field in a historical data request message is set to a
    /// value greater than INTERVAL_TICK. For example, if the RecordInterval is
    /// INTERVAL_1_MINUTE, then a message of this type will contain data for a
    /// 1 minute timeframe with a start time specified by the StartDateTime field.
    /// 1 minute timeframe with a start time specified by the StartDateTime field.
    ///
    /// Even when RecordInterval is INTERVAL_TICK, the HistoricalPriceDataTickRecordResponseFixed
    /// message can still be used instead of HistoricalPriceDataTickRecordResponseFixed.
    /// message can still be used instead of HistoricalPriceDataTickRecordResponseFixed.
    ///
    /// This message can be part of a compressed series of messages of this same
    /// type, if the Client requested compression be used.
    fn on_historical_price_data_record_response(
        &self,
        conn: &Connection,
        msg: &impl HistoricalPriceDataRecordResponse,
    ) -> Result<(), Error>;

    /// This is the response message when the RecordInterval field in a historical
    /// data request message is set to INTERVAL_TICK.
    ///
    /// If the Server does not support 1 Tick historical data or does not have
    /// 1 Tick historical data for the specified time period, it can respond with
    /// HistoricalPriceDataRecordResponseFixed messages instead. The Server must
    /// only respond with messages of one type in response to a particular historical
    /// price data request.
    ///
    /// This message can be part of a compressed series of messages of this same
    /// type, if the Client requested compression be used.
    fn on_historical_price_data_tick_record_response(
        &self,
        conn: &Connection,
        msg: &impl HistoricalPriceDataTickRecordResponse,
    ) -> Result<(), Error>;

    fn on_historical_price_data_response_trailer(
        &self,
        conn: &Connection,
        msg: &impl HistoricalPriceDataResponseTrailer,
    ) -> Result<(), Error>;

    fn on_historical_market_depth_data_request(
        &self,
        conn: &Connection,
        msg: &impl HistoricalMarketDepthDataRequest,
    ) -> Result<(), Error>;

    fn on_historical_market_depth_data_response_header(
        &self,
        conn: &Connection,
        msg: &impl HistoricalMarketDepthDataResponseHeader,
    ) -> Result<(), Error>;

    fn on_historical_market_depth_data_reject(
        &self,
        conn: &Connection,
        msg: &impl HistoricalMarketDepthDataReject,
    ) -> Result<(), Error>;

    fn on_historical_market_depth_data_record_response(
        &self,
        conn: &Connection,
        msg: &impl HistoricalMarketDepthDataRecordResponse,
    ) -> Result<(), Error>;

    fn on_historical_trades_request(
        &self,
        conn: &Connection,
        msg: &impl HistoricalTradesRequest,
    ) -> Result<(), Error>;

    fn on_historical_trades_reject(
        &self,
        conn: &Connection,
        msg: &impl HistoricalTradesReject,
    ) -> Result<(), Error>;

    fn on_historical_trades_response(
        &self,
        conn: &Connection,
        msg: &impl HistoricalTradesResponse,
    ) -> Result<(), Error>;

    fn on_replay_chart_data(
        &self,
        conn: &Connection,
        msg: &impl ReplayChartData,
    ) -> Result<(), Error>;

    fn on_replay_chart_data_perform_action(
        &self,
        conn: &Connection,
        msg: &impl ReplayChartDataPerformAction,
    ) -> Result<(), Error>;

    fn on_replay_chart_data_status(
        &self,
        conn: &Connection,
        msg: &impl ReplayChartDataStatus,
    ) -> Result<(), Error>;

    fn on_request_num_current_client_connections(
        &self,
        conn: &Connection,
        msg: &impl RequestNumCurrentClientConnections,
    ) -> Result<(), Error>;

    fn on_num_current_client_connections_response(
        &self,
        conn: &Connection,
        msg: &impl NumCurrentClientConnectionsResponse,
    ) -> Result<(), Error>;

    fn on_client_device_update(
        &self,
        conn: &Connection,
        msg: &impl ClientDeviceUpdate,
    ) -> Result<(), Error>;

    fn on_interprocess_synchronization_remote_state(
        &self,
        conn: &Connection,
        msg: &impl InterprocessSynchronizationRemoteState,
    ) -> Result<(), Error>;

    fn on_interprocess_synchronization_snapshot_request(
        &self,
        conn: &Connection,
        msg: &impl InterprocessSynchronizationSnapshotRequest,
    ) -> Result<(), Error>;

    fn on_interprocess_synchronization_trade_activity_request(
        &self,
        conn: &Connection,
        msg: &impl InterprocessSynchronizationTradeActivityRequest,
    ) -> Result<(), Error>;

    fn on_write_intraday_data_file_session_value(
        &self,
        conn: &Connection,
        msg: &impl WriteIntradayDataFileSessionValue,
    ) -> Result<(), Error>;

    fn on_sc_configuration_synchronization(
        &self,
        conn: &Connection,
        msg: &impl SCConfigurationSynchronization,
    ) -> Result<(), Error>;

    fn on_download_historical_order_fill_and_account_balance_data(
        &self,
        conn: &Connection,
        msg: &impl DownloadHistoricalOrderFillAndAccountBalanceData,
    ) -> Result<(), Error>;

    fn on_trade_order(&self, conn: &Connection, msg: &impl TradeOrder) -> Result<(), Error>;

    fn on_individual_trade_position(
        &self,
        conn: &Connection,
        msg: &impl IndividualTradePosition,
    ) -> Result<(), Error>;

    fn on_trade_position_consolidated(
        &self,
        conn: &Connection,
        msg: &impl TradePositionConsolidated,
    ) -> Result<(), Error>;

    fn on_trade_activity_data(
        &self,
        conn: &Connection,
        msg: &impl TradeActivityData,
    ) -> Result<(), Error>;

    fn on_trade_account_data_request(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataRequest,
    ) -> Result<(), Error>;

    fn on_trade_account_data_response(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataResponse,
    ) -> Result<(), Error>;

    fn on_trade_account_data_update(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataUpdate,
    ) -> Result<(), Error>;

    fn on_trade_account_data_delete(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataDelete,
    ) -> Result<(), Error>;

    fn on_trade_account_data_symbol_limits_response(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataSymbolLimitsResponse,
    ) -> Result<(), Error>;

    fn on_trade_account_data_symbol_limits_update(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataSymbolLimitsUpdate,
    ) -> Result<(), Error>;

    fn on_trade_account_data_symbol_commission_response(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataSymbolCommissionResponse,
    ) -> Result<(), Error>;

    fn on_trade_account_data_symbol_commission_update(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataSymbolCommissionUpdate,
    ) -> Result<(), Error>;

    fn on_trade_account_data_authorized_username_response(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataAuthorizedUsernameResponse,
    ) -> Result<(), Error>;

    fn on_trade_account_data_authorized_username_add(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataAuthorizedUsernameAdd,
    ) -> Result<(), Error>;

    fn on_trade_account_data_authorized_username_remove(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataAuthorizedUsernameRemove,
    ) -> Result<(), Error>;

    fn on_trade_account_data_username_to_share_with_response(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataUsernameToShareWithResponse,
    ) -> Result<(), Error>;

    fn on_trade_account_data_username_to_share_with_add(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataUsernameToShareWithAdd,
    ) -> Result<(), Error>;

    fn on_trade_account_data_username_to_share_with_remove(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataUsernameToShareWithRemove,
    ) -> Result<(), Error>;

    fn on_trade_account_data_response_trailer(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataResponseTrailer,
    ) -> Result<(), Error>;

    fn on_trade_account_data_update_operation_complete(
        &self,
        conn: &Connection,
        msg: &impl TradeAccountDataUpdateOperationComplete,
    ) -> Result<(), Error>;

    fn on_processed_fill_identifier(
        &self,
        conn: &Connection,
        msg: &impl ProcessedFillIdentifier,
    ) -> Result<(), Error>;

    fn on_flatten_positions_for_trade_account(
        &self,
        conn: &Connection,
        msg: &impl FlattenPositionsForTradeAccount,
    ) -> Result<(), Error>;

    fn on_user_information(
        &self,
        conn: &Connection,
        msg: &impl UserInformation,
    ) -> Result<(), Error>;

    fn on_margin_data_request(
        &self,
        conn: &Connection,
        msg: &impl MarginDataRequest,
    ) -> Result<(), Error>;

    fn on_margin_data_response(
        &self,
        conn: &Connection,
        msg: &impl MarginDataResponse,
    ) -> Result<(), Error>;

    fn on_unknown_message(&self, code: u16, data: &[u8]) -> Result<(), Error>;
}

#[inline]
pub fn handle<F: Factory, H: Handler>(
    handler: &H,
    data: &[u8],
    conn: &crate::Connection,
) -> Result<(), Error> {
    if data.len() < 4
        || (unsafe { u16::from_le(*(data[0..2].as_ptr() as *const u16)) } as usize) != data.len()
    {
        return Err(Error::Malformed(""));
    }
    let r#type = unsafe { u16::from_le(*(data[2..].as_ptr() as *const u16)) };
    match r#type {
        ENCODING_REQUEST => {
            if data.len() > 16 {
                match parse::<F::EncodingRequestExtended, F::EncodingRequestExtendedUnsafe>(data)? {
                    Parsed::Left(m) => handler.on_encoding_request_extended(conn, m),
                    Parsed::Right(m) => handler.on_encoding_request_extended(conn, m),
                }
            } else {
                match parse::<F::EncodingRequest, F::EncodingRequestUnsafe>(data)? {
                    Parsed::Left(m) => handler.on_encoding_request(conn, m),
                    Parsed::Right(m) => handler.on_encoding_request(conn, m),
                }
            }
        }
        ENCODING_RESPONSE => match parse::<F::EncodingResponse, F::EncodingResponseUnsafe>(data)? {
            Parsed::Left(m) => handler.on_encoding_response(conn, m),
            Parsed::Right(m) => handler.on_encoding_response(conn, m),
        },
        LOGON_REQUEST => match parse::<F::LogonRequest, F::LogonRequestUnsafe>(data)? {
            Parsed::Left(m) => handler.on_logon_request(conn, m),
            Parsed::Right(m) => handler.on_logon_request(conn, m),
        },
        LOGON_RESPONSE => match parse::<F::LogonResponse, F::LogonResponseUnsafe>(data)? {
            Parsed::Left(m) => handler.on_logon_response(conn, m),
            Parsed::Right(m) => handler.on_logon_response(conn, m),
        },
        LOGOFF => match parse::<F::Logoff, F::LogoffUnsafe>(data)? {
            Parsed::Left(m) => handler.on_logoff(conn, m),
            Parsed::Right(m) => handler.on_logoff(conn, m),
        },
        HEARTBEAT => {
            if data.len() > 16 {
                match parse::<F::HeartbeatExtended, F::HeartbeatExtendedUnsafe>(data)? {
                    Parsed::Left(m) => handler.on_heartbeat_extended(conn, m),
                    Parsed::Right(m) => handler.on_heartbeat_extended(conn, m),
                }
            } else {
                match parse::<F::Heartbeat, F::HeartbeatUnsafe>(data)? {
                    Parsed::Left(m) => handler.on_heartbeat(conn, m),
                    Parsed::Right(m) => handler.on_heartbeat(conn, m),
                }
            }
        }
        MARKET_DATA_FEED_STATUS => {
            match parse::<F::MarketDataFeedStatus, F::MarketDataFeedStatusUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_data_feed_status(conn, m),
                Parsed::Right(m) => handler.on_market_data_feed_status(conn, m),
            }
        }
        MARKET_DATA_FEED_SYMBOL_STATUS => {
            match parse::<F::MarketDataFeedSymbolStatus, F::MarketDataFeedSymbolStatusUnsafe>(data)?
            {
                Parsed::Left(m) => handler.on_market_data_feed_symbol_status(conn, m),
                Parsed::Right(m) => handler.on_market_data_feed_symbol_status(conn, m),
            }
        }
        TRADING_SYMBOL_STATUS => {
            match parse::<F::TradingSymbolStatus, F::TradingSymbolStatusUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trading_symbol_status(conn, m),
                Parsed::Right(m) => handler.on_trading_symbol_status(conn, m),
            }
        }
        MARKET_DATA_REQUEST => {
            match parse::<F::MarketDataRequest, F::MarketDataRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_data_request(conn, m),
                Parsed::Right(m) => handler.on_market_data_request(conn, m),
            }
        }
        MARKET_DEPTH_REQUEST => {
            match parse::<F::MarketDepthRequest, F::MarketDepthRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_depth_request(conn, m),
                Parsed::Right(m) => handler.on_market_depth_request(conn, m),
            }
        }
        MARKET_DATA_REJECT => {
            match parse::<F::MarketDataReject, F::MarketDataRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_data_reject(conn, m),
                Parsed::Right(m) => handler.on_market_data_reject(conn, m),
            }
        }
        MARKET_DATA_SNAPSHOT => {
            match parse::<F::MarketDataSnapshot, F::MarketDataSnapshotUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_data_snapshot(conn, m),
                Parsed::Right(m) => handler.on_market_data_snapshot(conn, m),
            }
        }
        MARKET_DEPTH_SNAPSHOT_LEVEL => {
            match parse::<F::MarketDepthSnapshotLevel, F::MarketDepthSnapshotLevelUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_depth_snapshot_level(conn, m),
                Parsed::Right(m) => handler.on_market_depth_snapshot_level(conn, m),
            }
        }
        MARKET_DEPTH_SNAPSHOT_LEVEL_FLOAT => {
            match parse::<F::MarketDepthSnapshotLevelFloat, F::MarketDepthSnapshotLevelFloatUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_market_depth_snapshot_level_float(conn, m),
                Parsed::Right(m) => handler.on_market_depth_snapshot_level_float(conn, m),
            }
        }
        MARKET_DEPTH_UPDATE_LEVEL => {
            match parse::<F::MarketDepthUpdateLevel, F::MarketDepthUpdateLevelUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_depth_update_level(conn, m),
                Parsed::Right(m) => handler.on_market_depth_update_level(conn, m),
            }
        }
        MARKET_DEPTH_UPDATE_LEVEL_FLOAT_WITH_MILLISECONDS => match parse::<
            F::MarketDepthUpdateLevelFloatWithMilliseconds,
            F::MarketDepthUpdateLevelFloatWithMillisecondsUnsafe,
        >(data)?
        {
            Parsed::Left(m) => {
                handler.on_market_depth_update_level_float_with_milliseconds(conn, m)
            }
            Parsed::Right(m) => {
                handler.on_market_depth_update_level_float_with_milliseconds(conn, m)
            }
        },
        MARKET_DEPTH_UPDATE_LEVEL_NO_TIMESTAMP => match parse::<
            F::MarketDepthUpdateLevelNoTimestamp,
            F::MarketDepthUpdateLevelNoTimestampUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_market_depth_update_level_no_timestamp(conn, m),
            Parsed::Right(m) => handler.on_market_depth_update_level_no_timestamp(conn, m),
        },
        MARKET_DATA_UPDATE_TRADE_NO_TIMESTAMP => match parse::<
            F::MarketDataUpdateTradeNoTimestamp,
            F::MarketDataUpdateTradeNoTimestampUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_market_data_update_trade_no_timestamp(conn, m),
            Parsed::Right(m) => handler.on_market_data_update_trade_no_timestamp(conn, m),
        },
        MARKET_DATA_UPDATE_SESSION_SETTLEMENT => match parse::<
            F::MarketDataUpdateSessionSettlement,
            F::MarketDataUpdateSessionSettlementUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_market_data_update_session_settlement(conn, m),
            Parsed::Right(m) => handler.on_market_data_update_session_settlement(conn, m),
        },
        MARKET_DATA_UPDATE_SESSION_OPEN => {
            match parse::<F::MarketDataUpdateSessionOpen, F::MarketDataUpdateSessionOpenUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_market_data_update_session_open(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_session_open(conn, m),
            }
        }
        MARKET_DATA_UPDATE_SESSION_NUM_TRADES => match parse::<
            F::MarketDataUpdateSessionNumTrades,
            F::MarketDataUpdateSessionNumTradesUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_market_data_update_session_num_trades(conn, m),
            Parsed::Right(m) => handler.on_market_data_update_session_num_trades(conn, m),
        },
        MARKET_DATA_UPDATE_TRADING_SESSION_DATE => match parse::<
            F::MarketDataUpdateTradingSessionDate,
            F::MarketDataUpdateTradingSessionDateUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_market_data_update_trading_session_date(conn, m),
            Parsed::Right(m) => handler.on_market_data_update_trading_session_date(conn, m),
        },
        MARKET_DEPTH_REJECT => {
            match parse::<F::MarketDepthReject, F::MarketDepthRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_depth_reject(conn, m),
                Parsed::Right(m) => handler.on_market_depth_reject(conn, m),
            }
        }
        MARKET_DATA_UPDATE_TRADE => {
            match parse::<F::MarketDataUpdateTrade, F::MarketDataUpdateTradeUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_data_update_trade(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_trade(conn, m),
            }
        }
        MARKET_DATA_UPDATE_TRADE_WITH_UNBUNDLED_INDICATOR => match parse::<
            F::MarketDataUpdateTradeWithUnbundledIndicator,
            F::MarketDataUpdateTradeWithUnbundledIndicatorUnsafe,
        >(data)?
        {
            Parsed::Left(m) => {
                handler.on_market_data_update_trade_with_unbundled_indicator(conn, m)
            }
            Parsed::Right(m) => {
                handler.on_market_data_update_trade_with_unbundled_indicator(conn, m)
            }
        },
        MARKET_DATA_UPDATE_TRADE_WITH_UNBUNDLED_INDICATOR_2 => match parse::<
            F::MarketDataUpdateTradeWithUnbundledIndicator2,
            F::MarketDataUpdateTradeWithUnbundledIndicator2Unsafe,
        >(data)?
        {
            Parsed::Left(m) => {
                handler.on_market_data_update_trade_with_unbundled_indicator2(conn, m)
            }
            Parsed::Right(m) => {
                handler.on_market_data_update_trade_with_unbundled_indicator2(conn, m)
            }
        },
        MARKET_DATA_UPDATE_BID_ASK => {
            match parse::<F::MarketDataUpdateBidAsk, F::MarketDataUpdateBidAskUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_data_update_bid_ask(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_bid_ask(conn, m),
            }
        }
        MARKET_DATA_UPDATE_BID_ASK_COMPACT => {
            match parse::<F::MarketDataUpdateBidAskCompact, F::MarketDataUpdateBidAskCompactUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_market_data_update_bid_ask_compact(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_bid_ask_compact(conn, m),
            }
        }
        MARKET_DATA_UPDATE_BID_ASK_FLOAT_WITH_MICROSECONDS => match parse::<
            F::MarketDataUpdateBidAskFloatWithMicroseconds,
            F::MarketDataUpdateBidAskFloatWithMicrosecondsUnsafe,
        >(data)?
        {
            Parsed::Left(m) => {
                handler.on_market_data_update_bid_ask_float_with_microseconds(conn, m)
            }
            Parsed::Right(m) => {
                handler.on_market_data_update_bid_ask_float_with_microseconds(conn, m)
            }
        },
        MARKET_DATA_UPDATE_BID_ASK_NO_TIMESTAMP => match parse::<
            F::MarketDataUpdateBidAskNoTimeStamp,
            F::MarketDataUpdateBidAskNoTimeStampUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_market_data_update_bid_ask_no_time_stamp(conn, m),
            Parsed::Right(m) => handler.on_market_data_update_bid_ask_no_time_stamp(conn, m),
        },
        MARKET_DATA_UPDATE_TRADE_COMPACT => {
            match parse::<F::MarketDataUpdateTradeCompact, F::MarketDataUpdateTradeCompactUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_market_data_update_trade_compact(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_trade_compact(conn, m),
            }
        }
        MARKET_DATA_UPDATE_SESSION_VOLUME => {
            match parse::<F::MarketDataUpdateSessionVolume, F::MarketDataUpdateSessionVolumeUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_market_data_update_session_volume(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_session_volume(conn, m),
            }
        }
        MARKET_DATA_UPDATE_OPEN_INTEREST => {
            match parse::<F::MarketDataUpdateOpenInterest, F::MarketDataUpdateOpenInterestUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_market_data_update_open_interest(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_open_interest(conn, m),
            }
        }
        MARKET_DATA_UPDATE_SESSION_HIGH => {
            match parse::<F::MarketDataUpdateSessionHigh, F::MarketDataUpdateSessionHighUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_market_data_update_session_high(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_session_high(conn, m),
            }
        }
        MARKET_DATA_UPDATE_SESSION_LOW => {
            match parse::<F::MarketDataUpdateSessionLow, F::MarketDataUpdateSessionLowUnsafe>(data)?
            {
                Parsed::Left(m) => handler.on_market_data_update_session_low(conn, m),
                Parsed::Right(m) => handler.on_market_data_update_session_low(conn, m),
            }
        }
        MARKET_DATA_UPDATE_LAST_TRADE_SNAPSHOT => match parse::<
            F::MarketDataUpdateLastTradeSnapshot,
            F::MarketDataUpdateLastTradeSnapshotUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_market_data_update_last_trade_snapshot(conn, m),
            Parsed::Right(m) => handler.on_market_data_update_last_trade_snapshot(conn, m),
        },
        MARKET_ORDERS_REQUEST => {
            match parse::<F::MarketOrdersRequest, F::MarketOrdersRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_orders_request(conn, m),
                Parsed::Right(m) => handler.on_market_orders_request(conn, m),
            }
        }
        MARKET_ORDERS_REJECT => {
            match parse::<F::MarketOrdersReject, F::MarketOrdersRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_orders_reject(conn, m),
                Parsed::Right(m) => handler.on_market_orders_reject(conn, m),
            }
        }
        MARKET_ORDERS_ADD => match parse::<F::MarketOrdersAdd, F::MarketOrdersAddUnsafe>(data)? {
            Parsed::Left(m) => handler.on_market_orders_add(conn, m),
            Parsed::Right(m) => handler.on_market_orders_add(conn, m),
        },
        MARKET_ORDERS_MODIFY => {
            match parse::<F::MarketOrdersModify, F::MarketOrdersModifyUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_orders_modify(conn, m),
                Parsed::Right(m) => handler.on_market_orders_modify(conn, m),
            }
        }
        MARKET_ORDERS_REMOVE => {
            match parse::<F::MarketOrdersRemove, F::MarketOrdersRemoveUnsafe>(data)? {
                Parsed::Left(m) => handler.on_market_orders_remove(conn, m),
                Parsed::Right(m) => handler.on_market_orders_remove(conn, m),
            }
        }
        MARKET_ORDERS_SNAPSHOT_MESSAGE_BOUNDARY => match parse::<
            F::MarketOrdersSnapshotMessageBoundary,
            F::MarketOrdersSnapshotMessageBoundaryUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_market_orders_snapshot_message_boundary(conn, m),
            Parsed::Right(m) => handler.on_market_orders_snapshot_message_boundary(conn, m),
        },
        SUBMIT_NEW_SINGLE_ORDER => {
            match parse::<F::SubmitNewSingleOrder, F::SubmitNewSingleOrderUnsafe>(data)? {
                Parsed::Left(m) => handler.on_submit_new_single_order(conn, m),
                Parsed::Right(m) => handler.on_submit_new_single_order(conn, m),
            }
        }
        SUBMIT_FLATTEN_POSITION_ORDER => {
            match parse::<F::SubmitFlattenPositionOrder, F::SubmitFlattenPositionOrderUnsafe>(data)?
            {
                Parsed::Left(m) => handler.on_submit_flatten_position_order(conn, m),
                Parsed::Right(m) => handler.on_submit_flatten_position_order(conn, m),
            }
        }
        CANCEL_REPLACE_ORDER => {
            match parse::<F::CancelReplaceOrder, F::CancelReplaceOrderUnsafe>(data)? {
                Parsed::Left(m) => handler.on_cancel_replace_order(conn, m),
                Parsed::Right(m) => handler.on_cancel_replace_order(conn, m),
            }
        }
        CANCEL_ORDER => match parse::<F::CancelOrder, F::CancelOrderUnsafe>(data)? {
            Parsed::Left(m) => handler.on_cancel_order(conn, m),
            Parsed::Right(m) => handler.on_cancel_order(conn, m),
        },
        SUBMIT_NEW_OCO_ORDER => {
            match parse::<F::SubmitNewOCOOrder, F::SubmitNewOCOOrderUnsafe>(data)? {
                Parsed::Left(m) => handler.on_submit_new_oco_order(conn, m),
                Parsed::Right(m) => handler.on_submit_new_oco_order(conn, m),
            }
        }
        OPEN_ORDERS_REQUEST => {
            match parse::<F::OpenOrdersRequest, F::OpenOrdersRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_open_orders_request(conn, m),
                Parsed::Right(m) => handler.on_open_orders_request(conn, m),
            }
        }
        HISTORICAL_ORDER_FILLS_REQUEST => {
            match parse::<F::HistoricalOrderFillsRequest, F::HistoricalOrderFillsRequestUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_historical_order_fills_request(conn, m),
                Parsed::Right(m) => handler.on_historical_order_fills_request(conn, m),
            }
        }
        HISTORICAL_ORDER_FILLS_REJECT => {
            match parse::<F::HistoricalOrderFillsReject, F::HistoricalOrderFillsRejectUnsafe>(data)?
            {
                Parsed::Left(m) => handler.on_historical_order_fills_reject(conn, m),
                Parsed::Right(m) => handler.on_historical_order_fills_reject(conn, m),
            }
        }
        CURRENT_POSITIONS_REQUEST => {
            match parse::<F::CurrentPositionsRequest, F::CurrentPositionsRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_current_positions_request(conn, m),
                Parsed::Right(m) => handler.on_current_positions_request(conn, m),
            }
        }
        CURRENT_POSITIONS_REJECT => {
            match parse::<F::CurrentPositionsReject, F::CurrentPositionsRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_current_positions_reject(conn, m),
                Parsed::Right(m) => handler.on_current_positions_reject(conn, m),
            }
        }
        ORDER_UPDATE => match parse::<F::OrderUpdate, F::OrderUpdateUnsafe>(data)? {
            Parsed::Left(m) => handler.on_order_update(conn, m),
            Parsed::Right(m) => handler.on_order_update(conn, m),
        },
        OPEN_ORDERS_REJECT => {
            match parse::<F::OpenOrdersReject, F::OpenOrdersRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_open_orders_reject(conn, m),
                Parsed::Right(m) => handler.on_open_orders_reject(conn, m),
            }
        }
        HISTORICAL_ORDER_FILL_RESPONSE => {
            match parse::<F::HistoricalOrderFillResponse, F::HistoricalOrderFillResponseUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_historical_order_fill_response(conn, m),
                Parsed::Right(m) => handler.on_historical_order_fill_response(conn, m),
            }
        }
        POSITION_UPDATE => match parse::<F::PositionUpdate, F::PositionUpdateUnsafe>(data)? {
            Parsed::Left(m) => handler.on_position_update(conn, m),
            Parsed::Right(m) => handler.on_position_update(conn, m),
        },
        ADD_CORRECTING_ORDER_FILL => {
            match parse::<F::AddCorrectingOrderFill, F::AddCorrectingOrderFillUnsafe>(data)? {
                Parsed::Left(m) => handler.on_add_correcting_order_fill(conn, m),
                Parsed::Right(m) => handler.on_add_correcting_order_fill(conn, m),
            }
        }
        CORRECTING_ORDER_FILL_RESPONSE => {
            match parse::<F::CorrectingOrderFillResponse, F::CorrectingOrderFillResponseUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_correcting_order_fill_response(conn, m),
                Parsed::Right(m) => handler.on_correcting_order_fill_response(conn, m),
            }
        }
        TRADE_ACCOUNTS_REQUEST => {
            match parse::<F::TradeAccountsRequest, F::TradeAccountsRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trade_accounts_request(conn, m),
                Parsed::Right(m) => handler.on_trade_accounts_request(conn, m),
            }
        }
        TRADE_ACCOUNT_RESPONSE => {
            match parse::<F::TradeAccountResponse, F::TradeAccountResponseUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trade_account_response(conn, m),
                Parsed::Right(m) => handler.on_trade_account_response(conn, m),
            }
        }
        EXCHANGE_LIST_REQUEST => {
            match parse::<F::ExchangeListRequest, F::ExchangeListRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_exchange_list_request(conn, m),
                Parsed::Right(m) => handler.on_exchange_list_request(conn, m),
            }
        }
        EXCHANGE_LIST_RESPONSE => {
            match parse::<F::ExchangeListResponse, F::ExchangeListResponseUnsafe>(data)? {
                Parsed::Left(m) => handler.on_exchange_list_response(conn, m),
                Parsed::Right(m) => handler.on_exchange_list_response(conn, m),
            }
        }
        SYMBOLS_FOR_EXCHANGE_REQUEST => {
            match parse::<F::SymbolsForExchangeRequest, F::SymbolsForExchangeRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_symbols_for_exchange_request(conn, m),
                Parsed::Right(m) => handler.on_symbols_for_exchange_request(conn, m),
            }
        }
        UNDERLYING_SYMBOLS_FOR_EXCHANGE_REQUEST => match parse::<
            F::UnderlyingSymbolsForExchangeRequest,
            F::UnderlyingSymbolsForExchangeRequestUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_underlying_symbols_for_exchange_request(conn, m),
            Parsed::Right(m) => handler.on_underlying_symbols_for_exchange_request(conn, m),
        },
        SYMBOLS_FOR_UNDERLYING_REQUEST => {
            match parse::<F::SymbolsForUnderlyingRequest, F::SymbolsForUnderlyingRequestUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_symbols_for_underlying_request(conn, m),
                Parsed::Right(m) => handler.on_symbols_for_underlying_request(conn, m),
            }
        }
        SYMBOL_SEARCH_REQUEST => {
            match parse::<F::SymbolSearchRequest, F::SymbolSearchRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_symbol_search_request(conn, m),
                Parsed::Right(m) => handler.on_symbol_search_request(conn, m),
            }
        }
        SECURITY_DEFINITION_FOR_SYMBOL_REQUEST => match parse::<
            F::SecurityDefinitionForSymbolRequest,
            F::SecurityDefinitionForSymbolRequestUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_security_definition_for_symbol_request(conn, m),
            Parsed::Right(m) => handler.on_security_definition_for_symbol_request(conn, m),
        },
        SECURITY_DEFINITION_RESPONSE => {
            match parse::<F::SecurityDefinitionResponse, F::SecurityDefinitionResponseUnsafe>(data)?
            {
                Parsed::Left(m) => handler.on_security_definition_response(conn, m),
                Parsed::Right(m) => handler.on_security_definition_response(conn, m),
            }
        }
        SECURITY_DEFINITION_REJECT => {
            match parse::<F::SecurityDefinitionReject, F::SecurityDefinitionRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_security_definition_reject(conn, m),
                Parsed::Right(m) => handler.on_security_definition_reject(conn, m),
            }
        }
        ACCOUNT_BALANCE_REQUEST => {
            match parse::<F::AccountBalanceRequest, F::AccountBalanceRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_account_balance_request(conn, m),
                Parsed::Right(m) => handler.on_account_balance_request(conn, m),
            }
        }
        ACCOUNT_BALANCE_REJECT => {
            match parse::<F::AccountBalanceReject, F::AccountBalanceRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_account_balance_reject(conn, m),
                Parsed::Right(m) => handler.on_account_balance_reject(conn, m),
            }
        }
        ACCOUNT_BALANCE_UPDATE => {
            match parse::<F::AccountBalanceUpdate, F::AccountBalanceUpdateUnsafe>(data)? {
                Parsed::Left(m) => handler.on_account_balance_update(conn, m),
                Parsed::Right(m) => handler.on_account_balance_update(conn, m),
            }
        }
        ACCOUNT_BALANCE_ADJUSTMENT => {
            match parse::<F::AccountBalanceAdjustment, F::AccountBalanceAdjustmentUnsafe>(data)? {
                Parsed::Left(m) => handler.on_account_balance_adjustment(conn, m),
                Parsed::Right(m) => handler.on_account_balance_adjustment(conn, m),
            }
        }
        ACCOUNT_BALANCE_ADJUSTMENT_REJECT => {
            match parse::<F::AccountBalanceAdjustmentReject, F::AccountBalanceAdjustmentRejectUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_account_balance_adjustment_reject(conn, m),
                Parsed::Right(m) => handler.on_account_balance_adjustment_reject(conn, m),
            }
        }
        ACCOUNT_BALANCE_ADJUSTMENT_COMPLETE => match parse::<
            F::AccountBalanceAdjustmentComplete,
            F::AccountBalanceAdjustmentCompleteUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_account_balance_adjustment_complete(conn, m),
            Parsed::Right(m) => handler.on_account_balance_adjustment_complete(conn, m),
        },
        HISTORICAL_ACCOUNT_BALANCES_REQUEST => match parse::<
            F::HistoricalAccountBalancesRequest,
            F::HistoricalAccountBalancesRequestUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_account_balances_request(conn, m),
            Parsed::Right(m) => handler.on_historical_account_balances_request(conn, m),
        },
        HISTORICAL_ACCOUNT_BALANCES_REJECT => match parse::<
            F::HistoricalAccountBalancesReject,
            F::HistoricalAccountBalancesRejectUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_account_balances_reject(conn, m),
            Parsed::Right(m) => handler.on_historical_account_balances_reject(conn, m),
        },
        HISTORICAL_ACCOUNT_BALANCE_RESPONSE => match parse::<
            F::HistoricalAccountBalanceResponse,
            F::HistoricalAccountBalanceResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_account_balance_response(conn, m),
            Parsed::Right(m) => handler.on_historical_account_balance_response(conn, m),
        },
        USER_MESSAGE => match parse::<F::UserMessage, F::UserMessageUnsafe>(data)? {
            Parsed::Left(m) => handler.on_user_message(conn, m),
            Parsed::Right(m) => handler.on_user_message(conn, m),
        },
        GENERAL_LOG_MESSAGE => {
            match parse::<F::GeneralLogMessage, F::GeneralLogMessageUnsafe>(data)? {
                Parsed::Left(m) => handler.on_general_log_message(conn, m),
                Parsed::Right(m) => handler.on_general_log_message(conn, m),
            }
        }
        ALERT_MESSAGE => match parse::<F::AlertMessage, F::AlertMessageUnsafe>(data)? {
            Parsed::Left(m) => handler.on_alert_message(conn, m),
            Parsed::Right(m) => handler.on_alert_message(conn, m),
        },
        JOURNAL_ENTRY_ADD => match parse::<F::JournalEntryAdd, F::JournalEntryAddUnsafe>(data)? {
            Parsed::Left(m) => handler.on_journal_entry_add(conn, m),
            Parsed::Right(m) => handler.on_journal_entry_add(conn, m),
        },
        JOURNAL_ENTRIES_REQUEST => {
            match parse::<F::JournalEntriesRequest, F::JournalEntriesRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_journal_entries_request(conn, m),
                Parsed::Right(m) => handler.on_journal_entries_request(conn, m),
            }
        }
        JOURNAL_ENTRIES_REJECT => {
            match parse::<F::JournalEntriesReject, F::JournalEntriesRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_journal_entries_reject(conn, m),
                Parsed::Right(m) => handler.on_journal_entries_reject(conn, m),
            }
        }
        JOURNAL_ENTRY_RESPONSE => {
            match parse::<F::JournalEntryResponse, F::JournalEntryResponseUnsafe>(data)? {
                Parsed::Left(m) => handler.on_journal_entry_response(conn, m),
                Parsed::Right(m) => handler.on_journal_entry_response(conn, m),
            }
        }
        HISTORICAL_PRICE_DATA_REQUEST => {
            match parse::<F::HistoricalPriceDataRequest, F::HistoricalPriceDataRequestUnsafe>(data)?
            {
                Parsed::Left(m) => handler.on_historical_price_data_request(conn, m),
                Parsed::Right(m) => handler.on_historical_price_data_request(conn, m),
            }
        }
        HISTORICAL_PRICE_DATA_RESPONSE_HEADER => match parse::<
            F::HistoricalPriceDataResponseHeader,
            F::HistoricalPriceDataResponseHeaderUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_price_data_response_header(conn, m),
            Parsed::Right(m) => handler.on_historical_price_data_response_header(conn, m),
        },
        HISTORICAL_PRICE_DATA_REJECT => {
            match parse::<F::HistoricalPriceDataReject, F::HistoricalPriceDataRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_historical_price_data_reject(conn, m),
                Parsed::Right(m) => handler.on_historical_price_data_reject(conn, m),
            }
        }
        HISTORICAL_PRICE_DATA_RECORD_RESPONSE => match parse::<
            F::HistoricalPriceDataRecordResponse,
            F::HistoricalPriceDataRecordResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_price_data_record_response(conn, m),
            Parsed::Right(m) => handler.on_historical_price_data_record_response(conn, m),
        },
        HISTORICAL_PRICE_DATA_TICK_RECORD_RESPONSE => match parse::<
            F::HistoricalPriceDataTickRecordResponse,
            F::HistoricalPriceDataTickRecordResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_price_data_tick_record_response(conn, m),
            Parsed::Right(m) => handler.on_historical_price_data_tick_record_response(conn, m),
        },
        HISTORICAL_PRICE_DATA_RESPONSE_TRAILER => match parse::<
            F::HistoricalPriceDataResponseTrailer,
            F::HistoricalPriceDataResponseTrailerUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_price_data_response_trailer(conn, m),
            Parsed::Right(m) => handler.on_historical_price_data_response_trailer(conn, m),
        },
        HISTORICAL_MARKET_DEPTH_DATA_REQUEST => match parse::<
            F::HistoricalMarketDepthDataRequest,
            F::HistoricalMarketDepthDataRequestUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_market_depth_data_request(conn, m),
            Parsed::Right(m) => handler.on_historical_market_depth_data_request(conn, m),
        },
        HISTORICAL_MARKET_DEPTH_DATA_RESPONSE_HEADER => match parse::<
            F::HistoricalMarketDepthDataResponseHeader,
            F::HistoricalMarketDepthDataResponseHeaderUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_market_depth_data_response_header(conn, m),
            Parsed::Right(m) => handler.on_historical_market_depth_data_response_header(conn, m),
        },
        HISTORICAL_MARKET_DEPTH_DATA_REJECT => match parse::<
            F::HistoricalMarketDepthDataReject,
            F::HistoricalMarketDepthDataRejectUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_market_depth_data_reject(conn, m),
            Parsed::Right(m) => handler.on_historical_market_depth_data_reject(conn, m),
        },
        HISTORICAL_MARKET_DEPTH_DATA_RECORD_RESPONSE => match parse::<
            F::HistoricalMarketDepthDataRecordResponse,
            F::HistoricalMarketDepthDataRecordResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_historical_market_depth_data_record_response(conn, m),
            Parsed::Right(m) => handler.on_historical_market_depth_data_record_response(conn, m),
        },
        HISTORICAL_TRADES_REQUEST => {
            match parse::<F::HistoricalTradesRequest, F::HistoricalTradesRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_historical_trades_request(conn, m),
                Parsed::Right(m) => handler.on_historical_trades_request(conn, m),
            }
        }
        HISTORICAL_TRADES_REJECT => {
            match parse::<F::HistoricalTradesReject, F::HistoricalTradesRejectUnsafe>(data)? {
                Parsed::Left(m) => handler.on_historical_trades_reject(conn, m),
                Parsed::Right(m) => handler.on_historical_trades_reject(conn, m),
            }
        }
        HISTORICAL_TRADES_RESPONSE => {
            match parse::<F::HistoricalTradesResponse, F::HistoricalTradesResponseUnsafe>(data)? {
                Parsed::Left(m) => handler.on_historical_trades_response(conn, m),
                Parsed::Right(m) => handler.on_historical_trades_response(conn, m),
            }
        }
        REPLAY_CHART_DATA => match parse::<F::ReplayChartData, F::ReplayChartDataUnsafe>(data)? {
            Parsed::Left(m) => handler.on_replay_chart_data(conn, m),
            Parsed::Right(m) => handler.on_replay_chart_data(conn, m),
        },
        REPLAY_CHART_DATA_PERFORM_ACTION => {
            match parse::<F::ReplayChartDataPerformAction, F::ReplayChartDataPerformActionUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_replay_chart_data_perform_action(conn, m),
                Parsed::Right(m) => handler.on_replay_chart_data_perform_action(conn, m),
            }
        }
        REPLAY_CHART_DATA_STATUS => {
            match parse::<F::ReplayChartDataStatus, F::ReplayChartDataStatusUnsafe>(data)? {
                Parsed::Left(m) => handler.on_replay_chart_data_status(conn, m),
                Parsed::Right(m) => handler.on_replay_chart_data_status(conn, m),
            }
        }
        REQUEST_NUM_CURRENT_CLIENT_CONNECTIONS => match parse::<
            F::RequestNumCurrentClientConnections,
            F::RequestNumCurrentClientConnectionsUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_request_num_current_client_connections(conn, m),
            Parsed::Right(m) => handler.on_request_num_current_client_connections(conn, m),
        },
        NUM_CURRENT_CLIENT_CONNECTIONS_RESPONSE => match parse::<
            F::NumCurrentClientConnectionsResponse,
            F::NumCurrentClientConnectionsResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_num_current_client_connections_response(conn, m),
            Parsed::Right(m) => handler.on_num_current_client_connections_response(conn, m),
        },
        CLIENT_DEVICE_UPDATE => {
            match parse::<F::ClientDeviceUpdate, F::ClientDeviceUpdateUnsafe>(data)? {
                Parsed::Left(m) => handler.on_client_device_update(conn, m),
                Parsed::Right(m) => handler.on_client_device_update(conn, m),
            }
        }
        INTERPROCESS_SYNCHRONIZATION_REMOTE_STATE => match parse::<
            F::InterprocessSynchronizationRemoteState,
            F::InterprocessSynchronizationRemoteStateUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_interprocess_synchronization_remote_state(conn, m),
            Parsed::Right(m) => handler.on_interprocess_synchronization_remote_state(conn, m),
        },
        INTERPROCESS_SYNCHRONIZATION_SNAPSHOT_REQUEST => match parse::<
            F::InterprocessSynchronizationSnapshotRequest,
            F::InterprocessSynchronizationSnapshotRequestUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_interprocess_synchronization_snapshot_request(conn, m),
            Parsed::Right(m) => handler.on_interprocess_synchronization_snapshot_request(conn, m),
        },
        INTERPROCESS_SYNCHRONIZATION_TRADE_ACTIVITY_REQUEST => match parse::<
            F::InterprocessSynchronizationTradeActivityRequest,
            F::InterprocessSynchronizationTradeActivityRequestUnsafe,
        >(data)?
        {
            Parsed::Left(m) => {
                handler.on_interprocess_synchronization_trade_activity_request(conn, m)
            }
            Parsed::Right(m) => {
                handler.on_interprocess_synchronization_trade_activity_request(conn, m)
            }
        },
        WRITE_INTRADAY_DATA_FILE_SESSION_VALUE => match parse::<
            F::WriteIntradayDataFileSessionValue,
            F::WriteIntradayDataFileSessionValueUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_write_intraday_data_file_session_value(conn, m),
            Parsed::Right(m) => handler.on_write_intraday_data_file_session_value(conn, m),
        },
        SC_CONFIGURATION_SYNCHRONIZATION => {
            match parse::<F::SCConfigurationSynchronization, F::SCConfigurationSynchronizationUnsafe>(
                data,
            )? {
                Parsed::Left(m) => handler.on_sc_configuration_synchronization(conn, m),
                Parsed::Right(m) => handler.on_sc_configuration_synchronization(conn, m),
            }
        }
        DOWNLOAD_HISTORICAL_ORDER_FILL_AND_ACCOUNT_BALANCE_DATA => match parse::<
            F::DownloadHistoricalOrderFillAndAccountBalanceData,
            F::DownloadHistoricalOrderFillAndAccountBalanceDataUnsafe,
        >(data)?
        {
            Parsed::Left(m) => {
                handler.on_download_historical_order_fill_and_account_balance_data(conn, m)
            }
            Parsed::Right(m) => {
                handler.on_download_historical_order_fill_and_account_balance_data(conn, m)
            }
        },
        SC_TRADE_ORDER => match parse::<F::TradeOrder, F::TradeOrderUnsafe>(data)? {
            Parsed::Left(m) => handler.on_trade_order(conn, m),
            Parsed::Right(m) => handler.on_trade_order(conn, m),
        },
        INDIVIDUAL_TRADE_POSITION => {
            match parse::<F::IndividualTradePosition, F::IndividualTradePositionUnsafe>(data)? {
                Parsed::Left(m) => handler.on_individual_trade_position(conn, m),
                Parsed::Right(m) => handler.on_individual_trade_position(conn, m),
            }
        }
        TRADE_POSITION_CONSOLIDATED => {
            match parse::<F::TradePositionConsolidated, F::TradePositionConsolidatedUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trade_position_consolidated(conn, m),
                Parsed::Right(m) => handler.on_trade_position_consolidated(conn, m),
            }
        }
        TRADE_ACTIVITY_DATA => {
            match parse::<F::TradeActivityData, F::TradeActivityDataUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trade_activity_data(conn, m),
                Parsed::Right(m) => handler.on_trade_activity_data(conn, m),
            }
        }
        TRADE_ACCOUNT_DATA_REQUEST => {
            match parse::<F::TradeAccountDataRequest, F::TradeAccountDataRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trade_account_data_request(conn, m),
                Parsed::Right(m) => handler.on_trade_account_data_request(conn, m),
            }
        }
        TRADE_ACCOUNT_DATA_RESPONSE => {
            match parse::<F::TradeAccountDataResponse, F::TradeAccountDataResponseUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trade_account_data_response(conn, m),
                Parsed::Right(m) => handler.on_trade_account_data_response(conn, m),
            }
        }
        TRADE_ACCOUNT_DATA_UPDATE => {
            match parse::<F::TradeAccountDataUpdate, F::TradeAccountDataUpdateUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trade_account_data_update(conn, m),
                Parsed::Right(m) => handler.on_trade_account_data_update(conn, m),
            }
        }
        TRADE_ACCOUNT_DATA_DELETE => {
            match parse::<F::TradeAccountDataDelete, F::TradeAccountDataDeleteUnsafe>(data)? {
                Parsed::Left(m) => handler.on_trade_account_data_delete(conn, m),
                Parsed::Right(m) => handler.on_trade_account_data_delete(conn, m),
            }
        }
        TRADE_ACCOUNT_DATA_SYMBOL_LIMITS_RESPONSE => match parse::<
            F::TradeAccountDataSymbolLimitsResponse,
            F::TradeAccountDataSymbolLimitsResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_symbol_limits_response(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_symbol_limits_response(conn, m),
        },
        TRADE_ACCOUNT_DATA_SYMBOL_LIMITS_UPDATE => match parse::<
            F::TradeAccountDataSymbolLimitsUpdate,
            F::TradeAccountDataSymbolLimitsUpdateUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_symbol_limits_update(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_symbol_limits_update(conn, m),
        },
        TRADE_ACCOUNT_DATA_SYMBOL_COMMISSION_RESPONSE => match parse::<
            F::TradeAccountDataSymbolCommissionResponse,
            F::TradeAccountDataSymbolCommissionResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_symbol_commission_response(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_symbol_commission_response(conn, m),
        },
        TRADE_ACCOUNT_DATA_SYMBOL_COMMISSION_UPDATE => match parse::<
            F::TradeAccountDataSymbolCommissionUpdate,
            F::TradeAccountDataSymbolCommissionUpdateUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_symbol_commission_update(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_symbol_commission_update(conn, m),
        },
        TRADE_ACCOUNT_DATA_AUTHORIZED_USERNAME_RESPONSE => match parse::<
            F::TradeAccountDataAuthorizedUsernameResponse,
            F::TradeAccountDataAuthorizedUsernameResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_authorized_username_response(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_authorized_username_response(conn, m),
        },
        TRADE_ACCOUNT_DATA_AUTHORIZED_USERNAME_ADD => match parse::<
            F::TradeAccountDataAuthorizedUsernameAdd,
            F::TradeAccountDataAuthorizedUsernameAddUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_authorized_username_add(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_authorized_username_add(conn, m),
        },
        TRADE_ACCOUNT_DATA_AUTHORIZED_USERNAME_REMOVE => match parse::<
            F::TradeAccountDataAuthorizedUsernameRemove,
            F::TradeAccountDataAuthorizedUsernameRemoveUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_authorized_username_remove(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_authorized_username_remove(conn, m),
        },
        TRADE_ACCOUNT_DATA_USERNAME_TO_SHARE_WITH_RESPONSE => match parse::<
            F::TradeAccountDataUsernameToShareWithResponse,
            F::TradeAccountDataUsernameToShareWithResponseUnsafe,
        >(data)?
        {
            Parsed::Left(m) => {
                handler.on_trade_account_data_username_to_share_with_response(conn, m)
            }
            Parsed::Right(m) => {
                handler.on_trade_account_data_username_to_share_with_response(conn, m)
            }
        },
        TRADE_ACCOUNT_DATA_USERNAME_TO_SHARE_WITH_ADD => match parse::<
            F::TradeAccountDataUsernameToShareWithAdd,
            F::TradeAccountDataUsernameToShareWithAddUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_username_to_share_with_add(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_username_to_share_with_add(conn, m),
        },
        TRADE_ACCOUNT_DATA_USERNAME_TO_SHARE_WITH_REMOVE => match parse::<
            F::TradeAccountDataUsernameToShareWithRemove,
            F::TradeAccountDataUsernameToShareWithRemoveUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_username_to_share_with_remove(conn, m),
            Parsed::Right(m) => {
                handler.on_trade_account_data_username_to_share_with_remove(conn, m)
            }
        },
        TRADE_ACCOUNT_DATA_RESPONSE_TRAILER => match parse::<
            F::TradeAccountDataResponseTrailer,
            F::TradeAccountDataResponseTrailerUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_response_trailer(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_response_trailer(conn, m),
        },
        TRADE_ACCOUNT_DATA_UPDATE_OPERATION_COMPLETE => match parse::<
            F::TradeAccountDataUpdateOperationComplete,
            F::TradeAccountDataUpdateOperationCompleteUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_trade_account_data_update_operation_complete(conn, m),
            Parsed::Right(m) => handler.on_trade_account_data_update_operation_complete(conn, m),
        },
        PROCESSED_FILL_IDENTIFIER => {
            match parse::<F::ProcessedFillIdentifier, F::ProcessedFillIdentifierUnsafe>(data)? {
                Parsed::Left(m) => handler.on_processed_fill_identifier(conn, m),
                Parsed::Right(m) => handler.on_processed_fill_identifier(conn, m),
            }
        }
        FLATTEN_POSITIONS_FOR_TRADE_ACCOUNT => match parse::<
            F::FlattenPositionsForTradeAccount,
            F::FlattenPositionsForTradeAccountUnsafe,
        >(data)?
        {
            Parsed::Left(m) => handler.on_flatten_positions_for_trade_account(conn, m),
            Parsed::Right(m) => handler.on_flatten_positions_for_trade_account(conn, m),
        },
        USER_INFORMATION => match parse::<F::UserInformation, F::UserInformationUnsafe>(data)? {
            Parsed::Left(m) => handler.on_user_information(conn, m),
            Parsed::Right(m) => handler.on_user_information(conn, m),
        },
        MARGIN_DATA_REQUEST => {
            match parse::<F::MarginDataRequest, F::MarginDataRequestUnsafe>(data)? {
                Parsed::Left(m) => handler.on_margin_data_request(conn, m),
                Parsed::Right(m) => handler.on_margin_data_request(conn, m),
            }
        }
        MARGIN_DATA_RESPONSE => {
            match parse::<F::MarginDataResponse, F::MarginDataResponseUnsafe>(data)? {
                Parsed::Left(m) => handler.on_margin_data_response(conn, m),
                Parsed::Right(m) => handler.on_margin_data_response(conn, m),
            }
        }
        code => handler.on_unknown_message(code, data),
    }
}
