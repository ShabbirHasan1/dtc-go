// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-27 08:32:53.747629 +0800 WITA m=+0.008238335
use super::*;

pub(crate) const TRADE_ORDER_VLS_SIZE: usize = 535;

/// size                                                              u16     = TradeOrderVLSSize  (535)
/// type                                                              u16     = SC_TRADE_ORDER  (10110)
/// base_size                                                         u16     = TradeOrderVLSSize  (535)
/// is_order_deleted                                                  bool    = false
/// internal_order_id                                                 u64     = 0
/// order_status_code                                                 u16     = 0
/// order_status_before_pending_modify                                u16     = 0
/// order_status_before_pending_cancel                                u16     = 0
/// service_order_id                                                  string  = ""
/// actual_symbol                                                     string  = ""
/// order_type                                                        i32     = 0
/// buy_sell                                                          u16     = 0
/// price1                                                            f64     = 0
/// price2                                                            f64     = 0
/// order_quantity                                                    f64     = 0
/// filled_quantity                                                   f64     = 0
/// average_fill_price                                                f64     = 0
/// realtime_fill_status                                              i32     = 0
/// is_resting_order_during_fill                                      bool    = false
/// order_reject_type                                                 i32     = 0
/// trade_account                                                     string  = ""
/// sub_account_identifier                                            u32     = 0
/// internal_order_id_modifier_for_service                            i32     = 0
/// fix_client_order_id                                               string  = ""
/// sequence_number_based_client_order_id                             u32     = 0
/// client_order_id_for_dtc_server                                    string  = ""
/// previous_client_order_id_for_dtc_server                           string  = ""
/// exchange_order_id                                                 string  = ""
/// originating_client_username                                       string  = ""
/// entry_date_time                                                   i64     = 0
/// last_action_date_time                                             i64     = 0
/// service_update_date_time_utc                                      i64     = 0
/// order_entry_time_for_service                                      u32     = 0
/// last_modify_time_for_service                                      u32     = 0
/// good_till_date_time                                               i64     = 0
/// time_in_force                                                     i32     = 0
/// open_close                                                        u16     = 0
/// trail_stop_offset1                                                f64     = 0
/// trail_stop_step                                                   f64     = 0
/// trail_trigger_price                                               f64     = 0
/// trailing_stop_trigger_offset                                      f64     = 0
/// trail_trigger_hit                                                 u8      = 0
/// trail_to_break_even_stop_offset                                   f64     = 0
/// maximum_chase_amount_as_price                                     f64     = 0
/// initial_chase_order_price1                                        f64     = 0
/// initial_last_trade_price_for_chase_orders                         f64     = 0
/// trailing_stop_trigger_oco_group_number                            i32     = 0
/// last_modify_price1                                                f64     = 0
/// last_modify_quantity                                              f64     = 0
/// cumulative_order_quantity_from_parent_fills                       f64     = 0
/// prior_filled_quantity                                             f64     = 0
/// tick_size                                                         f32     = 0
/// value_format                                                      i32     = 0
/// price_multiplier                                                  f32     = 0
/// parent_internal_order_id                                          u64     = 0
/// target_child_internal_order_id                                    u64     = 0
/// stop_child_internal_order_id                                      u64     = 0
/// attached_order_price_offset1                                      f64     = 0
/// link_internal_order_id                                            u64     = 0
/// oco_group_internal_order_id                                       u64     = 0
/// oco_sibling_internal_order_id                                     u64     = 0
/// disable_child_and_sibling_related_actions                         u8      = 0
/// oco_managed_by_service                                            u8      = 0
/// bracket_order_server_managed                                      u8      = 0
/// last_order_action_source                                          string  = ""
/// stop_limit_order_stop_price_triggered                             u8      = 0
/// oco_full_sibling_cancel_on_partial_fill                           u8      = 0
/// reverse_on_complete_fill                                          u8      = 0
/// support_scale_in                                                  u8      = 0
/// support_scale_out                                                 u8      = 0
/// source_chart_number                                               i32     = 0
/// source_chartbook_file_name                                        string  = ""
/// is_automated_order                                                bool    = false
/// simulated_order                                                   u8      = 0
/// is_chart_replaying                                                bool    = false
/// attached_order_oco_group_number                                   i32     = 0
/// last_fill_execution_service_id                                    string  = ""
/// fill_count                                                        i32     = 0
/// last_fill_quantity                                                f64     = 0
/// last_fill_price                                                   f64     = 0
/// last_fill_date_time_utc                                           i64     = 0
/// rejected_stop_oco_sibling_internal_order_id                       u64     = 0
/// rejected_stop_replacement_market_order_quantity                   f64     = 0
/// evaluating_for_fill                                               u8      = 0
/// last_processed_time_sales_record_sequence_for_prices              u32     = 0
/// is_market_data_management_of_order_enabled                        bool    = false
/// text_tag                                                          string  = ""
/// timed_out_order_requested_status_date_time                        i64     = 0
/// requested_status_for_timed_out_order                              u8      = 0
/// send_flatten_market_order_when_related_orders_confirmed_canceled  u8      = 0
/// quantity_to_increase_from_parent_fill                             f64     = 0
/// move_to_breakeven_stop_reference_price                            f64     = 0
/// quantity_triggered_stop_quantity_for_trigger                      f64     = 0
/// accumulated_trade_volume_for_triggered_stop                       f64     = 0
/// bid_ask_quantity_stop_initial_trigger_met                         u8      = 0
/// need_to_override_lock                                             u8      = 0
/// current_market_price                                              f64     = 0
/// current_market_date_time                                          i64     = 0
/// support_order_fill_billing                                        u8      = 0
/// is_billable                                                       bool    = false
/// quantity_for_billing                                              i32     = 0
/// number_of_failed_order_modifications                              u32     = 0
/// dtc_server_index                                                  i32     = 0
/// clearing_firm_id                                                  string  = ""
/// sender_sub_id                                                     string  = ""
/// sender_location_id                                                string  = ""
/// self_match_prevention_id                                          string  = ""
/// cti_code                                                          i32     = 0
/// obtain_order_action_date_time_from_last_trade_time_in_chart       u8      = 0
/// maximum_show_quantity                                             f64     = 0
/// order_submitted                                                   u8      = 0
/// is_snapshot                                                       bool    = false
/// is_first_message_in_batch                                         bool    = false
/// is_last_message_in_batch                                          bool    = false
/// external_last_action_date_time_utc                                i64     = 0
pub(crate) const TRADE_ORDER_VLS_DEFAULT: [u8; 535] = [
    23, 2, 126, 39, 23, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

pub trait TradeOrder: Message {
    type Safe: TradeOrder;
    type Unsafe: TradeOrder;

    fn is_order_deleted(&self) -> bool;

    fn internal_order_id(&self) -> u64;

    fn order_status_code(&self) -> u16;

    fn order_status_before_pending_modify(&self) -> u16;

    fn order_status_before_pending_cancel(&self) -> u16;

    fn service_order_id(&self) -> &str;

    fn actual_symbol(&self) -> &str;

    fn order_type(&self) -> i32;

    fn buy_sell(&self) -> u16;

    fn price1(&self) -> f64;

    fn price2(&self) -> f64;

    fn order_quantity(&self) -> f64;

    fn filled_quantity(&self) -> f64;

    fn average_fill_price(&self) -> f64;

    fn realtime_fill_status(&self) -> i32;

    fn is_resting_order_during_fill(&self) -> bool;

    fn order_reject_type(&self) -> i32;

    fn trade_account(&self) -> &str;

    fn sub_account_identifier(&self) -> u32;

    fn internal_order_id_modifier_for_service(&self) -> i32;

    fn fix_client_order_id(&self) -> &str;

    fn sequence_number_based_client_order_id(&self) -> u32;

    fn client_order_id_for_dtc_server(&self) -> &str;

    fn previous_client_order_id_for_dtc_server(&self) -> &str;

    fn exchange_order_id(&self) -> &str;

    fn originating_client_username(&self) -> &str;

    fn entry_date_time(&self) -> i64;

    fn last_action_date_time(&self) -> i64;

    fn service_update_date_time_utc(&self) -> i64;

    fn order_entry_time_for_service(&self) -> u32;

    fn last_modify_time_for_service(&self) -> u32;

    fn good_till_date_time(&self) -> i64;

    fn time_in_force(&self) -> i32;

    fn open_close(&self) -> u16;

    fn trail_stop_offset1(&self) -> f64;

    fn trail_stop_step(&self) -> f64;

    fn trail_trigger_price(&self) -> f64;

    fn trailing_stop_trigger_offset(&self) -> f64;

    fn trail_trigger_hit(&self) -> u8;

    fn trail_to_break_even_stop_offset(&self) -> f64;

    fn maximum_chase_amount_as_price(&self) -> f64;

    fn initial_chase_order_price1(&self) -> f64;

    fn initial_last_trade_price_for_chase_orders(&self) -> f64;

    fn trailing_stop_trigger_oco_group_number(&self) -> i32;

    fn last_modify_price1(&self) -> f64;

    fn last_modify_quantity(&self) -> f64;

    fn cumulative_order_quantity_from_parent_fills(&self) -> f64;

    fn prior_filled_quantity(&self) -> f64;

    fn tick_size(&self) -> f32;

    fn value_format(&self) -> i32;

    fn price_multiplier(&self) -> f32;

    fn parent_internal_order_id(&self) -> u64;

    fn target_child_internal_order_id(&self) -> u64;

    fn stop_child_internal_order_id(&self) -> u64;

    fn attached_order_price_offset1(&self) -> f64;

    fn link_internal_order_id(&self) -> u64;

    fn oco_group_internal_order_id(&self) -> u64;

    fn oco_sibling_internal_order_id(&self) -> u64;

    fn disable_child_and_sibling_related_actions(&self) -> u8;

    fn oco_managed_by_service(&self) -> u8;

    fn bracket_order_server_managed(&self) -> u8;

    fn last_order_action_source(&self) -> &str;

    fn stop_limit_order_stop_price_triggered(&self) -> u8;

    fn oco_full_sibling_cancel_on_partial_fill(&self) -> u8;

    fn reverse_on_complete_fill(&self) -> u8;

    fn support_scale_in(&self) -> u8;

    fn support_scale_out(&self) -> u8;

    fn source_chart_number(&self) -> i32;

    fn source_chartbook_file_name(&self) -> &str;

    fn is_automated_order(&self) -> bool;

    fn simulated_order(&self) -> u8;

    fn is_chart_replaying(&self) -> bool;

    fn attached_order_oco_group_number(&self) -> i32;

    fn last_fill_execution_service_id(&self) -> &str;

    fn fill_count(&self) -> i32;

    fn last_fill_quantity(&self) -> f64;

    fn last_fill_price(&self) -> f64;

    fn last_fill_date_time_utc(&self) -> i64;

    fn rejected_stop_oco_sibling_internal_order_id(&self) -> u64;

    fn rejected_stop_replacement_market_order_quantity(&self) -> f64;

    fn evaluating_for_fill(&self) -> u8;

    fn last_processed_time_sales_record_sequence_for_prices(&self) -> u32;

    fn is_market_data_management_of_order_enabled(&self) -> bool;

    fn text_tag(&self) -> &str;

    fn timed_out_order_requested_status_date_time(&self) -> i64;

    fn requested_status_for_timed_out_order(&self) -> u8;

    fn send_flatten_market_order_when_related_orders_confirmed_canceled(&self) -> u8;

    fn quantity_to_increase_from_parent_fill(&self) -> f64;

    fn move_to_breakeven_stop_reference_price(&self) -> f64;

    fn quantity_triggered_stop_quantity_for_trigger(&self) -> f64;

    fn accumulated_trade_volume_for_triggered_stop(&self) -> f64;

    fn bid_ask_quantity_stop_initial_trigger_met(&self) -> u8;

    fn need_to_override_lock(&self) -> u8;

    fn current_market_price(&self) -> f64;

    fn current_market_date_time(&self) -> i64;

    fn support_order_fill_billing(&self) -> u8;

    fn is_billable(&self) -> bool;

    fn quantity_for_billing(&self) -> i32;

    fn number_of_failed_order_modifications(&self) -> u32;

    fn dtc_server_index(&self) -> i32;

    fn clearing_firm_id(&self) -> &str;

    fn sender_sub_id(&self) -> &str;

    fn sender_location_id(&self) -> &str;

    fn self_match_prevention_id(&self) -> &str;

    fn cti_code(&self) -> i32;

    fn obtain_order_action_date_time_from_last_trade_time_in_chart(&self) -> u8;

    fn maximum_show_quantity(&self) -> f64;

    fn order_submitted(&self) -> u8;

    fn is_snapshot(&self) -> bool;

    fn is_first_message_in_batch(&self) -> bool;

    fn is_last_message_in_batch(&self) -> bool;

    fn external_last_action_date_time_utc(&self) -> i64;

    fn set_is_order_deleted(&mut self, value: bool) -> &mut Self;

    fn set_internal_order_id(&mut self, value: u64) -> &mut Self;

    fn set_order_status_code(&mut self, value: u16) -> &mut Self;

    fn set_order_status_before_pending_modify(&mut self, value: u16) -> &mut Self;

    fn set_order_status_before_pending_cancel(&mut self, value: u16) -> &mut Self;

    fn set_service_order_id(&mut self, value: &str) -> &mut Self;

    fn set_actual_symbol(&mut self, value: &str) -> &mut Self;

    fn set_order_type(&mut self, value: i32) -> &mut Self;

    fn set_buy_sell(&mut self, value: u16) -> &mut Self;

    fn set_price1(&mut self, value: f64) -> &mut Self;

    fn set_price2(&mut self, value: f64) -> &mut Self;

    fn set_order_quantity(&mut self, value: f64) -> &mut Self;

    fn set_filled_quantity(&mut self, value: f64) -> &mut Self;

    fn set_average_fill_price(&mut self, value: f64) -> &mut Self;

    fn set_realtime_fill_status(&mut self, value: i32) -> &mut Self;

    fn set_is_resting_order_during_fill(&mut self, value: bool) -> &mut Self;

    fn set_order_reject_type(&mut self, value: i32) -> &mut Self;

    fn set_trade_account(&mut self, value: &str) -> &mut Self;

    fn set_sub_account_identifier(&mut self, value: u32) -> &mut Self;

    fn set_internal_order_id_modifier_for_service(&mut self, value: i32) -> &mut Self;

    fn set_fix_client_order_id(&mut self, value: &str) -> &mut Self;

    fn set_sequence_number_based_client_order_id(&mut self, value: u32) -> &mut Self;

    fn set_client_order_id_for_dtc_server(&mut self, value: &str) -> &mut Self;

    fn set_previous_client_order_id_for_dtc_server(&mut self, value: &str) -> &mut Self;

    fn set_exchange_order_id(&mut self, value: &str) -> &mut Self;

    fn set_originating_client_username(&mut self, value: &str) -> &mut Self;

    fn set_entry_date_time(&mut self, value: i64) -> &mut Self;

    fn set_last_action_date_time(&mut self, value: i64) -> &mut Self;

    fn set_service_update_date_time_utc(&mut self, value: i64) -> &mut Self;

    fn set_order_entry_time_for_service(&mut self, value: u32) -> &mut Self;

    fn set_last_modify_time_for_service(&mut self, value: u32) -> &mut Self;

    fn set_good_till_date_time(&mut self, value: i64) -> &mut Self;

    fn set_time_in_force(&mut self, value: i32) -> &mut Self;

    fn set_open_close(&mut self, value: u16) -> &mut Self;

    fn set_trail_stop_offset1(&mut self, value: f64) -> &mut Self;

    fn set_trail_stop_step(&mut self, value: f64) -> &mut Self;

    fn set_trail_trigger_price(&mut self, value: f64) -> &mut Self;

    fn set_trailing_stop_trigger_offset(&mut self, value: f64) -> &mut Self;

    fn set_trail_trigger_hit(&mut self, value: u8) -> &mut Self;

    fn set_trail_to_break_even_stop_offset(&mut self, value: f64) -> &mut Self;

    fn set_maximum_chase_amount_as_price(&mut self, value: f64) -> &mut Self;

    fn set_initial_chase_order_price1(&mut self, value: f64) -> &mut Self;

    fn set_initial_last_trade_price_for_chase_orders(&mut self, value: f64) -> &mut Self;

    fn set_trailing_stop_trigger_oco_group_number(&mut self, value: i32) -> &mut Self;

    fn set_last_modify_price1(&mut self, value: f64) -> &mut Self;

    fn set_last_modify_quantity(&mut self, value: f64) -> &mut Self;

    fn set_cumulative_order_quantity_from_parent_fills(&mut self, value: f64) -> &mut Self;

    fn set_prior_filled_quantity(&mut self, value: f64) -> &mut Self;

    fn set_tick_size(&mut self, value: f32) -> &mut Self;

    fn set_value_format(&mut self, value: i32) -> &mut Self;

    fn set_price_multiplier(&mut self, value: f32) -> &mut Self;

    fn set_parent_internal_order_id(&mut self, value: u64) -> &mut Self;

    fn set_target_child_internal_order_id(&mut self, value: u64) -> &mut Self;

    fn set_stop_child_internal_order_id(&mut self, value: u64) -> &mut Self;

    fn set_attached_order_price_offset1(&mut self, value: f64) -> &mut Self;

    fn set_link_internal_order_id(&mut self, value: u64) -> &mut Self;

    fn set_oco_group_internal_order_id(&mut self, value: u64) -> &mut Self;

    fn set_oco_sibling_internal_order_id(&mut self, value: u64) -> &mut Self;

    fn set_disable_child_and_sibling_related_actions(&mut self, value: u8) -> &mut Self;

    fn set_oco_managed_by_service(&mut self, value: u8) -> &mut Self;

    fn set_bracket_order_server_managed(&mut self, value: u8) -> &mut Self;

    fn set_last_order_action_source(&mut self, value: &str) -> &mut Self;

    fn set_stop_limit_order_stop_price_triggered(&mut self, value: u8) -> &mut Self;

    fn set_oco_full_sibling_cancel_on_partial_fill(&mut self, value: u8) -> &mut Self;

    fn set_reverse_on_complete_fill(&mut self, value: u8) -> &mut Self;

    fn set_support_scale_in(&mut self, value: u8) -> &mut Self;

    fn set_support_scale_out(&mut self, value: u8) -> &mut Self;

    fn set_source_chart_number(&mut self, value: i32) -> &mut Self;

    fn set_source_chartbook_file_name(&mut self, value: &str) -> &mut Self;

    fn set_is_automated_order(&mut self, value: bool) -> &mut Self;

    fn set_simulated_order(&mut self, value: u8) -> &mut Self;

    fn set_is_chart_replaying(&mut self, value: bool) -> &mut Self;

    fn set_attached_order_oco_group_number(&mut self, value: i32) -> &mut Self;

    fn set_last_fill_execution_service_id(&mut self, value: &str) -> &mut Self;

    fn set_fill_count(&mut self, value: i32) -> &mut Self;

    fn set_last_fill_quantity(&mut self, value: f64) -> &mut Self;

    fn set_last_fill_price(&mut self, value: f64) -> &mut Self;

    fn set_last_fill_date_time_utc(&mut self, value: i64) -> &mut Self;

    fn set_rejected_stop_oco_sibling_internal_order_id(&mut self, value: u64) -> &mut Self;

    fn set_rejected_stop_replacement_market_order_quantity(&mut self, value: f64) -> &mut Self;

    fn set_evaluating_for_fill(&mut self, value: u8) -> &mut Self;

    fn set_last_processed_time_sales_record_sequence_for_prices(&mut self, value: u32)
        -> &mut Self;

    fn set_is_market_data_management_of_order_enabled(&mut self, value: bool) -> &mut Self;

    fn set_text_tag(&mut self, value: &str) -> &mut Self;

    fn set_timed_out_order_requested_status_date_time(&mut self, value: i64) -> &mut Self;

    fn set_requested_status_for_timed_out_order(&mut self, value: u8) -> &mut Self;

    fn set_send_flatten_market_order_when_related_orders_confirmed_canceled(
        &mut self,
        value: u8,
    ) -> &mut Self;

    fn set_quantity_to_increase_from_parent_fill(&mut self, value: f64) -> &mut Self;

    fn set_move_to_breakeven_stop_reference_price(&mut self, value: f64) -> &mut Self;

    fn set_quantity_triggered_stop_quantity_for_trigger(&mut self, value: f64) -> &mut Self;

    fn set_accumulated_trade_volume_for_triggered_stop(&mut self, value: f64) -> &mut Self;

    fn set_bid_ask_quantity_stop_initial_trigger_met(&mut self, value: u8) -> &mut Self;

    fn set_need_to_override_lock(&mut self, value: u8) -> &mut Self;

    fn set_current_market_price(&mut self, value: f64) -> &mut Self;

    fn set_current_market_date_time(&mut self, value: i64) -> &mut Self;

    fn set_support_order_fill_billing(&mut self, value: u8) -> &mut Self;

    fn set_is_billable(&mut self, value: bool) -> &mut Self;

    fn set_quantity_for_billing(&mut self, value: i32) -> &mut Self;

    fn set_number_of_failed_order_modifications(&mut self, value: u32) -> &mut Self;

    fn set_dtc_server_index(&mut self, value: i32) -> &mut Self;

    fn set_clearing_firm_id(&mut self, value: &str) -> &mut Self;

    fn set_sender_sub_id(&mut self, value: &str) -> &mut Self;

    fn set_sender_location_id(&mut self, value: &str) -> &mut Self;

    fn set_self_match_prevention_id(&mut self, value: &str) -> &mut Self;

    fn set_cti_code(&mut self, value: i32) -> &mut Self;

    fn set_obtain_order_action_date_time_from_last_trade_time_in_chart(
        &mut self,
        value: u8,
    ) -> &mut Self;

    fn set_maximum_show_quantity(&mut self, value: f64) -> &mut Self;

    fn set_order_submitted(&mut self, value: u8) -> &mut Self;

    fn set_is_snapshot(&mut self, value: bool) -> &mut Self;

    fn set_is_first_message_in_batch(&mut self, value: bool) -> &mut Self;

    fn set_is_last_message_in_batch(&mut self, value: bool) -> &mut Self;

    fn set_external_last_action_date_time_utc(&mut self, value: i64) -> &mut Self;

    fn clone_safe(&self) -> Self::Safe;

    fn to_safe(self) -> Self::Safe;

    fn copy_to(&self, to: &mut impl TradeOrder) {
        to.set_is_order_deleted(self.is_order_deleted());
        to.set_internal_order_id(self.internal_order_id());
        to.set_order_status_code(self.order_status_code());
        to.set_order_status_before_pending_modify(self.order_status_before_pending_modify());
        to.set_order_status_before_pending_cancel(self.order_status_before_pending_cancel());
        to.set_service_order_id(self.service_order_id());
        to.set_actual_symbol(self.actual_symbol());
        to.set_order_type(self.order_type());
        to.set_buy_sell(self.buy_sell());
        to.set_price1(self.price1());
        to.set_price2(self.price2());
        to.set_order_quantity(self.order_quantity());
        to.set_filled_quantity(self.filled_quantity());
        to.set_average_fill_price(self.average_fill_price());
        to.set_realtime_fill_status(self.realtime_fill_status());
        to.set_is_resting_order_during_fill(self.is_resting_order_during_fill());
        to.set_order_reject_type(self.order_reject_type());
        to.set_trade_account(self.trade_account());
        to.set_sub_account_identifier(self.sub_account_identifier());
        to.set_internal_order_id_modifier_for_service(
            self.internal_order_id_modifier_for_service(),
        );
        to.set_fix_client_order_id(self.fix_client_order_id());
        to.set_sequence_number_based_client_order_id(self.sequence_number_based_client_order_id());
        to.set_client_order_id_for_dtc_server(self.client_order_id_for_dtc_server());
        to.set_previous_client_order_id_for_dtc_server(
            self.previous_client_order_id_for_dtc_server(),
        );
        to.set_exchange_order_id(self.exchange_order_id());
        to.set_originating_client_username(self.originating_client_username());
        to.set_entry_date_time(self.entry_date_time());
        to.set_last_action_date_time(self.last_action_date_time());
        to.set_service_update_date_time_utc(self.service_update_date_time_utc());
        to.set_order_entry_time_for_service(self.order_entry_time_for_service());
        to.set_last_modify_time_for_service(self.last_modify_time_for_service());
        to.set_good_till_date_time(self.good_till_date_time());
        to.set_time_in_force(self.time_in_force());
        to.set_open_close(self.open_close());
        to.set_trail_stop_offset1(self.trail_stop_offset1());
        to.set_trail_stop_step(self.trail_stop_step());
        to.set_trail_trigger_price(self.trail_trigger_price());
        to.set_trailing_stop_trigger_offset(self.trailing_stop_trigger_offset());
        to.set_trail_trigger_hit(self.trail_trigger_hit());
        to.set_trail_to_break_even_stop_offset(self.trail_to_break_even_stop_offset());
        to.set_maximum_chase_amount_as_price(self.maximum_chase_amount_as_price());
        to.set_initial_chase_order_price1(self.initial_chase_order_price1());
        to.set_initial_last_trade_price_for_chase_orders(
            self.initial_last_trade_price_for_chase_orders(),
        );
        to.set_trailing_stop_trigger_oco_group_number(
            self.trailing_stop_trigger_oco_group_number(),
        );
        to.set_last_modify_price1(self.last_modify_price1());
        to.set_last_modify_quantity(self.last_modify_quantity());
        to.set_cumulative_order_quantity_from_parent_fills(
            self.cumulative_order_quantity_from_parent_fills(),
        );
        to.set_prior_filled_quantity(self.prior_filled_quantity());
        to.set_tick_size(self.tick_size());
        to.set_value_format(self.value_format());
        to.set_price_multiplier(self.price_multiplier());
        to.set_parent_internal_order_id(self.parent_internal_order_id());
        to.set_target_child_internal_order_id(self.target_child_internal_order_id());
        to.set_stop_child_internal_order_id(self.stop_child_internal_order_id());
        to.set_attached_order_price_offset1(self.attached_order_price_offset1());
        to.set_link_internal_order_id(self.link_internal_order_id());
        to.set_oco_group_internal_order_id(self.oco_group_internal_order_id());
        to.set_oco_sibling_internal_order_id(self.oco_sibling_internal_order_id());
        to.set_disable_child_and_sibling_related_actions(
            self.disable_child_and_sibling_related_actions(),
        );
        to.set_oco_managed_by_service(self.oco_managed_by_service());
        to.set_bracket_order_server_managed(self.bracket_order_server_managed());
        to.set_last_order_action_source(self.last_order_action_source());
        to.set_stop_limit_order_stop_price_triggered(self.stop_limit_order_stop_price_triggered());
        to.set_oco_full_sibling_cancel_on_partial_fill(
            self.oco_full_sibling_cancel_on_partial_fill(),
        );
        to.set_reverse_on_complete_fill(self.reverse_on_complete_fill());
        to.set_support_scale_in(self.support_scale_in());
        to.set_support_scale_out(self.support_scale_out());
        to.set_source_chart_number(self.source_chart_number());
        to.set_source_chartbook_file_name(self.source_chartbook_file_name());
        to.set_is_automated_order(self.is_automated_order());
        to.set_simulated_order(self.simulated_order());
        to.set_is_chart_replaying(self.is_chart_replaying());
        to.set_attached_order_oco_group_number(self.attached_order_oco_group_number());
        to.set_last_fill_execution_service_id(self.last_fill_execution_service_id());
        to.set_fill_count(self.fill_count());
        to.set_last_fill_quantity(self.last_fill_quantity());
        to.set_last_fill_price(self.last_fill_price());
        to.set_last_fill_date_time_utc(self.last_fill_date_time_utc());
        to.set_rejected_stop_oco_sibling_internal_order_id(
            self.rejected_stop_oco_sibling_internal_order_id(),
        );
        to.set_rejected_stop_replacement_market_order_quantity(
            self.rejected_stop_replacement_market_order_quantity(),
        );
        to.set_evaluating_for_fill(self.evaluating_for_fill());
        to.set_last_processed_time_sales_record_sequence_for_prices(
            self.last_processed_time_sales_record_sequence_for_prices(),
        );
        to.set_is_market_data_management_of_order_enabled(
            self.is_market_data_management_of_order_enabled(),
        );
        to.set_text_tag(self.text_tag());
        to.set_timed_out_order_requested_status_date_time(
            self.timed_out_order_requested_status_date_time(),
        );
        to.set_requested_status_for_timed_out_order(self.requested_status_for_timed_out_order());
        to.set_send_flatten_market_order_when_related_orders_confirmed_canceled(
            self.send_flatten_market_order_when_related_orders_confirmed_canceled(),
        );
        to.set_quantity_to_increase_from_parent_fill(self.quantity_to_increase_from_parent_fill());
        to.set_move_to_breakeven_stop_reference_price(
            self.move_to_breakeven_stop_reference_price(),
        );
        to.set_quantity_triggered_stop_quantity_for_trigger(
            self.quantity_triggered_stop_quantity_for_trigger(),
        );
        to.set_accumulated_trade_volume_for_triggered_stop(
            self.accumulated_trade_volume_for_triggered_stop(),
        );
        to.set_bid_ask_quantity_stop_initial_trigger_met(
            self.bid_ask_quantity_stop_initial_trigger_met(),
        );
        to.set_need_to_override_lock(self.need_to_override_lock());
        to.set_current_market_price(self.current_market_price());
        to.set_current_market_date_time(self.current_market_date_time());
        to.set_support_order_fill_billing(self.support_order_fill_billing());
        to.set_is_billable(self.is_billable());
        to.set_quantity_for_billing(self.quantity_for_billing());
        to.set_number_of_failed_order_modifications(self.number_of_failed_order_modifications());
        to.set_dtc_server_index(self.dtc_server_index());
        to.set_clearing_firm_id(self.clearing_firm_id());
        to.set_sender_sub_id(self.sender_sub_id());
        to.set_sender_location_id(self.sender_location_id());
        to.set_self_match_prevention_id(self.self_match_prevention_id());
        to.set_cti_code(self.cti_code());
        to.set_obtain_order_action_date_time_from_last_trade_time_in_chart(
            self.obtain_order_action_date_time_from_last_trade_time_in_chart(),
        );
        to.set_maximum_show_quantity(self.maximum_show_quantity());
        to.set_order_submitted(self.order_submitted());
        to.set_is_snapshot(self.is_snapshot());
        to.set_is_first_message_in_batch(self.is_first_message_in_batch());
        to.set_is_last_message_in_batch(self.is_last_message_in_batch());
        to.set_external_last_action_date_time_utc(self.external_last_action_date_time_utc());
    }

    #[inline]
    fn parse<F: Fn(Parsed<Self::Safe, Self::Unsafe>) -> Result<(), crate::Error>>(
        data: &[u8],
        f: F,
    ) -> Result<(), crate::Error> {
        if data.len() < 6 {
            return Err(crate::Error::Malformed("need more data"));
        }
        let size = unsafe { u16::from_le(*(data.as_ptr() as *const u16)) };
        let base_size = if Self::BASE_SIZE_OFFSET == 0 {
            size
        } else {
            let base_size = unsafe {
                u16::from_le(*(data.as_ptr().offset(Self::BASE_SIZE_OFFSET) as *const u16))
            };
            if base_size > size {
                return Err(crate::Error::Malformed("base_size is greater than size"));
            }
            base_size
        };
        if (base_size as usize) >= Self::BASE_SIZE {
            let msg = unsafe { Self::Safe::from_raw_parts(data.as_ptr(), size as usize) };
            let r = f(Parsed::Safe(&msg));
            core::mem::forget(msg);
            r
        } else {
            let msg = unsafe { Self::Unsafe::from_raw_parts(data.as_ptr(), size as usize) };
            let r = f(Parsed::Unsafe(&msg));
            core::mem::forget(msg);
            r
        }
    }
}

pub struct TradeOrderVLS {
    data: *const TradeOrderVLSData,
    capacity: usize,
}

pub struct TradeOrderVLSUnsafe {
    data: *const TradeOrderVLSData,
    capacity: usize,
}

#[repr(packed(1), C)]
pub struct TradeOrderVLSData {
    size: u16,
    r#type: u16,
    base_size: u16,
    is_order_deleted: bool,
    internal_order_id: u64,
    order_status_code: u16,
    order_status_before_pending_modify: u16,
    order_status_before_pending_cancel: u16,
    service_order_id: VLS,
    actual_symbol: VLS,
    order_type: i32,
    buy_sell: u16,
    price1: f64,
    price2: f64,
    order_quantity: f64,
    filled_quantity: f64,
    average_fill_price: f64,
    realtime_fill_status: i32,
    is_resting_order_during_fill: bool,
    order_reject_type: i32,
    trade_account: VLS,
    sub_account_identifier: u32,
    internal_order_id_modifier_for_service: i32,
    fix_client_order_id: VLS,
    sequence_number_based_client_order_id: u32,
    client_order_id_for_dtc_server: VLS,
    previous_client_order_id_for_dtc_server: VLS,
    exchange_order_id: VLS,
    originating_client_username: VLS,
    entry_date_time: i64,
    last_action_date_time: i64,
    service_update_date_time_utc: i64,
    order_entry_time_for_service: u32,
    last_modify_time_for_service: u32,
    good_till_date_time: i64,
    time_in_force: i32,
    open_close: u16,
    trail_stop_offset1: f64,
    trail_stop_step: f64,
    trail_trigger_price: f64,
    trailing_stop_trigger_offset: f64,
    trail_trigger_hit: u8,
    trail_to_break_even_stop_offset: f64,
    maximum_chase_amount_as_price: f64,
    initial_chase_order_price1: f64,
    initial_last_trade_price_for_chase_orders: f64,
    trailing_stop_trigger_oco_group_number: i32,
    last_modify_price1: f64,
    last_modify_quantity: f64,
    cumulative_order_quantity_from_parent_fills: f64,
    prior_filled_quantity: f64,
    tick_size: f32,
    value_format: i32,
    price_multiplier: f32,
    parent_internal_order_id: u64,
    target_child_internal_order_id: u64,
    stop_child_internal_order_id: u64,
    attached_order_price_offset1: f64,
    link_internal_order_id: u64,
    oco_group_internal_order_id: u64,
    oco_sibling_internal_order_id: u64,
    disable_child_and_sibling_related_actions: u8,
    oco_managed_by_service: u8,
    bracket_order_server_managed: u8,
    last_order_action_source: VLS,
    stop_limit_order_stop_price_triggered: u8,
    oco_full_sibling_cancel_on_partial_fill: u8,
    reverse_on_complete_fill: u8,
    support_scale_in: u8,
    support_scale_out: u8,
    source_chart_number: i32,
    source_chartbook_file_name: VLS,
    is_automated_order: bool,
    simulated_order: u8,
    is_chart_replaying: bool,
    attached_order_oco_group_number: i32,
    last_fill_execution_service_id: VLS,
    fill_count: i32,
    last_fill_quantity: f64,
    last_fill_price: f64,
    last_fill_date_time_utc: i64,
    rejected_stop_oco_sibling_internal_order_id: u64,
    rejected_stop_replacement_market_order_quantity: f64,
    evaluating_for_fill: u8,
    last_processed_time_sales_record_sequence_for_prices: u32,
    is_market_data_management_of_order_enabled: bool,
    text_tag: VLS,
    timed_out_order_requested_status_date_time: i64,
    requested_status_for_timed_out_order: u8,
    send_flatten_market_order_when_related_orders_confirmed_canceled: u8,
    quantity_to_increase_from_parent_fill: f64,
    move_to_breakeven_stop_reference_price: f64,
    quantity_triggered_stop_quantity_for_trigger: f64,
    accumulated_trade_volume_for_triggered_stop: f64,
    bid_ask_quantity_stop_initial_trigger_met: u8,
    need_to_override_lock: u8,
    current_market_price: f64,
    current_market_date_time: i64,
    support_order_fill_billing: u8,
    is_billable: bool,
    quantity_for_billing: i32,
    number_of_failed_order_modifications: u32,
    dtc_server_index: i32,
    clearing_firm_id: VLS,
    sender_sub_id: VLS,
    sender_location_id: VLS,
    self_match_prevention_id: VLS,
    cti_code: i32,
    obtain_order_action_date_time_from_last_trade_time_in_chart: u8,
    maximum_show_quantity: f64,
    order_submitted: u8,
    is_snapshot: bool,
    is_first_message_in_batch: bool,
    is_last_message_in_batch: bool,
    external_last_action_date_time_utc: i64,
}

impl TradeOrderVLSData {
    pub fn new() -> Self {
        Self {
            size: 535u16.to_le(),
            r#type: SC_TRADE_ORDER.to_le(),
            base_size: 535u16.to_le(),
            is_order_deleted: false,
            internal_order_id: 0u64.to_le(),
            order_status_code: 0u16.to_le(),
            order_status_before_pending_modify: 0u16.to_le(),
            order_status_before_pending_cancel: 0u16.to_le(),
            service_order_id: crate::message::VLS::new(),
            actual_symbol: crate::message::VLS::new(),
            order_type: 0i32.to_le(),
            buy_sell: 0u16.to_le(),
            price1: 0.0,
            price2: 0.0,
            order_quantity: 0.0,
            filled_quantity: 0.0,
            average_fill_price: 0.0,
            realtime_fill_status: 0i32.to_le(),
            is_resting_order_during_fill: false,
            order_reject_type: 0i32.to_le(),
            trade_account: crate::message::VLS::new(),
            sub_account_identifier: 0u32.to_le(),
            internal_order_id_modifier_for_service: 0i32.to_le(),
            fix_client_order_id: crate::message::VLS::new(),
            sequence_number_based_client_order_id: 0u32.to_le(),
            client_order_id_for_dtc_server: crate::message::VLS::new(),
            previous_client_order_id_for_dtc_server: crate::message::VLS::new(),
            exchange_order_id: crate::message::VLS::new(),
            originating_client_username: crate::message::VLS::new(),
            entry_date_time: 0i64.to_le(),
            last_action_date_time: 0i64.to_le(),
            service_update_date_time_utc: 0i64.to_le(),
            order_entry_time_for_service: 0u32.to_le(),
            last_modify_time_for_service: 0u32.to_le(),
            good_till_date_time: 0i64.to_le(),
            time_in_force: 0i32.to_le(),
            open_close: 0u16.to_le(),
            trail_stop_offset1: 0.0,
            trail_stop_step: 0.0,
            trail_trigger_price: 0.0,
            trailing_stop_trigger_offset: 0.0,
            trail_trigger_hit: 0,
            trail_to_break_even_stop_offset: 0.0,
            maximum_chase_amount_as_price: 0.0,
            initial_chase_order_price1: 0.0,
            initial_last_trade_price_for_chase_orders: 0.0,
            trailing_stop_trigger_oco_group_number: 0i32.to_le(),
            last_modify_price1: 0.0,
            last_modify_quantity: 0.0,
            cumulative_order_quantity_from_parent_fills: 0.0,
            prior_filled_quantity: 0.0,
            tick_size: 0.0,
            value_format: 0i32.to_le(),
            price_multiplier: 0.0,
            parent_internal_order_id: 0u64.to_le(),
            target_child_internal_order_id: 0u64.to_le(),
            stop_child_internal_order_id: 0u64.to_le(),
            attached_order_price_offset1: 0.0,
            link_internal_order_id: 0u64.to_le(),
            oco_group_internal_order_id: 0u64.to_le(),
            oco_sibling_internal_order_id: 0u64.to_le(),
            disable_child_and_sibling_related_actions: 0,
            oco_managed_by_service: 0,
            bracket_order_server_managed: 0,
            last_order_action_source: crate::message::VLS::new(),
            stop_limit_order_stop_price_triggered: 0,
            oco_full_sibling_cancel_on_partial_fill: 0,
            reverse_on_complete_fill: 0,
            support_scale_in: 0,
            support_scale_out: 0,
            source_chart_number: 0i32.to_le(),
            source_chartbook_file_name: crate::message::VLS::new(),
            is_automated_order: false,
            simulated_order: 0,
            is_chart_replaying: false,
            attached_order_oco_group_number: 0i32.to_le(),
            last_fill_execution_service_id: crate::message::VLS::new(),
            fill_count: 0i32.to_le(),
            last_fill_quantity: 0.0,
            last_fill_price: 0.0,
            last_fill_date_time_utc: 0i64.to_le(),
            rejected_stop_oco_sibling_internal_order_id: 0u64.to_le(),
            rejected_stop_replacement_market_order_quantity: 0.0,
            evaluating_for_fill: 0,
            last_processed_time_sales_record_sequence_for_prices: 0u32.to_le(),
            is_market_data_management_of_order_enabled: false,
            text_tag: crate::message::VLS::new(),
            timed_out_order_requested_status_date_time: 0i64.to_le(),
            requested_status_for_timed_out_order: 0,
            send_flatten_market_order_when_related_orders_confirmed_canceled: 0,
            quantity_to_increase_from_parent_fill: 0.0,
            move_to_breakeven_stop_reference_price: 0.0,
            quantity_triggered_stop_quantity_for_trigger: 0.0,
            accumulated_trade_volume_for_triggered_stop: 0.0,
            bid_ask_quantity_stop_initial_trigger_met: 0,
            need_to_override_lock: 0,
            current_market_price: 0.0,
            current_market_date_time: 0i64.to_le(),
            support_order_fill_billing: 0,
            is_billable: false,
            quantity_for_billing: 0i32.to_le(),
            number_of_failed_order_modifications: 0u32.to_le(),
            dtc_server_index: 0i32.to_le(),
            clearing_firm_id: crate::message::VLS::new(),
            sender_sub_id: crate::message::VLS::new(),
            sender_location_id: crate::message::VLS::new(),
            self_match_prevention_id: crate::message::VLS::new(),
            cti_code: 0i32.to_le(),
            obtain_order_action_date_time_from_last_trade_time_in_chart: 0,
            maximum_show_quantity: 0.0,
            order_submitted: 0,
            is_snapshot: false,
            is_first_message_in_batch: false,
            is_last_message_in_batch: false,
            external_last_action_date_time_utc: 0i64.to_le(),
        }
    }
}

unsafe impl Send for TradeOrderVLS {}
unsafe impl Send for TradeOrderVLSUnsafe {}
unsafe impl Send for TradeOrderVLSData {}

impl Drop for TradeOrderVLS {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for TradeOrderVLSUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Clone for TradeOrderVLS {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for TradeOrderVLSUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Into<Vec<u8>> for TradeOrderVLS {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for TradeOrderVLSUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl core::ops::Deref for TradeOrderVLS {
    type Target = TradeOrderVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for TradeOrderVLS {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for TradeOrderVLSUnsafe {
    type Target = TradeOrderVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for TradeOrderVLSUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::fmt::Display for TradeOrderVLS {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(format!("TradeOrderVLS(size: {}, type: {}, base_size: {}, is_order_deleted: {}, internal_order_id: {}, order_status_code: {}, order_status_before_pending_modify: {}, order_status_before_pending_cancel: {}, service_order_id: \"{}\", actual_symbol: \"{}\", order_type: {}, buy_sell: {}, price1: {}, price2: {}, order_quantity: {}, filled_quantity: {}, average_fill_price: {}, realtime_fill_status: {}, is_resting_order_during_fill: {}, order_reject_type: {}, trade_account: \"{}\", sub_account_identifier: {}, internal_order_id_modifier_for_service: {}, fix_client_order_id: \"{}\", sequence_number_based_client_order_id: {}, client_order_id_for_dtc_server: \"{}\", previous_client_order_id_for_dtc_server: \"{}\", exchange_order_id: \"{}\", originating_client_username: \"{}\", entry_date_time: {}, last_action_date_time: {}, service_update_date_time_utc: {}, order_entry_time_for_service: {}, last_modify_time_for_service: {}, good_till_date_time: {}, time_in_force: {}, open_close: {}, trail_stop_offset1: {}, trail_stop_step: {}, trail_trigger_price: {}, trailing_stop_trigger_offset: {}, trail_trigger_hit: {}, trail_to_break_even_stop_offset: {}, maximum_chase_amount_as_price: {}, initial_chase_order_price1: {}, initial_last_trade_price_for_chase_orders: {}, trailing_stop_trigger_oco_group_number: {}, last_modify_price1: {}, last_modify_quantity: {}, cumulative_order_quantity_from_parent_fills: {}, prior_filled_quantity: {}, tick_size: {}, value_format: {}, price_multiplier: {}, parent_internal_order_id: {}, target_child_internal_order_id: {}, stop_child_internal_order_id: {}, attached_order_price_offset1: {}, link_internal_order_id: {}, oco_group_internal_order_id: {}, oco_sibling_internal_order_id: {}, disable_child_and_sibling_related_actions: {}, oco_managed_by_service: {}, bracket_order_server_managed: {}, last_order_action_source: \"{}\", stop_limit_order_stop_price_triggered: {}, oco_full_sibling_cancel_on_partial_fill: {}, reverse_on_complete_fill: {}, support_scale_in: {}, support_scale_out: {}, source_chart_number: {}, source_chartbook_file_name: \"{}\", is_automated_order: {}, simulated_order: {}, is_chart_replaying: {}, attached_order_oco_group_number: {}, last_fill_execution_service_id: \"{}\", fill_count: {}, last_fill_quantity: {}, last_fill_price: {}, last_fill_date_time_utc: {}, rejected_stop_oco_sibling_internal_order_id: {}, rejected_stop_replacement_market_order_quantity: {}, evaluating_for_fill: {}, last_processed_time_sales_record_sequence_for_prices: {}, is_market_data_management_of_order_enabled: {}, text_tag: \"{}\", timed_out_order_requested_status_date_time: {}, requested_status_for_timed_out_order: {}, send_flatten_market_order_when_related_orders_confirmed_canceled: {}, quantity_to_increase_from_parent_fill: {}, move_to_breakeven_stop_reference_price: {}, quantity_triggered_stop_quantity_for_trigger: {}, accumulated_trade_volume_for_triggered_stop: {}, bid_ask_quantity_stop_initial_trigger_met: {}, need_to_override_lock: {}, current_market_price: {}, current_market_date_time: {}, support_order_fill_billing: {}, is_billable: {}, quantity_for_billing: {}, number_of_failed_order_modifications: {}, dtc_server_index: {}, clearing_firm_id: \"{}\", sender_sub_id: \"{}\", sender_location_id: \"{}\", self_match_prevention_id: \"{}\", cti_code: {}, obtain_order_action_date_time_from_last_trade_time_in_chart: {}, maximum_show_quantity: {}, order_submitted: {}, is_snapshot: {}, is_first_message_in_batch: {}, is_last_message_in_batch: {}, external_last_action_date_time_utc: {})", self.size(), self.r#type(), self.base_size(), self.is_order_deleted(), self.internal_order_id(), self.order_status_code(), self.order_status_before_pending_modify(), self.order_status_before_pending_cancel(), self.service_order_id(), self.actual_symbol(), self.order_type(), self.buy_sell(), self.price1(), self.price2(), self.order_quantity(), self.filled_quantity(), self.average_fill_price(), self.realtime_fill_status(), self.is_resting_order_during_fill(), self.order_reject_type(), self.trade_account(), self.sub_account_identifier(), self.internal_order_id_modifier_for_service(), self.fix_client_order_id(), self.sequence_number_based_client_order_id(), self.client_order_id_for_dtc_server(), self.previous_client_order_id_for_dtc_server(), self.exchange_order_id(), self.originating_client_username(), self.entry_date_time(), self.last_action_date_time(), self.service_update_date_time_utc(), self.order_entry_time_for_service(), self.last_modify_time_for_service(), self.good_till_date_time(), self.time_in_force(), self.open_close(), self.trail_stop_offset1(), self.trail_stop_step(), self.trail_trigger_price(), self.trailing_stop_trigger_offset(), self.trail_trigger_hit(), self.trail_to_break_even_stop_offset(), self.maximum_chase_amount_as_price(), self.initial_chase_order_price1(), self.initial_last_trade_price_for_chase_orders(), self.trailing_stop_trigger_oco_group_number(), self.last_modify_price1(), self.last_modify_quantity(), self.cumulative_order_quantity_from_parent_fills(), self.prior_filled_quantity(), self.tick_size(), self.value_format(), self.price_multiplier(), self.parent_internal_order_id(), self.target_child_internal_order_id(), self.stop_child_internal_order_id(), self.attached_order_price_offset1(), self.link_internal_order_id(), self.oco_group_internal_order_id(), self.oco_sibling_internal_order_id(), self.disable_child_and_sibling_related_actions(), self.oco_managed_by_service(), self.bracket_order_server_managed(), self.last_order_action_source(), self.stop_limit_order_stop_price_triggered(), self.oco_full_sibling_cancel_on_partial_fill(), self.reverse_on_complete_fill(), self.support_scale_in(), self.support_scale_out(), self.source_chart_number(), self.source_chartbook_file_name(), self.is_automated_order(), self.simulated_order(), self.is_chart_replaying(), self.attached_order_oco_group_number(), self.last_fill_execution_service_id(), self.fill_count(), self.last_fill_quantity(), self.last_fill_price(), self.last_fill_date_time_utc(), self.rejected_stop_oco_sibling_internal_order_id(), self.rejected_stop_replacement_market_order_quantity(), self.evaluating_for_fill(), self.last_processed_time_sales_record_sequence_for_prices(), self.is_market_data_management_of_order_enabled(), self.text_tag(), self.timed_out_order_requested_status_date_time(), self.requested_status_for_timed_out_order(), self.send_flatten_market_order_when_related_orders_confirmed_canceled(), self.quantity_to_increase_from_parent_fill(), self.move_to_breakeven_stop_reference_price(), self.quantity_triggered_stop_quantity_for_trigger(), self.accumulated_trade_volume_for_triggered_stop(), self.bid_ask_quantity_stop_initial_trigger_met(), self.need_to_override_lock(), self.current_market_price(), self.current_market_date_time(), self.support_order_fill_billing(), self.is_billable(), self.quantity_for_billing(), self.number_of_failed_order_modifications(), self.dtc_server_index(), self.clearing_firm_id(), self.sender_sub_id(), self.sender_location_id(), self.self_match_prevention_id(), self.cti_code(), self.obtain_order_action_date_time_from_last_trade_time_in_chart(), self.maximum_show_quantity(), self.order_submitted(), self.is_snapshot(), self.is_first_message_in_batch(), self.is_last_message_in_batch(), self.external_last_action_date_time_utc()).as_str())
    }
}

impl core::fmt::Debug for TradeOrderVLS {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(format!("TradeOrderVLS(size: {}, type: {}, base_size: {}, is_order_deleted: {}, internal_order_id: {}, order_status_code: {}, order_status_before_pending_modify: {}, order_status_before_pending_cancel: {}, service_order_id: \"{}\", actual_symbol: \"{}\", order_type: {}, buy_sell: {}, price1: {}, price2: {}, order_quantity: {}, filled_quantity: {}, average_fill_price: {}, realtime_fill_status: {}, is_resting_order_during_fill: {}, order_reject_type: {}, trade_account: \"{}\", sub_account_identifier: {}, internal_order_id_modifier_for_service: {}, fix_client_order_id: \"{}\", sequence_number_based_client_order_id: {}, client_order_id_for_dtc_server: \"{}\", previous_client_order_id_for_dtc_server: \"{}\", exchange_order_id: \"{}\", originating_client_username: \"{}\", entry_date_time: {}, last_action_date_time: {}, service_update_date_time_utc: {}, order_entry_time_for_service: {}, last_modify_time_for_service: {}, good_till_date_time: {}, time_in_force: {}, open_close: {}, trail_stop_offset1: {}, trail_stop_step: {}, trail_trigger_price: {}, trailing_stop_trigger_offset: {}, trail_trigger_hit: {}, trail_to_break_even_stop_offset: {}, maximum_chase_amount_as_price: {}, initial_chase_order_price1: {}, initial_last_trade_price_for_chase_orders: {}, trailing_stop_trigger_oco_group_number: {}, last_modify_price1: {}, last_modify_quantity: {}, cumulative_order_quantity_from_parent_fills: {}, prior_filled_quantity: {}, tick_size: {}, value_format: {}, price_multiplier: {}, parent_internal_order_id: {}, target_child_internal_order_id: {}, stop_child_internal_order_id: {}, attached_order_price_offset1: {}, link_internal_order_id: {}, oco_group_internal_order_id: {}, oco_sibling_internal_order_id: {}, disable_child_and_sibling_related_actions: {}, oco_managed_by_service: {}, bracket_order_server_managed: {}, last_order_action_source: \"{}\", stop_limit_order_stop_price_triggered: {}, oco_full_sibling_cancel_on_partial_fill: {}, reverse_on_complete_fill: {}, support_scale_in: {}, support_scale_out: {}, source_chart_number: {}, source_chartbook_file_name: \"{}\", is_automated_order: {}, simulated_order: {}, is_chart_replaying: {}, attached_order_oco_group_number: {}, last_fill_execution_service_id: \"{}\", fill_count: {}, last_fill_quantity: {}, last_fill_price: {}, last_fill_date_time_utc: {}, rejected_stop_oco_sibling_internal_order_id: {}, rejected_stop_replacement_market_order_quantity: {}, evaluating_for_fill: {}, last_processed_time_sales_record_sequence_for_prices: {}, is_market_data_management_of_order_enabled: {}, text_tag: \"{}\", timed_out_order_requested_status_date_time: {}, requested_status_for_timed_out_order: {}, send_flatten_market_order_when_related_orders_confirmed_canceled: {}, quantity_to_increase_from_parent_fill: {}, move_to_breakeven_stop_reference_price: {}, quantity_triggered_stop_quantity_for_trigger: {}, accumulated_trade_volume_for_triggered_stop: {}, bid_ask_quantity_stop_initial_trigger_met: {}, need_to_override_lock: {}, current_market_price: {}, current_market_date_time: {}, support_order_fill_billing: {}, is_billable: {}, quantity_for_billing: {}, number_of_failed_order_modifications: {}, dtc_server_index: {}, clearing_firm_id: \"{}\", sender_sub_id: \"{}\", sender_location_id: \"{}\", self_match_prevention_id: \"{}\", cti_code: {}, obtain_order_action_date_time_from_last_trade_time_in_chart: {}, maximum_show_quantity: {}, order_submitted: {}, is_snapshot: {}, is_first_message_in_batch: {}, is_last_message_in_batch: {}, external_last_action_date_time_utc: {})", self.size(), self.r#type(), self.base_size(), self.is_order_deleted(), self.internal_order_id(), self.order_status_code(), self.order_status_before_pending_modify(), self.order_status_before_pending_cancel(), self.service_order_id(), self.actual_symbol(), self.order_type(), self.buy_sell(), self.price1(), self.price2(), self.order_quantity(), self.filled_quantity(), self.average_fill_price(), self.realtime_fill_status(), self.is_resting_order_during_fill(), self.order_reject_type(), self.trade_account(), self.sub_account_identifier(), self.internal_order_id_modifier_for_service(), self.fix_client_order_id(), self.sequence_number_based_client_order_id(), self.client_order_id_for_dtc_server(), self.previous_client_order_id_for_dtc_server(), self.exchange_order_id(), self.originating_client_username(), self.entry_date_time(), self.last_action_date_time(), self.service_update_date_time_utc(), self.order_entry_time_for_service(), self.last_modify_time_for_service(), self.good_till_date_time(), self.time_in_force(), self.open_close(), self.trail_stop_offset1(), self.trail_stop_step(), self.trail_trigger_price(), self.trailing_stop_trigger_offset(), self.trail_trigger_hit(), self.trail_to_break_even_stop_offset(), self.maximum_chase_amount_as_price(), self.initial_chase_order_price1(), self.initial_last_trade_price_for_chase_orders(), self.trailing_stop_trigger_oco_group_number(), self.last_modify_price1(), self.last_modify_quantity(), self.cumulative_order_quantity_from_parent_fills(), self.prior_filled_quantity(), self.tick_size(), self.value_format(), self.price_multiplier(), self.parent_internal_order_id(), self.target_child_internal_order_id(), self.stop_child_internal_order_id(), self.attached_order_price_offset1(), self.link_internal_order_id(), self.oco_group_internal_order_id(), self.oco_sibling_internal_order_id(), self.disable_child_and_sibling_related_actions(), self.oco_managed_by_service(), self.bracket_order_server_managed(), self.last_order_action_source(), self.stop_limit_order_stop_price_triggered(), self.oco_full_sibling_cancel_on_partial_fill(), self.reverse_on_complete_fill(), self.support_scale_in(), self.support_scale_out(), self.source_chart_number(), self.source_chartbook_file_name(), self.is_automated_order(), self.simulated_order(), self.is_chart_replaying(), self.attached_order_oco_group_number(), self.last_fill_execution_service_id(), self.fill_count(), self.last_fill_quantity(), self.last_fill_price(), self.last_fill_date_time_utc(), self.rejected_stop_oco_sibling_internal_order_id(), self.rejected_stop_replacement_market_order_quantity(), self.evaluating_for_fill(), self.last_processed_time_sales_record_sequence_for_prices(), self.is_market_data_management_of_order_enabled(), self.text_tag(), self.timed_out_order_requested_status_date_time(), self.requested_status_for_timed_out_order(), self.send_flatten_market_order_when_related_orders_confirmed_canceled(), self.quantity_to_increase_from_parent_fill(), self.move_to_breakeven_stop_reference_price(), self.quantity_triggered_stop_quantity_for_trigger(), self.accumulated_trade_volume_for_triggered_stop(), self.bid_ask_quantity_stop_initial_trigger_met(), self.need_to_override_lock(), self.current_market_price(), self.current_market_date_time(), self.support_order_fill_billing(), self.is_billable(), self.quantity_for_billing(), self.number_of_failed_order_modifications(), self.dtc_server_index(), self.clearing_firm_id(), self.sender_sub_id(), self.sender_location_id(), self.self_match_prevention_id(), self.cti_code(), self.obtain_order_action_date_time_from_last_trade_time_in_chart(), self.maximum_show_quantity(), self.order_submitted(), self.is_snapshot(), self.is_first_message_in_batch(), self.is_last_message_in_batch(), self.external_last_action_date_time_utc()).as_str())
    }
}

impl core::fmt::Display for TradeOrderVLSUnsafe {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(format!("TradeOrderVLSUnsafe(size: {}, type: {}, base_size: {}, is_order_deleted: {}, internal_order_id: {}, order_status_code: {}, order_status_before_pending_modify: {}, order_status_before_pending_cancel: {}, service_order_id: \"{}\", actual_symbol: \"{}\", order_type: {}, buy_sell: {}, price1: {}, price2: {}, order_quantity: {}, filled_quantity: {}, average_fill_price: {}, realtime_fill_status: {}, is_resting_order_during_fill: {}, order_reject_type: {}, trade_account: \"{}\", sub_account_identifier: {}, internal_order_id_modifier_for_service: {}, fix_client_order_id: \"{}\", sequence_number_based_client_order_id: {}, client_order_id_for_dtc_server: \"{}\", previous_client_order_id_for_dtc_server: \"{}\", exchange_order_id: \"{}\", originating_client_username: \"{}\", entry_date_time: {}, last_action_date_time: {}, service_update_date_time_utc: {}, order_entry_time_for_service: {}, last_modify_time_for_service: {}, good_till_date_time: {}, time_in_force: {}, open_close: {}, trail_stop_offset1: {}, trail_stop_step: {}, trail_trigger_price: {}, trailing_stop_trigger_offset: {}, trail_trigger_hit: {}, trail_to_break_even_stop_offset: {}, maximum_chase_amount_as_price: {}, initial_chase_order_price1: {}, initial_last_trade_price_for_chase_orders: {}, trailing_stop_trigger_oco_group_number: {}, last_modify_price1: {}, last_modify_quantity: {}, cumulative_order_quantity_from_parent_fills: {}, prior_filled_quantity: {}, tick_size: {}, value_format: {}, price_multiplier: {}, parent_internal_order_id: {}, target_child_internal_order_id: {}, stop_child_internal_order_id: {}, attached_order_price_offset1: {}, link_internal_order_id: {}, oco_group_internal_order_id: {}, oco_sibling_internal_order_id: {}, disable_child_and_sibling_related_actions: {}, oco_managed_by_service: {}, bracket_order_server_managed: {}, last_order_action_source: \"{}\", stop_limit_order_stop_price_triggered: {}, oco_full_sibling_cancel_on_partial_fill: {}, reverse_on_complete_fill: {}, support_scale_in: {}, support_scale_out: {}, source_chart_number: {}, source_chartbook_file_name: \"{}\", is_automated_order: {}, simulated_order: {}, is_chart_replaying: {}, attached_order_oco_group_number: {}, last_fill_execution_service_id: \"{}\", fill_count: {}, last_fill_quantity: {}, last_fill_price: {}, last_fill_date_time_utc: {}, rejected_stop_oco_sibling_internal_order_id: {}, rejected_stop_replacement_market_order_quantity: {}, evaluating_for_fill: {}, last_processed_time_sales_record_sequence_for_prices: {}, is_market_data_management_of_order_enabled: {}, text_tag: \"{}\", timed_out_order_requested_status_date_time: {}, requested_status_for_timed_out_order: {}, send_flatten_market_order_when_related_orders_confirmed_canceled: {}, quantity_to_increase_from_parent_fill: {}, move_to_breakeven_stop_reference_price: {}, quantity_triggered_stop_quantity_for_trigger: {}, accumulated_trade_volume_for_triggered_stop: {}, bid_ask_quantity_stop_initial_trigger_met: {}, need_to_override_lock: {}, current_market_price: {}, current_market_date_time: {}, support_order_fill_billing: {}, is_billable: {}, quantity_for_billing: {}, number_of_failed_order_modifications: {}, dtc_server_index: {}, clearing_firm_id: \"{}\", sender_sub_id: \"{}\", sender_location_id: \"{}\", self_match_prevention_id: \"{}\", cti_code: {}, obtain_order_action_date_time_from_last_trade_time_in_chart: {}, maximum_show_quantity: {}, order_submitted: {}, is_snapshot: {}, is_first_message_in_batch: {}, is_last_message_in_batch: {}, external_last_action_date_time_utc: {})", self.size(), self.r#type(), self.base_size(), self.is_order_deleted(), self.internal_order_id(), self.order_status_code(), self.order_status_before_pending_modify(), self.order_status_before_pending_cancel(), self.service_order_id(), self.actual_symbol(), self.order_type(), self.buy_sell(), self.price1(), self.price2(), self.order_quantity(), self.filled_quantity(), self.average_fill_price(), self.realtime_fill_status(), self.is_resting_order_during_fill(), self.order_reject_type(), self.trade_account(), self.sub_account_identifier(), self.internal_order_id_modifier_for_service(), self.fix_client_order_id(), self.sequence_number_based_client_order_id(), self.client_order_id_for_dtc_server(), self.previous_client_order_id_for_dtc_server(), self.exchange_order_id(), self.originating_client_username(), self.entry_date_time(), self.last_action_date_time(), self.service_update_date_time_utc(), self.order_entry_time_for_service(), self.last_modify_time_for_service(), self.good_till_date_time(), self.time_in_force(), self.open_close(), self.trail_stop_offset1(), self.trail_stop_step(), self.trail_trigger_price(), self.trailing_stop_trigger_offset(), self.trail_trigger_hit(), self.trail_to_break_even_stop_offset(), self.maximum_chase_amount_as_price(), self.initial_chase_order_price1(), self.initial_last_trade_price_for_chase_orders(), self.trailing_stop_trigger_oco_group_number(), self.last_modify_price1(), self.last_modify_quantity(), self.cumulative_order_quantity_from_parent_fills(), self.prior_filled_quantity(), self.tick_size(), self.value_format(), self.price_multiplier(), self.parent_internal_order_id(), self.target_child_internal_order_id(), self.stop_child_internal_order_id(), self.attached_order_price_offset1(), self.link_internal_order_id(), self.oco_group_internal_order_id(), self.oco_sibling_internal_order_id(), self.disable_child_and_sibling_related_actions(), self.oco_managed_by_service(), self.bracket_order_server_managed(), self.last_order_action_source(), self.stop_limit_order_stop_price_triggered(), self.oco_full_sibling_cancel_on_partial_fill(), self.reverse_on_complete_fill(), self.support_scale_in(), self.support_scale_out(), self.source_chart_number(), self.source_chartbook_file_name(), self.is_automated_order(), self.simulated_order(), self.is_chart_replaying(), self.attached_order_oco_group_number(), self.last_fill_execution_service_id(), self.fill_count(), self.last_fill_quantity(), self.last_fill_price(), self.last_fill_date_time_utc(), self.rejected_stop_oco_sibling_internal_order_id(), self.rejected_stop_replacement_market_order_quantity(), self.evaluating_for_fill(), self.last_processed_time_sales_record_sequence_for_prices(), self.is_market_data_management_of_order_enabled(), self.text_tag(), self.timed_out_order_requested_status_date_time(), self.requested_status_for_timed_out_order(), self.send_flatten_market_order_when_related_orders_confirmed_canceled(), self.quantity_to_increase_from_parent_fill(), self.move_to_breakeven_stop_reference_price(), self.quantity_triggered_stop_quantity_for_trigger(), self.accumulated_trade_volume_for_triggered_stop(), self.bid_ask_quantity_stop_initial_trigger_met(), self.need_to_override_lock(), self.current_market_price(), self.current_market_date_time(), self.support_order_fill_billing(), self.is_billable(), self.quantity_for_billing(), self.number_of_failed_order_modifications(), self.dtc_server_index(), self.clearing_firm_id(), self.sender_sub_id(), self.sender_location_id(), self.self_match_prevention_id(), self.cti_code(), self.obtain_order_action_date_time_from_last_trade_time_in_chart(), self.maximum_show_quantity(), self.order_submitted(), self.is_snapshot(), self.is_first_message_in_batch(), self.is_last_message_in_batch(), self.external_last_action_date_time_utc()).as_str())
    }
}

impl core::fmt::Debug for TradeOrderVLSUnsafe {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(format!("TradeOrderVLSUnsafe(size: {}, type: {}, base_size: {}, is_order_deleted: {}, internal_order_id: {}, order_status_code: {}, order_status_before_pending_modify: {}, order_status_before_pending_cancel: {}, service_order_id: \"{}\", actual_symbol: \"{}\", order_type: {}, buy_sell: {}, price1: {}, price2: {}, order_quantity: {}, filled_quantity: {}, average_fill_price: {}, realtime_fill_status: {}, is_resting_order_during_fill: {}, order_reject_type: {}, trade_account: \"{}\", sub_account_identifier: {}, internal_order_id_modifier_for_service: {}, fix_client_order_id: \"{}\", sequence_number_based_client_order_id: {}, client_order_id_for_dtc_server: \"{}\", previous_client_order_id_for_dtc_server: \"{}\", exchange_order_id: \"{}\", originating_client_username: \"{}\", entry_date_time: {}, last_action_date_time: {}, service_update_date_time_utc: {}, order_entry_time_for_service: {}, last_modify_time_for_service: {}, good_till_date_time: {}, time_in_force: {}, open_close: {}, trail_stop_offset1: {}, trail_stop_step: {}, trail_trigger_price: {}, trailing_stop_trigger_offset: {}, trail_trigger_hit: {}, trail_to_break_even_stop_offset: {}, maximum_chase_amount_as_price: {}, initial_chase_order_price1: {}, initial_last_trade_price_for_chase_orders: {}, trailing_stop_trigger_oco_group_number: {}, last_modify_price1: {}, last_modify_quantity: {}, cumulative_order_quantity_from_parent_fills: {}, prior_filled_quantity: {}, tick_size: {}, value_format: {}, price_multiplier: {}, parent_internal_order_id: {}, target_child_internal_order_id: {}, stop_child_internal_order_id: {}, attached_order_price_offset1: {}, link_internal_order_id: {}, oco_group_internal_order_id: {}, oco_sibling_internal_order_id: {}, disable_child_and_sibling_related_actions: {}, oco_managed_by_service: {}, bracket_order_server_managed: {}, last_order_action_source: \"{}\", stop_limit_order_stop_price_triggered: {}, oco_full_sibling_cancel_on_partial_fill: {}, reverse_on_complete_fill: {}, support_scale_in: {}, support_scale_out: {}, source_chart_number: {}, source_chartbook_file_name: \"{}\", is_automated_order: {}, simulated_order: {}, is_chart_replaying: {}, attached_order_oco_group_number: {}, last_fill_execution_service_id: \"{}\", fill_count: {}, last_fill_quantity: {}, last_fill_price: {}, last_fill_date_time_utc: {}, rejected_stop_oco_sibling_internal_order_id: {}, rejected_stop_replacement_market_order_quantity: {}, evaluating_for_fill: {}, last_processed_time_sales_record_sequence_for_prices: {}, is_market_data_management_of_order_enabled: {}, text_tag: \"{}\", timed_out_order_requested_status_date_time: {}, requested_status_for_timed_out_order: {}, send_flatten_market_order_when_related_orders_confirmed_canceled: {}, quantity_to_increase_from_parent_fill: {}, move_to_breakeven_stop_reference_price: {}, quantity_triggered_stop_quantity_for_trigger: {}, accumulated_trade_volume_for_triggered_stop: {}, bid_ask_quantity_stop_initial_trigger_met: {}, need_to_override_lock: {}, current_market_price: {}, current_market_date_time: {}, support_order_fill_billing: {}, is_billable: {}, quantity_for_billing: {}, number_of_failed_order_modifications: {}, dtc_server_index: {}, clearing_firm_id: \"{}\", sender_sub_id: \"{}\", sender_location_id: \"{}\", self_match_prevention_id: \"{}\", cti_code: {}, obtain_order_action_date_time_from_last_trade_time_in_chart: {}, maximum_show_quantity: {}, order_submitted: {}, is_snapshot: {}, is_first_message_in_batch: {}, is_last_message_in_batch: {}, external_last_action_date_time_utc: {})", self.size(), self.r#type(), self.base_size(), self.is_order_deleted(), self.internal_order_id(), self.order_status_code(), self.order_status_before_pending_modify(), self.order_status_before_pending_cancel(), self.service_order_id(), self.actual_symbol(), self.order_type(), self.buy_sell(), self.price1(), self.price2(), self.order_quantity(), self.filled_quantity(), self.average_fill_price(), self.realtime_fill_status(), self.is_resting_order_during_fill(), self.order_reject_type(), self.trade_account(), self.sub_account_identifier(), self.internal_order_id_modifier_for_service(), self.fix_client_order_id(), self.sequence_number_based_client_order_id(), self.client_order_id_for_dtc_server(), self.previous_client_order_id_for_dtc_server(), self.exchange_order_id(), self.originating_client_username(), self.entry_date_time(), self.last_action_date_time(), self.service_update_date_time_utc(), self.order_entry_time_for_service(), self.last_modify_time_for_service(), self.good_till_date_time(), self.time_in_force(), self.open_close(), self.trail_stop_offset1(), self.trail_stop_step(), self.trail_trigger_price(), self.trailing_stop_trigger_offset(), self.trail_trigger_hit(), self.trail_to_break_even_stop_offset(), self.maximum_chase_amount_as_price(), self.initial_chase_order_price1(), self.initial_last_trade_price_for_chase_orders(), self.trailing_stop_trigger_oco_group_number(), self.last_modify_price1(), self.last_modify_quantity(), self.cumulative_order_quantity_from_parent_fills(), self.prior_filled_quantity(), self.tick_size(), self.value_format(), self.price_multiplier(), self.parent_internal_order_id(), self.target_child_internal_order_id(), self.stop_child_internal_order_id(), self.attached_order_price_offset1(), self.link_internal_order_id(), self.oco_group_internal_order_id(), self.oco_sibling_internal_order_id(), self.disable_child_and_sibling_related_actions(), self.oco_managed_by_service(), self.bracket_order_server_managed(), self.last_order_action_source(), self.stop_limit_order_stop_price_triggered(), self.oco_full_sibling_cancel_on_partial_fill(), self.reverse_on_complete_fill(), self.support_scale_in(), self.support_scale_out(), self.source_chart_number(), self.source_chartbook_file_name(), self.is_automated_order(), self.simulated_order(), self.is_chart_replaying(), self.attached_order_oco_group_number(), self.last_fill_execution_service_id(), self.fill_count(), self.last_fill_quantity(), self.last_fill_price(), self.last_fill_date_time_utc(), self.rejected_stop_oco_sibling_internal_order_id(), self.rejected_stop_replacement_market_order_quantity(), self.evaluating_for_fill(), self.last_processed_time_sales_record_sequence_for_prices(), self.is_market_data_management_of_order_enabled(), self.text_tag(), self.timed_out_order_requested_status_date_time(), self.requested_status_for_timed_out_order(), self.send_flatten_market_order_when_related_orders_confirmed_canceled(), self.quantity_to_increase_from_parent_fill(), self.move_to_breakeven_stop_reference_price(), self.quantity_triggered_stop_quantity_for_trigger(), self.accumulated_trade_volume_for_triggered_stop(), self.bid_ask_quantity_stop_initial_trigger_met(), self.need_to_override_lock(), self.current_market_price(), self.current_market_date_time(), self.support_order_fill_billing(), self.is_billable(), self.quantity_for_billing(), self.number_of_failed_order_modifications(), self.dtc_server_index(), self.clearing_firm_id(), self.sender_sub_id(), self.sender_location_id(), self.self_match_prevention_id(), self.cti_code(), self.obtain_order_action_date_time_from_last_trade_time_in_chart(), self.maximum_show_quantity(), self.order_submitted(), self.is_snapshot(), self.is_first_message_in_batch(), self.is_last_message_in_batch(), self.external_last_action_date_time_utc()).as_str())
    }
}

impl crate::Message for TradeOrderVLS {
    type Data = TradeOrderVLSData;

    const TYPE: u16 = SC_TRADE_ORDER;
    const BASE_SIZE: usize = 535;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, TradeOrderVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const TradeOrderVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for TradeOrderVLS {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const TradeOrderVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl crate::Message for TradeOrderVLSUnsafe {
    type Data = TradeOrderVLSData;

    const TYPE: u16 = SC_TRADE_ORDER;
    const BASE_SIZE: usize = 535;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, TradeOrderVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const TradeOrderVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for TradeOrderVLSUnsafe {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const TradeOrderVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl TradeOrder for TradeOrderVLS {
    type Safe = TradeOrderVLS;
    type Unsafe = TradeOrderVLSUnsafe;

    fn is_order_deleted(&self) -> bool {
        self.is_order_deleted
    }

    fn internal_order_id(&self) -> u64 {
        u64::from_le(self.internal_order_id)
    }

    fn order_status_code(&self) -> u16 {
        u16::from_le(self.order_status_code)
    }

    fn order_status_before_pending_modify(&self) -> u16 {
        u16::from_le(self.order_status_before_pending_modify)
    }

    fn order_status_before_pending_cancel(&self) -> u16 {
        u16::from_le(self.order_status_before_pending_cancel)
    }

    fn service_order_id(&self) -> &str {
        get_vls(self, self.service_order_id)
    }

    fn actual_symbol(&self) -> &str {
        get_vls(self, self.actual_symbol)
    }

    fn order_type(&self) -> i32 {
        i32::from_le(self.order_type)
    }

    fn buy_sell(&self) -> u16 {
        u16::from_le(self.buy_sell)
    }

    fn price1(&self) -> f64 {
        f64_le(self.price1)
    }

    fn price2(&self) -> f64 {
        f64_le(self.price2)
    }

    fn order_quantity(&self) -> f64 {
        f64_le(self.order_quantity)
    }

    fn filled_quantity(&self) -> f64 {
        f64_le(self.filled_quantity)
    }

    fn average_fill_price(&self) -> f64 {
        f64_le(self.average_fill_price)
    }

    fn realtime_fill_status(&self) -> i32 {
        i32::from_le(self.realtime_fill_status)
    }

    fn is_resting_order_during_fill(&self) -> bool {
        self.is_resting_order_during_fill
    }

    fn order_reject_type(&self) -> i32 {
        i32::from_le(self.order_reject_type)
    }

    fn trade_account(&self) -> &str {
        get_vls(self, self.trade_account)
    }

    fn sub_account_identifier(&self) -> u32 {
        u32::from_le(self.sub_account_identifier)
    }

    fn internal_order_id_modifier_for_service(&self) -> i32 {
        i32::from_le(self.internal_order_id_modifier_for_service)
    }

    fn fix_client_order_id(&self) -> &str {
        get_vls(self, self.fix_client_order_id)
    }

    fn sequence_number_based_client_order_id(&self) -> u32 {
        u32::from_le(self.sequence_number_based_client_order_id)
    }

    fn client_order_id_for_dtc_server(&self) -> &str {
        get_vls(self, self.client_order_id_for_dtc_server)
    }

    fn previous_client_order_id_for_dtc_server(&self) -> &str {
        get_vls(self, self.previous_client_order_id_for_dtc_server)
    }

    fn exchange_order_id(&self) -> &str {
        get_vls(self, self.exchange_order_id)
    }

    fn originating_client_username(&self) -> &str {
        get_vls(self, self.originating_client_username)
    }

    fn entry_date_time(&self) -> i64 {
        i64::from_le(self.entry_date_time)
    }

    fn last_action_date_time(&self) -> i64 {
        i64::from_le(self.last_action_date_time)
    }

    fn service_update_date_time_utc(&self) -> i64 {
        i64::from_le(self.service_update_date_time_utc)
    }

    fn order_entry_time_for_service(&self) -> u32 {
        u32::from_le(self.order_entry_time_for_service)
    }

    fn last_modify_time_for_service(&self) -> u32 {
        u32::from_le(self.last_modify_time_for_service)
    }

    fn good_till_date_time(&self) -> i64 {
        i64::from_le(self.good_till_date_time)
    }

    fn time_in_force(&self) -> i32 {
        i32::from_le(self.time_in_force)
    }

    fn open_close(&self) -> u16 {
        u16::from_le(self.open_close)
    }

    fn trail_stop_offset1(&self) -> f64 {
        f64_le(self.trail_stop_offset1)
    }

    fn trail_stop_step(&self) -> f64 {
        f64_le(self.trail_stop_step)
    }

    fn trail_trigger_price(&self) -> f64 {
        f64_le(self.trail_trigger_price)
    }

    fn trailing_stop_trigger_offset(&self) -> f64 {
        f64_le(self.trailing_stop_trigger_offset)
    }

    fn trail_trigger_hit(&self) -> u8 {
        self.trail_trigger_hit
    }

    fn trail_to_break_even_stop_offset(&self) -> f64 {
        f64_le(self.trail_to_break_even_stop_offset)
    }

    fn maximum_chase_amount_as_price(&self) -> f64 {
        f64_le(self.maximum_chase_amount_as_price)
    }

    fn initial_chase_order_price1(&self) -> f64 {
        f64_le(self.initial_chase_order_price1)
    }

    fn initial_last_trade_price_for_chase_orders(&self) -> f64 {
        f64_le(self.initial_last_trade_price_for_chase_orders)
    }

    fn trailing_stop_trigger_oco_group_number(&self) -> i32 {
        i32::from_le(self.trailing_stop_trigger_oco_group_number)
    }

    fn last_modify_price1(&self) -> f64 {
        f64_le(self.last_modify_price1)
    }

    fn last_modify_quantity(&self) -> f64 {
        f64_le(self.last_modify_quantity)
    }

    fn cumulative_order_quantity_from_parent_fills(&self) -> f64 {
        f64_le(self.cumulative_order_quantity_from_parent_fills)
    }

    fn prior_filled_quantity(&self) -> f64 {
        f64_le(self.prior_filled_quantity)
    }

    fn tick_size(&self) -> f32 {
        f32_le(self.tick_size)
    }

    fn value_format(&self) -> i32 {
        i32::from_le(self.value_format)
    }

    fn price_multiplier(&self) -> f32 {
        f32_le(self.price_multiplier)
    }

    fn parent_internal_order_id(&self) -> u64 {
        u64::from_le(self.parent_internal_order_id)
    }

    fn target_child_internal_order_id(&self) -> u64 {
        u64::from_le(self.target_child_internal_order_id)
    }

    fn stop_child_internal_order_id(&self) -> u64 {
        u64::from_le(self.stop_child_internal_order_id)
    }

    fn attached_order_price_offset1(&self) -> f64 {
        f64_le(self.attached_order_price_offset1)
    }

    fn link_internal_order_id(&self) -> u64 {
        u64::from_le(self.link_internal_order_id)
    }

    fn oco_group_internal_order_id(&self) -> u64 {
        u64::from_le(self.oco_group_internal_order_id)
    }

    fn oco_sibling_internal_order_id(&self) -> u64 {
        u64::from_le(self.oco_sibling_internal_order_id)
    }

    fn disable_child_and_sibling_related_actions(&self) -> u8 {
        self.disable_child_and_sibling_related_actions
    }

    fn oco_managed_by_service(&self) -> u8 {
        self.oco_managed_by_service
    }

    fn bracket_order_server_managed(&self) -> u8 {
        self.bracket_order_server_managed
    }

    fn last_order_action_source(&self) -> &str {
        get_vls(self, self.last_order_action_source)
    }

    fn stop_limit_order_stop_price_triggered(&self) -> u8 {
        self.stop_limit_order_stop_price_triggered
    }

    fn oco_full_sibling_cancel_on_partial_fill(&self) -> u8 {
        self.oco_full_sibling_cancel_on_partial_fill
    }

    fn reverse_on_complete_fill(&self) -> u8 {
        self.reverse_on_complete_fill
    }

    fn support_scale_in(&self) -> u8 {
        self.support_scale_in
    }

    fn support_scale_out(&self) -> u8 {
        self.support_scale_out
    }

    fn source_chart_number(&self) -> i32 {
        i32::from_le(self.source_chart_number)
    }

    fn source_chartbook_file_name(&self) -> &str {
        get_vls(self, self.source_chartbook_file_name)
    }

    fn is_automated_order(&self) -> bool {
        self.is_automated_order
    }

    fn simulated_order(&self) -> u8 {
        self.simulated_order
    }

    fn is_chart_replaying(&self) -> bool {
        self.is_chart_replaying
    }

    fn attached_order_oco_group_number(&self) -> i32 {
        i32::from_le(self.attached_order_oco_group_number)
    }

    fn last_fill_execution_service_id(&self) -> &str {
        get_vls(self, self.last_fill_execution_service_id)
    }

    fn fill_count(&self) -> i32 {
        i32::from_le(self.fill_count)
    }

    fn last_fill_quantity(&self) -> f64 {
        f64_le(self.last_fill_quantity)
    }

    fn last_fill_price(&self) -> f64 {
        f64_le(self.last_fill_price)
    }

    fn last_fill_date_time_utc(&self) -> i64 {
        i64::from_le(self.last_fill_date_time_utc)
    }

    fn rejected_stop_oco_sibling_internal_order_id(&self) -> u64 {
        u64::from_le(self.rejected_stop_oco_sibling_internal_order_id)
    }

    fn rejected_stop_replacement_market_order_quantity(&self) -> f64 {
        f64_le(self.rejected_stop_replacement_market_order_quantity)
    }

    fn evaluating_for_fill(&self) -> u8 {
        self.evaluating_for_fill
    }

    fn last_processed_time_sales_record_sequence_for_prices(&self) -> u32 {
        u32::from_le(self.last_processed_time_sales_record_sequence_for_prices)
    }

    fn is_market_data_management_of_order_enabled(&self) -> bool {
        self.is_market_data_management_of_order_enabled
    }

    fn text_tag(&self) -> &str {
        get_vls(self, self.text_tag)
    }

    fn timed_out_order_requested_status_date_time(&self) -> i64 {
        i64::from_le(self.timed_out_order_requested_status_date_time)
    }

    fn requested_status_for_timed_out_order(&self) -> u8 {
        self.requested_status_for_timed_out_order
    }

    fn send_flatten_market_order_when_related_orders_confirmed_canceled(&self) -> u8 {
        self.send_flatten_market_order_when_related_orders_confirmed_canceled
    }

    fn quantity_to_increase_from_parent_fill(&self) -> f64 {
        f64_le(self.quantity_to_increase_from_parent_fill)
    }

    fn move_to_breakeven_stop_reference_price(&self) -> f64 {
        f64_le(self.move_to_breakeven_stop_reference_price)
    }

    fn quantity_triggered_stop_quantity_for_trigger(&self) -> f64 {
        f64_le(self.quantity_triggered_stop_quantity_for_trigger)
    }

    fn accumulated_trade_volume_for_triggered_stop(&self) -> f64 {
        f64_le(self.accumulated_trade_volume_for_triggered_stop)
    }

    fn bid_ask_quantity_stop_initial_trigger_met(&self) -> u8 {
        self.bid_ask_quantity_stop_initial_trigger_met
    }

    fn need_to_override_lock(&self) -> u8 {
        self.need_to_override_lock
    }

    fn current_market_price(&self) -> f64 {
        f64_le(self.current_market_price)
    }

    fn current_market_date_time(&self) -> i64 {
        i64::from_le(self.current_market_date_time)
    }

    fn support_order_fill_billing(&self) -> u8 {
        self.support_order_fill_billing
    }

    fn is_billable(&self) -> bool {
        self.is_billable
    }

    fn quantity_for_billing(&self) -> i32 {
        i32::from_le(self.quantity_for_billing)
    }

    fn number_of_failed_order_modifications(&self) -> u32 {
        u32::from_le(self.number_of_failed_order_modifications)
    }

    fn dtc_server_index(&self) -> i32 {
        i32::from_le(self.dtc_server_index)
    }

    fn clearing_firm_id(&self) -> &str {
        get_vls(self, self.clearing_firm_id)
    }

    fn sender_sub_id(&self) -> &str {
        get_vls(self, self.sender_sub_id)
    }

    fn sender_location_id(&self) -> &str {
        get_vls(self, self.sender_location_id)
    }

    fn self_match_prevention_id(&self) -> &str {
        get_vls(self, self.self_match_prevention_id)
    }

    fn cti_code(&self) -> i32 {
        i32::from_le(self.cti_code)
    }

    fn obtain_order_action_date_time_from_last_trade_time_in_chart(&self) -> u8 {
        self.obtain_order_action_date_time_from_last_trade_time_in_chart
    }

    fn maximum_show_quantity(&self) -> f64 {
        f64_le(self.maximum_show_quantity)
    }

    fn order_submitted(&self) -> u8 {
        self.order_submitted
    }

    fn is_snapshot(&self) -> bool {
        self.is_snapshot
    }

    fn is_first_message_in_batch(&self) -> bool {
        self.is_first_message_in_batch
    }

    fn is_last_message_in_batch(&self) -> bool {
        self.is_last_message_in_batch
    }

    fn external_last_action_date_time_utc(&self) -> i64 {
        i64::from_le(self.external_last_action_date_time_utc)
    }

    fn set_is_order_deleted(&mut self, value: bool) -> &mut Self {
        self.is_order_deleted = value;
        self
    }

    fn set_internal_order_id(&mut self, value: u64) -> &mut Self {
        self.internal_order_id = value.to_le();
        self
    }

    fn set_order_status_code(&mut self, value: u16) -> &mut Self {
        self.order_status_code = value.to_le();
        self
    }

    fn set_order_status_before_pending_modify(&mut self, value: u16) -> &mut Self {
        self.order_status_before_pending_modify = value.to_le();
        self
    }

    fn set_order_status_before_pending_cancel(&mut self, value: u16) -> &mut Self {
        self.order_status_before_pending_cancel = value.to_le();
        self
    }

    fn set_service_order_id(&mut self, value: &str) -> &mut Self {
        self.service_order_id = set_vls(self, self.service_order_id, value);
        self
    }

    fn set_actual_symbol(&mut self, value: &str) -> &mut Self {
        self.actual_symbol = set_vls(self, self.actual_symbol, value);
        self
    }

    fn set_order_type(&mut self, value: i32) -> &mut Self {
        self.order_type = value.to_le();
        self
    }

    fn set_buy_sell(&mut self, value: u16) -> &mut Self {
        self.buy_sell = value.to_le();
        self
    }

    fn set_price1(&mut self, value: f64) -> &mut Self {
        self.price1 = f64_le(value);
        self
    }

    fn set_price2(&mut self, value: f64) -> &mut Self {
        self.price2 = f64_le(value);
        self
    }

    fn set_order_quantity(&mut self, value: f64) -> &mut Self {
        self.order_quantity = f64_le(value);
        self
    }

    fn set_filled_quantity(&mut self, value: f64) -> &mut Self {
        self.filled_quantity = f64_le(value);
        self
    }

    fn set_average_fill_price(&mut self, value: f64) -> &mut Self {
        self.average_fill_price = f64_le(value);
        self
    }

    fn set_realtime_fill_status(&mut self, value: i32) -> &mut Self {
        self.realtime_fill_status = value.to_le();
        self
    }

    fn set_is_resting_order_during_fill(&mut self, value: bool) -> &mut Self {
        self.is_resting_order_during_fill = value;
        self
    }

    fn set_order_reject_type(&mut self, value: i32) -> &mut Self {
        self.order_reject_type = value.to_le();
        self
    }

    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        self.trade_account = set_vls(self, self.trade_account, value);
        self
    }

    fn set_sub_account_identifier(&mut self, value: u32) -> &mut Self {
        self.sub_account_identifier = value.to_le();
        self
    }

    fn set_internal_order_id_modifier_for_service(&mut self, value: i32) -> &mut Self {
        self.internal_order_id_modifier_for_service = value.to_le();
        self
    }

    fn set_fix_client_order_id(&mut self, value: &str) -> &mut Self {
        self.fix_client_order_id = set_vls(self, self.fix_client_order_id, value);
        self
    }

    fn set_sequence_number_based_client_order_id(&mut self, value: u32) -> &mut Self {
        self.sequence_number_based_client_order_id = value.to_le();
        self
    }

    fn set_client_order_id_for_dtc_server(&mut self, value: &str) -> &mut Self {
        self.client_order_id_for_dtc_server =
            set_vls(self, self.client_order_id_for_dtc_server, value);
        self
    }

    fn set_previous_client_order_id_for_dtc_server(&mut self, value: &str) -> &mut Self {
        self.previous_client_order_id_for_dtc_server =
            set_vls(self, self.previous_client_order_id_for_dtc_server, value);
        self
    }

    fn set_exchange_order_id(&mut self, value: &str) -> &mut Self {
        self.exchange_order_id = set_vls(self, self.exchange_order_id, value);
        self
    }

    fn set_originating_client_username(&mut self, value: &str) -> &mut Self {
        self.originating_client_username = set_vls(self, self.originating_client_username, value);
        self
    }

    fn set_entry_date_time(&mut self, value: i64) -> &mut Self {
        self.entry_date_time = value.to_le();
        self
    }

    fn set_last_action_date_time(&mut self, value: i64) -> &mut Self {
        self.last_action_date_time = value.to_le();
        self
    }

    fn set_service_update_date_time_utc(&mut self, value: i64) -> &mut Self {
        self.service_update_date_time_utc = value.to_le();
        self
    }

    fn set_order_entry_time_for_service(&mut self, value: u32) -> &mut Self {
        self.order_entry_time_for_service = value.to_le();
        self
    }

    fn set_last_modify_time_for_service(&mut self, value: u32) -> &mut Self {
        self.last_modify_time_for_service = value.to_le();
        self
    }

    fn set_good_till_date_time(&mut self, value: i64) -> &mut Self {
        self.good_till_date_time = value.to_le();
        self
    }

    fn set_time_in_force(&mut self, value: i32) -> &mut Self {
        self.time_in_force = value.to_le();
        self
    }

    fn set_open_close(&mut self, value: u16) -> &mut Self {
        self.open_close = value.to_le();
        self
    }

    fn set_trail_stop_offset1(&mut self, value: f64) -> &mut Self {
        self.trail_stop_offset1 = f64_le(value);
        self
    }

    fn set_trail_stop_step(&mut self, value: f64) -> &mut Self {
        self.trail_stop_step = f64_le(value);
        self
    }

    fn set_trail_trigger_price(&mut self, value: f64) -> &mut Self {
        self.trail_trigger_price = f64_le(value);
        self
    }

    fn set_trailing_stop_trigger_offset(&mut self, value: f64) -> &mut Self {
        self.trailing_stop_trigger_offset = f64_le(value);
        self
    }

    fn set_trail_trigger_hit(&mut self, value: u8) -> &mut Self {
        self.trail_trigger_hit = value;
        self
    }

    fn set_trail_to_break_even_stop_offset(&mut self, value: f64) -> &mut Self {
        self.trail_to_break_even_stop_offset = f64_le(value);
        self
    }

    fn set_maximum_chase_amount_as_price(&mut self, value: f64) -> &mut Self {
        self.maximum_chase_amount_as_price = f64_le(value);
        self
    }

    fn set_initial_chase_order_price1(&mut self, value: f64) -> &mut Self {
        self.initial_chase_order_price1 = f64_le(value);
        self
    }

    fn set_initial_last_trade_price_for_chase_orders(&mut self, value: f64) -> &mut Self {
        self.initial_last_trade_price_for_chase_orders = f64_le(value);
        self
    }

    fn set_trailing_stop_trigger_oco_group_number(&mut self, value: i32) -> &mut Self {
        self.trailing_stop_trigger_oco_group_number = value.to_le();
        self
    }

    fn set_last_modify_price1(&mut self, value: f64) -> &mut Self {
        self.last_modify_price1 = f64_le(value);
        self
    }

    fn set_last_modify_quantity(&mut self, value: f64) -> &mut Self {
        self.last_modify_quantity = f64_le(value);
        self
    }

    fn set_cumulative_order_quantity_from_parent_fills(&mut self, value: f64) -> &mut Self {
        self.cumulative_order_quantity_from_parent_fills = f64_le(value);
        self
    }

    fn set_prior_filled_quantity(&mut self, value: f64) -> &mut Self {
        self.prior_filled_quantity = f64_le(value);
        self
    }

    fn set_tick_size(&mut self, value: f32) -> &mut Self {
        self.tick_size = f32_le(value);
        self
    }

    fn set_value_format(&mut self, value: i32) -> &mut Self {
        self.value_format = value.to_le();
        self
    }

    fn set_price_multiplier(&mut self, value: f32) -> &mut Self {
        self.price_multiplier = f32_le(value);
        self
    }

    fn set_parent_internal_order_id(&mut self, value: u64) -> &mut Self {
        self.parent_internal_order_id = value.to_le();
        self
    }

    fn set_target_child_internal_order_id(&mut self, value: u64) -> &mut Self {
        self.target_child_internal_order_id = value.to_le();
        self
    }

    fn set_stop_child_internal_order_id(&mut self, value: u64) -> &mut Self {
        self.stop_child_internal_order_id = value.to_le();
        self
    }

    fn set_attached_order_price_offset1(&mut self, value: f64) -> &mut Self {
        self.attached_order_price_offset1 = f64_le(value);
        self
    }

    fn set_link_internal_order_id(&mut self, value: u64) -> &mut Self {
        self.link_internal_order_id = value.to_le();
        self
    }

    fn set_oco_group_internal_order_id(&mut self, value: u64) -> &mut Self {
        self.oco_group_internal_order_id = value.to_le();
        self
    }

    fn set_oco_sibling_internal_order_id(&mut self, value: u64) -> &mut Self {
        self.oco_sibling_internal_order_id = value.to_le();
        self
    }

    fn set_disable_child_and_sibling_related_actions(&mut self, value: u8) -> &mut Self {
        self.disable_child_and_sibling_related_actions = value;
        self
    }

    fn set_oco_managed_by_service(&mut self, value: u8) -> &mut Self {
        self.oco_managed_by_service = value;
        self
    }

    fn set_bracket_order_server_managed(&mut self, value: u8) -> &mut Self {
        self.bracket_order_server_managed = value;
        self
    }

    fn set_last_order_action_source(&mut self, value: &str) -> &mut Self {
        self.last_order_action_source = set_vls(self, self.last_order_action_source, value);
        self
    }

    fn set_stop_limit_order_stop_price_triggered(&mut self, value: u8) -> &mut Self {
        self.stop_limit_order_stop_price_triggered = value;
        self
    }

    fn set_oco_full_sibling_cancel_on_partial_fill(&mut self, value: u8) -> &mut Self {
        self.oco_full_sibling_cancel_on_partial_fill = value;
        self
    }

    fn set_reverse_on_complete_fill(&mut self, value: u8) -> &mut Self {
        self.reverse_on_complete_fill = value;
        self
    }

    fn set_support_scale_in(&mut self, value: u8) -> &mut Self {
        self.support_scale_in = value;
        self
    }

    fn set_support_scale_out(&mut self, value: u8) -> &mut Self {
        self.support_scale_out = value;
        self
    }

    fn set_source_chart_number(&mut self, value: i32) -> &mut Self {
        self.source_chart_number = value.to_le();
        self
    }

    fn set_source_chartbook_file_name(&mut self, value: &str) -> &mut Self {
        self.source_chartbook_file_name = set_vls(self, self.source_chartbook_file_name, value);
        self
    }

    fn set_is_automated_order(&mut self, value: bool) -> &mut Self {
        self.is_automated_order = value;
        self
    }

    fn set_simulated_order(&mut self, value: u8) -> &mut Self {
        self.simulated_order = value;
        self
    }

    fn set_is_chart_replaying(&mut self, value: bool) -> &mut Self {
        self.is_chart_replaying = value;
        self
    }

    fn set_attached_order_oco_group_number(&mut self, value: i32) -> &mut Self {
        self.attached_order_oco_group_number = value.to_le();
        self
    }

    fn set_last_fill_execution_service_id(&mut self, value: &str) -> &mut Self {
        self.last_fill_execution_service_id =
            set_vls(self, self.last_fill_execution_service_id, value);
        self
    }

    fn set_fill_count(&mut self, value: i32) -> &mut Self {
        self.fill_count = value.to_le();
        self
    }

    fn set_last_fill_quantity(&mut self, value: f64) -> &mut Self {
        self.last_fill_quantity = f64_le(value);
        self
    }

    fn set_last_fill_price(&mut self, value: f64) -> &mut Self {
        self.last_fill_price = f64_le(value);
        self
    }

    fn set_last_fill_date_time_utc(&mut self, value: i64) -> &mut Self {
        self.last_fill_date_time_utc = value.to_le();
        self
    }

    fn set_rejected_stop_oco_sibling_internal_order_id(&mut self, value: u64) -> &mut Self {
        self.rejected_stop_oco_sibling_internal_order_id = value.to_le();
        self
    }

    fn set_rejected_stop_replacement_market_order_quantity(&mut self, value: f64) -> &mut Self {
        self.rejected_stop_replacement_market_order_quantity = f64_le(value);
        self
    }

    fn set_evaluating_for_fill(&mut self, value: u8) -> &mut Self {
        self.evaluating_for_fill = value;
        self
    }

    fn set_last_processed_time_sales_record_sequence_for_prices(
        &mut self,
        value: u32,
    ) -> &mut Self {
        self.last_processed_time_sales_record_sequence_for_prices = value.to_le();
        self
    }

    fn set_is_market_data_management_of_order_enabled(&mut self, value: bool) -> &mut Self {
        self.is_market_data_management_of_order_enabled = value;
        self
    }

    fn set_text_tag(&mut self, value: &str) -> &mut Self {
        self.text_tag = set_vls(self, self.text_tag, value);
        self
    }

    fn set_timed_out_order_requested_status_date_time(&mut self, value: i64) -> &mut Self {
        self.timed_out_order_requested_status_date_time = value.to_le();
        self
    }

    fn set_requested_status_for_timed_out_order(&mut self, value: u8) -> &mut Self {
        self.requested_status_for_timed_out_order = value;
        self
    }

    fn set_send_flatten_market_order_when_related_orders_confirmed_canceled(
        &mut self,
        value: u8,
    ) -> &mut Self {
        self.send_flatten_market_order_when_related_orders_confirmed_canceled = value;
        self
    }

    fn set_quantity_to_increase_from_parent_fill(&mut self, value: f64) -> &mut Self {
        self.quantity_to_increase_from_parent_fill = f64_le(value);
        self
    }

    fn set_move_to_breakeven_stop_reference_price(&mut self, value: f64) -> &mut Self {
        self.move_to_breakeven_stop_reference_price = f64_le(value);
        self
    }

    fn set_quantity_triggered_stop_quantity_for_trigger(&mut self, value: f64) -> &mut Self {
        self.quantity_triggered_stop_quantity_for_trigger = f64_le(value);
        self
    }

    fn set_accumulated_trade_volume_for_triggered_stop(&mut self, value: f64) -> &mut Self {
        self.accumulated_trade_volume_for_triggered_stop = f64_le(value);
        self
    }

    fn set_bid_ask_quantity_stop_initial_trigger_met(&mut self, value: u8) -> &mut Self {
        self.bid_ask_quantity_stop_initial_trigger_met = value;
        self
    }

    fn set_need_to_override_lock(&mut self, value: u8) -> &mut Self {
        self.need_to_override_lock = value;
        self
    }

    fn set_current_market_price(&mut self, value: f64) -> &mut Self {
        self.current_market_price = f64_le(value);
        self
    }

    fn set_current_market_date_time(&mut self, value: i64) -> &mut Self {
        self.current_market_date_time = value.to_le();
        self
    }

    fn set_support_order_fill_billing(&mut self, value: u8) -> &mut Self {
        self.support_order_fill_billing = value;
        self
    }

    fn set_is_billable(&mut self, value: bool) -> &mut Self {
        self.is_billable = value;
        self
    }

    fn set_quantity_for_billing(&mut self, value: i32) -> &mut Self {
        self.quantity_for_billing = value.to_le();
        self
    }

    fn set_number_of_failed_order_modifications(&mut self, value: u32) -> &mut Self {
        self.number_of_failed_order_modifications = value.to_le();
        self
    }

    fn set_dtc_server_index(&mut self, value: i32) -> &mut Self {
        self.dtc_server_index = value.to_le();
        self
    }

    fn set_clearing_firm_id(&mut self, value: &str) -> &mut Self {
        self.clearing_firm_id = set_vls(self, self.clearing_firm_id, value);
        self
    }

    fn set_sender_sub_id(&mut self, value: &str) -> &mut Self {
        self.sender_sub_id = set_vls(self, self.sender_sub_id, value);
        self
    }

    fn set_sender_location_id(&mut self, value: &str) -> &mut Self {
        self.sender_location_id = set_vls(self, self.sender_location_id, value);
        self
    }

    fn set_self_match_prevention_id(&mut self, value: &str) -> &mut Self {
        self.self_match_prevention_id = set_vls(self, self.self_match_prevention_id, value);
        self
    }

    fn set_cti_code(&mut self, value: i32) -> &mut Self {
        self.cti_code = value.to_le();
        self
    }

    fn set_obtain_order_action_date_time_from_last_trade_time_in_chart(
        &mut self,
        value: u8,
    ) -> &mut Self {
        self.obtain_order_action_date_time_from_last_trade_time_in_chart = value;
        self
    }

    fn set_maximum_show_quantity(&mut self, value: f64) -> &mut Self {
        self.maximum_show_quantity = f64_le(value);
        self
    }

    fn set_order_submitted(&mut self, value: u8) -> &mut Self {
        self.order_submitted = value;
        self
    }

    fn set_is_snapshot(&mut self, value: bool) -> &mut Self {
        self.is_snapshot = value;
        self
    }

    fn set_is_first_message_in_batch(&mut self, value: bool) -> &mut Self {
        self.is_first_message_in_batch = value;
        self
    }

    fn set_is_last_message_in_batch(&mut self, value: bool) -> &mut Self {
        self.is_last_message_in_batch = value;
        self
    }

    fn set_external_last_action_date_time_utc(&mut self, value: i64) -> &mut Self {
        self.external_last_action_date_time_utc = value.to_le();
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

impl TradeOrder for TradeOrderVLSUnsafe {
    type Safe = TradeOrderVLS;
    type Unsafe = TradeOrderVLSUnsafe;

    fn is_order_deleted(&self) -> bool {
        if self.is_out_of_bounds(7) {
            false
        } else {
            self.is_order_deleted
        }
    }

    fn internal_order_id(&self) -> u64 {
        if self.is_out_of_bounds(15) {
            0u64.to_le()
        } else {
            u64::from_le(self.internal_order_id)
        }
    }

    fn order_status_code(&self) -> u16 {
        if self.is_out_of_bounds(17) {
            0u16.to_le()
        } else {
            u16::from_le(self.order_status_code)
        }
    }

    fn order_status_before_pending_modify(&self) -> u16 {
        if self.is_out_of_bounds(19) {
            0u16.to_le()
        } else {
            u16::from_le(self.order_status_before_pending_modify)
        }
    }

    fn order_status_before_pending_cancel(&self) -> u16 {
        if self.is_out_of_bounds(21) {
            0u16.to_le()
        } else {
            u16::from_le(self.order_status_before_pending_cancel)
        }
    }

    fn service_order_id(&self) -> &str {
        if self.is_out_of_bounds(25) {
            ""
        } else {
            get_vls(self, self.service_order_id)
        }
    }

    fn actual_symbol(&self) -> &str {
        if self.is_out_of_bounds(29) {
            ""
        } else {
            get_vls(self, self.actual_symbol)
        }
    }

    fn order_type(&self) -> i32 {
        if self.is_out_of_bounds(33) {
            0i32.to_le()
        } else {
            i32::from_le(self.order_type)
        }
    }

    fn buy_sell(&self) -> u16 {
        if self.is_out_of_bounds(35) {
            0u16.to_le()
        } else {
            u16::from_le(self.buy_sell)
        }
    }

    fn price1(&self) -> f64 {
        if self.is_out_of_bounds(43) {
            0.0
        } else {
            f64_le(self.price1)
        }
    }

    fn price2(&self) -> f64 {
        if self.is_out_of_bounds(51) {
            0.0
        } else {
            f64_le(self.price2)
        }
    }

    fn order_quantity(&self) -> f64 {
        if self.is_out_of_bounds(59) {
            0.0
        } else {
            f64_le(self.order_quantity)
        }
    }

    fn filled_quantity(&self) -> f64 {
        if self.is_out_of_bounds(67) {
            0.0
        } else {
            f64_le(self.filled_quantity)
        }
    }

    fn average_fill_price(&self) -> f64 {
        if self.is_out_of_bounds(75) {
            0.0
        } else {
            f64_le(self.average_fill_price)
        }
    }

    fn realtime_fill_status(&self) -> i32 {
        if self.is_out_of_bounds(79) {
            0i32.to_le()
        } else {
            i32::from_le(self.realtime_fill_status)
        }
    }

    fn is_resting_order_during_fill(&self) -> bool {
        if self.is_out_of_bounds(80) {
            false
        } else {
            self.is_resting_order_during_fill
        }
    }

    fn order_reject_type(&self) -> i32 {
        if self.is_out_of_bounds(84) {
            0i32.to_le()
        } else {
            i32::from_le(self.order_reject_type)
        }
    }

    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(88) {
            ""
        } else {
            get_vls(self, self.trade_account)
        }
    }

    fn sub_account_identifier(&self) -> u32 {
        if self.is_out_of_bounds(92) {
            0u32.to_le()
        } else {
            u32::from_le(self.sub_account_identifier)
        }
    }

    fn internal_order_id_modifier_for_service(&self) -> i32 {
        if self.is_out_of_bounds(96) {
            0i32.to_le()
        } else {
            i32::from_le(self.internal_order_id_modifier_for_service)
        }
    }

    fn fix_client_order_id(&self) -> &str {
        if self.is_out_of_bounds(100) {
            ""
        } else {
            get_vls(self, self.fix_client_order_id)
        }
    }

    fn sequence_number_based_client_order_id(&self) -> u32 {
        if self.is_out_of_bounds(104) {
            0u32.to_le()
        } else {
            u32::from_le(self.sequence_number_based_client_order_id)
        }
    }

    fn client_order_id_for_dtc_server(&self) -> &str {
        if self.is_out_of_bounds(108) {
            ""
        } else {
            get_vls(self, self.client_order_id_for_dtc_server)
        }
    }

    fn previous_client_order_id_for_dtc_server(&self) -> &str {
        if self.is_out_of_bounds(112) {
            ""
        } else {
            get_vls(self, self.previous_client_order_id_for_dtc_server)
        }
    }

    fn exchange_order_id(&self) -> &str {
        if self.is_out_of_bounds(116) {
            ""
        } else {
            get_vls(self, self.exchange_order_id)
        }
    }

    fn originating_client_username(&self) -> &str {
        if self.is_out_of_bounds(120) {
            ""
        } else {
            get_vls(self, self.originating_client_username)
        }
    }

    fn entry_date_time(&self) -> i64 {
        if self.is_out_of_bounds(128) {
            0i64.to_le()
        } else {
            i64::from_le(self.entry_date_time)
        }
    }

    fn last_action_date_time(&self) -> i64 {
        if self.is_out_of_bounds(136) {
            0i64.to_le()
        } else {
            i64::from_le(self.last_action_date_time)
        }
    }

    fn service_update_date_time_utc(&self) -> i64 {
        if self.is_out_of_bounds(144) {
            0i64.to_le()
        } else {
            i64::from_le(self.service_update_date_time_utc)
        }
    }

    fn order_entry_time_for_service(&self) -> u32 {
        if self.is_out_of_bounds(148) {
            0u32.to_le()
        } else {
            u32::from_le(self.order_entry_time_for_service)
        }
    }

    fn last_modify_time_for_service(&self) -> u32 {
        if self.is_out_of_bounds(152) {
            0u32.to_le()
        } else {
            u32::from_le(self.last_modify_time_for_service)
        }
    }

    fn good_till_date_time(&self) -> i64 {
        if self.is_out_of_bounds(160) {
            0i64.to_le()
        } else {
            i64::from_le(self.good_till_date_time)
        }
    }

    fn time_in_force(&self) -> i32 {
        if self.is_out_of_bounds(164) {
            0i32.to_le()
        } else {
            i32::from_le(self.time_in_force)
        }
    }

    fn open_close(&self) -> u16 {
        if self.is_out_of_bounds(166) {
            0u16.to_le()
        } else {
            u16::from_le(self.open_close)
        }
    }

    fn trail_stop_offset1(&self) -> f64 {
        if self.is_out_of_bounds(174) {
            0.0
        } else {
            f64_le(self.trail_stop_offset1)
        }
    }

    fn trail_stop_step(&self) -> f64 {
        if self.is_out_of_bounds(182) {
            0.0
        } else {
            f64_le(self.trail_stop_step)
        }
    }

    fn trail_trigger_price(&self) -> f64 {
        if self.is_out_of_bounds(190) {
            0.0
        } else {
            f64_le(self.trail_trigger_price)
        }
    }

    fn trailing_stop_trigger_offset(&self) -> f64 {
        if self.is_out_of_bounds(198) {
            0.0
        } else {
            f64_le(self.trailing_stop_trigger_offset)
        }
    }

    fn trail_trigger_hit(&self) -> u8 {
        if self.is_out_of_bounds(199) {
            0
        } else {
            self.trail_trigger_hit
        }
    }

    fn trail_to_break_even_stop_offset(&self) -> f64 {
        if self.is_out_of_bounds(207) {
            0.0
        } else {
            f64_le(self.trail_to_break_even_stop_offset)
        }
    }

    fn maximum_chase_amount_as_price(&self) -> f64 {
        if self.is_out_of_bounds(215) {
            0.0
        } else {
            f64_le(self.maximum_chase_amount_as_price)
        }
    }

    fn initial_chase_order_price1(&self) -> f64 {
        if self.is_out_of_bounds(223) {
            0.0
        } else {
            f64_le(self.initial_chase_order_price1)
        }
    }

    fn initial_last_trade_price_for_chase_orders(&self) -> f64 {
        if self.is_out_of_bounds(231) {
            0.0
        } else {
            f64_le(self.initial_last_trade_price_for_chase_orders)
        }
    }

    fn trailing_stop_trigger_oco_group_number(&self) -> i32 {
        if self.is_out_of_bounds(235) {
            0i32.to_le()
        } else {
            i32::from_le(self.trailing_stop_trigger_oco_group_number)
        }
    }

    fn last_modify_price1(&self) -> f64 {
        if self.is_out_of_bounds(243) {
            0.0
        } else {
            f64_le(self.last_modify_price1)
        }
    }

    fn last_modify_quantity(&self) -> f64 {
        if self.is_out_of_bounds(251) {
            0.0
        } else {
            f64_le(self.last_modify_quantity)
        }
    }

    fn cumulative_order_quantity_from_parent_fills(&self) -> f64 {
        if self.is_out_of_bounds(259) {
            0.0
        } else {
            f64_le(self.cumulative_order_quantity_from_parent_fills)
        }
    }

    fn prior_filled_quantity(&self) -> f64 {
        if self.is_out_of_bounds(267) {
            0.0
        } else {
            f64_le(self.prior_filled_quantity)
        }
    }

    fn tick_size(&self) -> f32 {
        if self.is_out_of_bounds(271) {
            0.0
        } else {
            f32_le(self.tick_size)
        }
    }

    fn value_format(&self) -> i32 {
        if self.is_out_of_bounds(275) {
            0i32.to_le()
        } else {
            i32::from_le(self.value_format)
        }
    }

    fn price_multiplier(&self) -> f32 {
        if self.is_out_of_bounds(279) {
            0.0
        } else {
            f32_le(self.price_multiplier)
        }
    }

    fn parent_internal_order_id(&self) -> u64 {
        if self.is_out_of_bounds(287) {
            0u64.to_le()
        } else {
            u64::from_le(self.parent_internal_order_id)
        }
    }

    fn target_child_internal_order_id(&self) -> u64 {
        if self.is_out_of_bounds(295) {
            0u64.to_le()
        } else {
            u64::from_le(self.target_child_internal_order_id)
        }
    }

    fn stop_child_internal_order_id(&self) -> u64 {
        if self.is_out_of_bounds(303) {
            0u64.to_le()
        } else {
            u64::from_le(self.stop_child_internal_order_id)
        }
    }

    fn attached_order_price_offset1(&self) -> f64 {
        if self.is_out_of_bounds(311) {
            0.0
        } else {
            f64_le(self.attached_order_price_offset1)
        }
    }

    fn link_internal_order_id(&self) -> u64 {
        if self.is_out_of_bounds(319) {
            0u64.to_le()
        } else {
            u64::from_le(self.link_internal_order_id)
        }
    }

    fn oco_group_internal_order_id(&self) -> u64 {
        if self.is_out_of_bounds(327) {
            0u64.to_le()
        } else {
            u64::from_le(self.oco_group_internal_order_id)
        }
    }

    fn oco_sibling_internal_order_id(&self) -> u64 {
        if self.is_out_of_bounds(335) {
            0u64.to_le()
        } else {
            u64::from_le(self.oco_sibling_internal_order_id)
        }
    }

    fn disable_child_and_sibling_related_actions(&self) -> u8 {
        if self.is_out_of_bounds(336) {
            0
        } else {
            self.disable_child_and_sibling_related_actions
        }
    }

    fn oco_managed_by_service(&self) -> u8 {
        if self.is_out_of_bounds(337) {
            0
        } else {
            self.oco_managed_by_service
        }
    }

    fn bracket_order_server_managed(&self) -> u8 {
        if self.is_out_of_bounds(338) {
            0
        } else {
            self.bracket_order_server_managed
        }
    }

    fn last_order_action_source(&self) -> &str {
        if self.is_out_of_bounds(342) {
            ""
        } else {
            get_vls(self, self.last_order_action_source)
        }
    }

    fn stop_limit_order_stop_price_triggered(&self) -> u8 {
        if self.is_out_of_bounds(343) {
            0
        } else {
            self.stop_limit_order_stop_price_triggered
        }
    }

    fn oco_full_sibling_cancel_on_partial_fill(&self) -> u8 {
        if self.is_out_of_bounds(344) {
            0
        } else {
            self.oco_full_sibling_cancel_on_partial_fill
        }
    }

    fn reverse_on_complete_fill(&self) -> u8 {
        if self.is_out_of_bounds(345) {
            0
        } else {
            self.reverse_on_complete_fill
        }
    }

    fn support_scale_in(&self) -> u8 {
        if self.is_out_of_bounds(346) {
            0
        } else {
            self.support_scale_in
        }
    }

    fn support_scale_out(&self) -> u8 {
        if self.is_out_of_bounds(347) {
            0
        } else {
            self.support_scale_out
        }
    }

    fn source_chart_number(&self) -> i32 {
        if self.is_out_of_bounds(351) {
            0i32.to_le()
        } else {
            i32::from_le(self.source_chart_number)
        }
    }

    fn source_chartbook_file_name(&self) -> &str {
        if self.is_out_of_bounds(355) {
            ""
        } else {
            get_vls(self, self.source_chartbook_file_name)
        }
    }

    fn is_automated_order(&self) -> bool {
        if self.is_out_of_bounds(356) {
            false
        } else {
            self.is_automated_order
        }
    }

    fn simulated_order(&self) -> u8 {
        if self.is_out_of_bounds(357) {
            0
        } else {
            self.simulated_order
        }
    }

    fn is_chart_replaying(&self) -> bool {
        if self.is_out_of_bounds(358) {
            false
        } else {
            self.is_chart_replaying
        }
    }

    fn attached_order_oco_group_number(&self) -> i32 {
        if self.is_out_of_bounds(362) {
            0i32.to_le()
        } else {
            i32::from_le(self.attached_order_oco_group_number)
        }
    }

    fn last_fill_execution_service_id(&self) -> &str {
        if self.is_out_of_bounds(366) {
            ""
        } else {
            get_vls(self, self.last_fill_execution_service_id)
        }
    }

    fn fill_count(&self) -> i32 {
        if self.is_out_of_bounds(370) {
            0i32.to_le()
        } else {
            i32::from_le(self.fill_count)
        }
    }

    fn last_fill_quantity(&self) -> f64 {
        if self.is_out_of_bounds(378) {
            0.0
        } else {
            f64_le(self.last_fill_quantity)
        }
    }

    fn last_fill_price(&self) -> f64 {
        if self.is_out_of_bounds(386) {
            0.0
        } else {
            f64_le(self.last_fill_price)
        }
    }

    fn last_fill_date_time_utc(&self) -> i64 {
        if self.is_out_of_bounds(394) {
            0i64.to_le()
        } else {
            i64::from_le(self.last_fill_date_time_utc)
        }
    }

    fn rejected_stop_oco_sibling_internal_order_id(&self) -> u64 {
        if self.is_out_of_bounds(402) {
            0u64.to_le()
        } else {
            u64::from_le(self.rejected_stop_oco_sibling_internal_order_id)
        }
    }

    fn rejected_stop_replacement_market_order_quantity(&self) -> f64 {
        if self.is_out_of_bounds(410) {
            0.0
        } else {
            f64_le(self.rejected_stop_replacement_market_order_quantity)
        }
    }

    fn evaluating_for_fill(&self) -> u8 {
        if self.is_out_of_bounds(411) {
            0
        } else {
            self.evaluating_for_fill
        }
    }

    fn last_processed_time_sales_record_sequence_for_prices(&self) -> u32 {
        if self.is_out_of_bounds(415) {
            0u32.to_le()
        } else {
            u32::from_le(self.last_processed_time_sales_record_sequence_for_prices)
        }
    }

    fn is_market_data_management_of_order_enabled(&self) -> bool {
        if self.is_out_of_bounds(416) {
            false
        } else {
            self.is_market_data_management_of_order_enabled
        }
    }

    fn text_tag(&self) -> &str {
        if self.is_out_of_bounds(420) {
            ""
        } else {
            get_vls(self, self.text_tag)
        }
    }

    fn timed_out_order_requested_status_date_time(&self) -> i64 {
        if self.is_out_of_bounds(428) {
            0i64.to_le()
        } else {
            i64::from_le(self.timed_out_order_requested_status_date_time)
        }
    }

    fn requested_status_for_timed_out_order(&self) -> u8 {
        if self.is_out_of_bounds(429) {
            0
        } else {
            self.requested_status_for_timed_out_order
        }
    }

    fn send_flatten_market_order_when_related_orders_confirmed_canceled(&self) -> u8 {
        if self.is_out_of_bounds(430) {
            0
        } else {
            self.send_flatten_market_order_when_related_orders_confirmed_canceled
        }
    }

    fn quantity_to_increase_from_parent_fill(&self) -> f64 {
        if self.is_out_of_bounds(438) {
            0.0
        } else {
            f64_le(self.quantity_to_increase_from_parent_fill)
        }
    }

    fn move_to_breakeven_stop_reference_price(&self) -> f64 {
        if self.is_out_of_bounds(446) {
            0.0
        } else {
            f64_le(self.move_to_breakeven_stop_reference_price)
        }
    }

    fn quantity_triggered_stop_quantity_for_trigger(&self) -> f64 {
        if self.is_out_of_bounds(454) {
            0.0
        } else {
            f64_le(self.quantity_triggered_stop_quantity_for_trigger)
        }
    }

    fn accumulated_trade_volume_for_triggered_stop(&self) -> f64 {
        if self.is_out_of_bounds(462) {
            0.0
        } else {
            f64_le(self.accumulated_trade_volume_for_triggered_stop)
        }
    }

    fn bid_ask_quantity_stop_initial_trigger_met(&self) -> u8 {
        if self.is_out_of_bounds(463) {
            0
        } else {
            self.bid_ask_quantity_stop_initial_trigger_met
        }
    }

    fn need_to_override_lock(&self) -> u8 {
        if self.is_out_of_bounds(464) {
            0
        } else {
            self.need_to_override_lock
        }
    }

    fn current_market_price(&self) -> f64 {
        if self.is_out_of_bounds(472) {
            0.0
        } else {
            f64_le(self.current_market_price)
        }
    }

    fn current_market_date_time(&self) -> i64 {
        if self.is_out_of_bounds(480) {
            0i64.to_le()
        } else {
            i64::from_le(self.current_market_date_time)
        }
    }

    fn support_order_fill_billing(&self) -> u8 {
        if self.is_out_of_bounds(481) {
            0
        } else {
            self.support_order_fill_billing
        }
    }

    fn is_billable(&self) -> bool {
        if self.is_out_of_bounds(482) {
            false
        } else {
            self.is_billable
        }
    }

    fn quantity_for_billing(&self) -> i32 {
        if self.is_out_of_bounds(486) {
            0i32.to_le()
        } else {
            i32::from_le(self.quantity_for_billing)
        }
    }

    fn number_of_failed_order_modifications(&self) -> u32 {
        if self.is_out_of_bounds(490) {
            0u32.to_le()
        } else {
            u32::from_le(self.number_of_failed_order_modifications)
        }
    }

    fn dtc_server_index(&self) -> i32 {
        if self.is_out_of_bounds(494) {
            0i32.to_le()
        } else {
            i32::from_le(self.dtc_server_index)
        }
    }

    fn clearing_firm_id(&self) -> &str {
        if self.is_out_of_bounds(498) {
            ""
        } else {
            get_vls(self, self.clearing_firm_id)
        }
    }

    fn sender_sub_id(&self) -> &str {
        if self.is_out_of_bounds(502) {
            ""
        } else {
            get_vls(self, self.sender_sub_id)
        }
    }

    fn sender_location_id(&self) -> &str {
        if self.is_out_of_bounds(506) {
            ""
        } else {
            get_vls(self, self.sender_location_id)
        }
    }

    fn self_match_prevention_id(&self) -> &str {
        if self.is_out_of_bounds(510) {
            ""
        } else {
            get_vls(self, self.self_match_prevention_id)
        }
    }

    fn cti_code(&self) -> i32 {
        if self.is_out_of_bounds(514) {
            0i32.to_le()
        } else {
            i32::from_le(self.cti_code)
        }
    }

    fn obtain_order_action_date_time_from_last_trade_time_in_chart(&self) -> u8 {
        if self.is_out_of_bounds(515) {
            0
        } else {
            self.obtain_order_action_date_time_from_last_trade_time_in_chart
        }
    }

    fn maximum_show_quantity(&self) -> f64 {
        if self.is_out_of_bounds(523) {
            0.0
        } else {
            f64_le(self.maximum_show_quantity)
        }
    }

    fn order_submitted(&self) -> u8 {
        if self.is_out_of_bounds(524) {
            0
        } else {
            self.order_submitted
        }
    }

    fn is_snapshot(&self) -> bool {
        if self.is_out_of_bounds(525) {
            false
        } else {
            self.is_snapshot
        }
    }

    fn is_first_message_in_batch(&self) -> bool {
        if self.is_out_of_bounds(526) {
            false
        } else {
            self.is_first_message_in_batch
        }
    }

    fn is_last_message_in_batch(&self) -> bool {
        if self.is_out_of_bounds(527) {
            false
        } else {
            self.is_last_message_in_batch
        }
    }

    fn external_last_action_date_time_utc(&self) -> i64 {
        if self.is_out_of_bounds(535) {
            0i64.to_le()
        } else {
            i64::from_le(self.external_last_action_date_time_utc)
        }
    }

    fn set_is_order_deleted(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(7) {
            self.is_order_deleted = value;
        }
        self
    }

    fn set_internal_order_id(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(15) {
            self.internal_order_id = value.to_le();
        }
        self
    }

    fn set_order_status_code(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(17) {
            self.order_status_code = value.to_le();
        }
        self
    }

    fn set_order_status_before_pending_modify(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(19) {
            self.order_status_before_pending_modify = value.to_le();
        }
        self
    }

    fn set_order_status_before_pending_cancel(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(21) {
            self.order_status_before_pending_cancel = value.to_le();
        }
        self
    }

    fn set_service_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(25) {
            self.service_order_id = set_vls(self, self.service_order_id, value);
        }
        self
    }

    fn set_actual_symbol(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(29) {
            self.actual_symbol = set_vls(self, self.actual_symbol, value);
        }
        self
    }

    fn set_order_type(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(33) {
            self.order_type = value.to_le();
        }
        self
    }

    fn set_buy_sell(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(35) {
            self.buy_sell = value.to_le();
        }
        self
    }

    fn set_price1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(43) {
            self.price1 = f64_le(value);
        }
        self
    }

    fn set_price2(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(51) {
            self.price2 = f64_le(value);
        }
        self
    }

    fn set_order_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(59) {
            self.order_quantity = f64_le(value);
        }
        self
    }

    fn set_filled_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(67) {
            self.filled_quantity = f64_le(value);
        }
        self
    }

    fn set_average_fill_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(75) {
            self.average_fill_price = f64_le(value);
        }
        self
    }

    fn set_realtime_fill_status(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(79) {
            self.realtime_fill_status = value.to_le();
        }
        self
    }

    fn set_is_resting_order_during_fill(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(80) {
            self.is_resting_order_during_fill = value;
        }
        self
    }

    fn set_order_reject_type(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(84) {
            self.order_reject_type = value.to_le();
        }
        self
    }

    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(88) {
            self.trade_account = set_vls(self, self.trade_account, value);
        }
        self
    }

    fn set_sub_account_identifier(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(92) {
            self.sub_account_identifier = value.to_le();
        }
        self
    }

    fn set_internal_order_id_modifier_for_service(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(96) {
            self.internal_order_id_modifier_for_service = value.to_le();
        }
        self
    }

    fn set_fix_client_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(100) {
            self.fix_client_order_id = set_vls(self, self.fix_client_order_id, value);
        }
        self
    }

    fn set_sequence_number_based_client_order_id(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(104) {
            self.sequence_number_based_client_order_id = value.to_le();
        }
        self
    }

    fn set_client_order_id_for_dtc_server(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(108) {
            self.client_order_id_for_dtc_server =
                set_vls(self, self.client_order_id_for_dtc_server, value);
        }
        self
    }

    fn set_previous_client_order_id_for_dtc_server(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(112) {
            self.previous_client_order_id_for_dtc_server =
                set_vls(self, self.previous_client_order_id_for_dtc_server, value);
        }
        self
    }

    fn set_exchange_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(116) {
            self.exchange_order_id = set_vls(self, self.exchange_order_id, value);
        }
        self
    }

    fn set_originating_client_username(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(120) {
            self.originating_client_username =
                set_vls(self, self.originating_client_username, value);
        }
        self
    }

    fn set_entry_date_time(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(128) {
            self.entry_date_time = value.to_le();
        }
        self
    }

    fn set_last_action_date_time(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(136) {
            self.last_action_date_time = value.to_le();
        }
        self
    }

    fn set_service_update_date_time_utc(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(144) {
            self.service_update_date_time_utc = value.to_le();
        }
        self
    }

    fn set_order_entry_time_for_service(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(148) {
            self.order_entry_time_for_service = value.to_le();
        }
        self
    }

    fn set_last_modify_time_for_service(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(152) {
            self.last_modify_time_for_service = value.to_le();
        }
        self
    }

    fn set_good_till_date_time(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(160) {
            self.good_till_date_time = value.to_le();
        }
        self
    }

    fn set_time_in_force(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(164) {
            self.time_in_force = value.to_le();
        }
        self
    }

    fn set_open_close(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(166) {
            self.open_close = value.to_le();
        }
        self
    }

    fn set_trail_stop_offset1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(174) {
            self.trail_stop_offset1 = f64_le(value);
        }
        self
    }

    fn set_trail_stop_step(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(182) {
            self.trail_stop_step = f64_le(value);
        }
        self
    }

    fn set_trail_trigger_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(190) {
            self.trail_trigger_price = f64_le(value);
        }
        self
    }

    fn set_trailing_stop_trigger_offset(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(198) {
            self.trailing_stop_trigger_offset = f64_le(value);
        }
        self
    }

    fn set_trail_trigger_hit(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(199) {
            self.trail_trigger_hit = value;
        }
        self
    }

    fn set_trail_to_break_even_stop_offset(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(207) {
            self.trail_to_break_even_stop_offset = f64_le(value);
        }
        self
    }

    fn set_maximum_chase_amount_as_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(215) {
            self.maximum_chase_amount_as_price = f64_le(value);
        }
        self
    }

    fn set_initial_chase_order_price1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(223) {
            self.initial_chase_order_price1 = f64_le(value);
        }
        self
    }

    fn set_initial_last_trade_price_for_chase_orders(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(231) {
            self.initial_last_trade_price_for_chase_orders = f64_le(value);
        }
        self
    }

    fn set_trailing_stop_trigger_oco_group_number(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(235) {
            self.trailing_stop_trigger_oco_group_number = value.to_le();
        }
        self
    }

    fn set_last_modify_price1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(243) {
            self.last_modify_price1 = f64_le(value);
        }
        self
    }

    fn set_last_modify_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(251) {
            self.last_modify_quantity = f64_le(value);
        }
        self
    }

    fn set_cumulative_order_quantity_from_parent_fills(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(259) {
            self.cumulative_order_quantity_from_parent_fills = f64_le(value);
        }
        self
    }

    fn set_prior_filled_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(267) {
            self.prior_filled_quantity = f64_le(value);
        }
        self
    }

    fn set_tick_size(&mut self, value: f32) -> &mut Self {
        if !self.is_out_of_bounds(271) {
            self.tick_size = f32_le(value);
        }
        self
    }

    fn set_value_format(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(275) {
            self.value_format = value.to_le();
        }
        self
    }

    fn set_price_multiplier(&mut self, value: f32) -> &mut Self {
        if !self.is_out_of_bounds(279) {
            self.price_multiplier = f32_le(value);
        }
        self
    }

    fn set_parent_internal_order_id(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(287) {
            self.parent_internal_order_id = value.to_le();
        }
        self
    }

    fn set_target_child_internal_order_id(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(295) {
            self.target_child_internal_order_id = value.to_le();
        }
        self
    }

    fn set_stop_child_internal_order_id(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(303) {
            self.stop_child_internal_order_id = value.to_le();
        }
        self
    }

    fn set_attached_order_price_offset1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(311) {
            self.attached_order_price_offset1 = f64_le(value);
        }
        self
    }

    fn set_link_internal_order_id(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(319) {
            self.link_internal_order_id = value.to_le();
        }
        self
    }

    fn set_oco_group_internal_order_id(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(327) {
            self.oco_group_internal_order_id = value.to_le();
        }
        self
    }

    fn set_oco_sibling_internal_order_id(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(335) {
            self.oco_sibling_internal_order_id = value.to_le();
        }
        self
    }

    fn set_disable_child_and_sibling_related_actions(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(336) {
            self.disable_child_and_sibling_related_actions = value;
        }
        self
    }

    fn set_oco_managed_by_service(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(337) {
            self.oco_managed_by_service = value;
        }
        self
    }

    fn set_bracket_order_server_managed(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(338) {
            self.bracket_order_server_managed = value;
        }
        self
    }

    fn set_last_order_action_source(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(342) {
            self.last_order_action_source = set_vls(self, self.last_order_action_source, value);
        }
        self
    }

    fn set_stop_limit_order_stop_price_triggered(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(343) {
            self.stop_limit_order_stop_price_triggered = value;
        }
        self
    }

    fn set_oco_full_sibling_cancel_on_partial_fill(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(344) {
            self.oco_full_sibling_cancel_on_partial_fill = value;
        }
        self
    }

    fn set_reverse_on_complete_fill(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(345) {
            self.reverse_on_complete_fill = value;
        }
        self
    }

    fn set_support_scale_in(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(346) {
            self.support_scale_in = value;
        }
        self
    }

    fn set_support_scale_out(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(347) {
            self.support_scale_out = value;
        }
        self
    }

    fn set_source_chart_number(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(351) {
            self.source_chart_number = value.to_le();
        }
        self
    }

    fn set_source_chartbook_file_name(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(355) {
            self.source_chartbook_file_name = set_vls(self, self.source_chartbook_file_name, value);
        }
        self
    }

    fn set_is_automated_order(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(356) {
            self.is_automated_order = value;
        }
        self
    }

    fn set_simulated_order(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(357) {
            self.simulated_order = value;
        }
        self
    }

    fn set_is_chart_replaying(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(358) {
            self.is_chart_replaying = value;
        }
        self
    }

    fn set_attached_order_oco_group_number(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(362) {
            self.attached_order_oco_group_number = value.to_le();
        }
        self
    }

    fn set_last_fill_execution_service_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(366) {
            self.last_fill_execution_service_id =
                set_vls(self, self.last_fill_execution_service_id, value);
        }
        self
    }

    fn set_fill_count(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(370) {
            self.fill_count = value.to_le();
        }
        self
    }

    fn set_last_fill_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(378) {
            self.last_fill_quantity = f64_le(value);
        }
        self
    }

    fn set_last_fill_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(386) {
            self.last_fill_price = f64_le(value);
        }
        self
    }

    fn set_last_fill_date_time_utc(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(394) {
            self.last_fill_date_time_utc = value.to_le();
        }
        self
    }

    fn set_rejected_stop_oco_sibling_internal_order_id(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(402) {
            self.rejected_stop_oco_sibling_internal_order_id = value.to_le();
        }
        self
    }

    fn set_rejected_stop_replacement_market_order_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(410) {
            self.rejected_stop_replacement_market_order_quantity = f64_le(value);
        }
        self
    }

    fn set_evaluating_for_fill(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(411) {
            self.evaluating_for_fill = value;
        }
        self
    }

    fn set_last_processed_time_sales_record_sequence_for_prices(
        &mut self,
        value: u32,
    ) -> &mut Self {
        if !self.is_out_of_bounds(415) {
            self.last_processed_time_sales_record_sequence_for_prices = value.to_le();
        }
        self
    }

    fn set_is_market_data_management_of_order_enabled(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(416) {
            self.is_market_data_management_of_order_enabled = value;
        }
        self
    }

    fn set_text_tag(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(420) {
            self.text_tag = set_vls(self, self.text_tag, value);
        }
        self
    }

    fn set_timed_out_order_requested_status_date_time(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(428) {
            self.timed_out_order_requested_status_date_time = value.to_le();
        }
        self
    }

    fn set_requested_status_for_timed_out_order(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(429) {
            self.requested_status_for_timed_out_order = value;
        }
        self
    }

    fn set_send_flatten_market_order_when_related_orders_confirmed_canceled(
        &mut self,
        value: u8,
    ) -> &mut Self {
        if !self.is_out_of_bounds(430) {
            self.send_flatten_market_order_when_related_orders_confirmed_canceled = value;
        }
        self
    }

    fn set_quantity_to_increase_from_parent_fill(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(438) {
            self.quantity_to_increase_from_parent_fill = f64_le(value);
        }
        self
    }

    fn set_move_to_breakeven_stop_reference_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(446) {
            self.move_to_breakeven_stop_reference_price = f64_le(value);
        }
        self
    }

    fn set_quantity_triggered_stop_quantity_for_trigger(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(454) {
            self.quantity_triggered_stop_quantity_for_trigger = f64_le(value);
        }
        self
    }

    fn set_accumulated_trade_volume_for_triggered_stop(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(462) {
            self.accumulated_trade_volume_for_triggered_stop = f64_le(value);
        }
        self
    }

    fn set_bid_ask_quantity_stop_initial_trigger_met(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(463) {
            self.bid_ask_quantity_stop_initial_trigger_met = value;
        }
        self
    }

    fn set_need_to_override_lock(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(464) {
            self.need_to_override_lock = value;
        }
        self
    }

    fn set_current_market_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(472) {
            self.current_market_price = f64_le(value);
        }
        self
    }

    fn set_current_market_date_time(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(480) {
            self.current_market_date_time = value.to_le();
        }
        self
    }

    fn set_support_order_fill_billing(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(481) {
            self.support_order_fill_billing = value;
        }
        self
    }

    fn set_is_billable(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(482) {
            self.is_billable = value;
        }
        self
    }

    fn set_quantity_for_billing(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(486) {
            self.quantity_for_billing = value.to_le();
        }
        self
    }

    fn set_number_of_failed_order_modifications(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(490) {
            self.number_of_failed_order_modifications = value.to_le();
        }
        self
    }

    fn set_dtc_server_index(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(494) {
            self.dtc_server_index = value.to_le();
        }
        self
    }

    fn set_clearing_firm_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(498) {
            self.clearing_firm_id = set_vls(self, self.clearing_firm_id, value);
        }
        self
    }

    fn set_sender_sub_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(502) {
            self.sender_sub_id = set_vls(self, self.sender_sub_id, value);
        }
        self
    }

    fn set_sender_location_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(506) {
            self.sender_location_id = set_vls(self, self.sender_location_id, value);
        }
        self
    }

    fn set_self_match_prevention_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(510) {
            self.self_match_prevention_id = set_vls(self, self.self_match_prevention_id, value);
        }
        self
    }

    fn set_cti_code(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(514) {
            self.cti_code = value.to_le();
        }
        self
    }

    fn set_obtain_order_action_date_time_from_last_trade_time_in_chart(
        &mut self,
        value: u8,
    ) -> &mut Self {
        if !self.is_out_of_bounds(515) {
            self.obtain_order_action_date_time_from_last_trade_time_in_chart = value;
        }
        self
    }

    fn set_maximum_show_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(523) {
            self.maximum_show_quantity = f64_le(value);
        }
        self
    }

    fn set_order_submitted(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(524) {
            self.order_submitted = value;
        }
        self
    }

    fn set_is_snapshot(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(525) {
            self.is_snapshot = value;
        }
        self
    }

    fn set_is_first_message_in_batch(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(526) {
            self.is_first_message_in_batch = value;
        }
        self
    }

    fn set_is_last_message_in_batch(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(527) {
            self.is_last_message_in_batch = value;
        }
        self
    }

    fn set_external_last_action_date_time_utc(&mut self, value: i64) -> &mut Self {
        if !self.is_out_of_bounds(535) {
            self.external_last_action_date_time_utc = value.to_le();
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    #[test]
    pub(crate) fn layout() {
        unsafe {
            assert_eq!(
                535usize,
                core::mem::size_of::<TradeOrderVLSData>(),
                "TradeOrderVLSData sizeof expected {:} but was {:}",
                535usize,
                core::mem::size_of::<TradeOrderVLSData>()
            );
            assert_eq!(
                535u16,
                TradeOrderVLS::new().size(),
                "TradeOrderVLS sizeof expected {:} but was {:}",
                535u16,
                TradeOrderVLS::new().size(),
            );
            assert_eq!(
                SC_TRADE_ORDER,
                TradeOrderVLS::new().r#type(),
                "TradeOrderVLS type expected {:} but was {:}",
                SC_TRADE_ORDER,
                TradeOrderVLS::new().r#type(),
            );
            assert_eq!(
                10110u16,
                TradeOrderVLS::new().r#type(),
                "TradeOrderVLS type expected {:} but was {:}",
                10110u16,
                TradeOrderVLS::new().r#type(),
            );
            let d = TradeOrderVLSData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
                "base_size offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
            );
            assert_eq!(
                6usize,
                (core::ptr::addr_of!(d.is_order_deleted) as usize) - p,
                "is_order_deleted offset expected {:} but was {:}",
                6usize,
                (core::ptr::addr_of!(d.is_order_deleted) as usize) - p,
            );
            assert_eq!(
                7usize,
                (core::ptr::addr_of!(d.internal_order_id) as usize) - p,
                "internal_order_id offset expected {:} but was {:}",
                7usize,
                (core::ptr::addr_of!(d.internal_order_id) as usize) - p,
            );
            assert_eq!(
                15usize,
                (core::ptr::addr_of!(d.order_status_code) as usize) - p,
                "order_status_code offset expected {:} but was {:}",
                15usize,
                (core::ptr::addr_of!(d.order_status_code) as usize) - p,
            );
            assert_eq!(
                17usize,
                (core::ptr::addr_of!(d.order_status_before_pending_modify) as usize) - p,
                "order_status_before_pending_modify offset expected {:} but was {:}",
                17usize,
                (core::ptr::addr_of!(d.order_status_before_pending_modify) as usize) - p,
            );
            assert_eq!(
                19usize,
                (core::ptr::addr_of!(d.order_status_before_pending_cancel) as usize) - p,
                "order_status_before_pending_cancel offset expected {:} but was {:}",
                19usize,
                (core::ptr::addr_of!(d.order_status_before_pending_cancel) as usize) - p,
            );
            assert_eq!(
                21usize,
                (core::ptr::addr_of!(d.service_order_id) as usize) - p,
                "service_order_id offset expected {:} but was {:}",
                21usize,
                (core::ptr::addr_of!(d.service_order_id) as usize) - p,
            );
            assert_eq!(
                25usize,
                (core::ptr::addr_of!(d.actual_symbol) as usize) - p,
                "actual_symbol offset expected {:} but was {:}",
                25usize,
                (core::ptr::addr_of!(d.actual_symbol) as usize) - p,
            );
            assert_eq!(
                29usize,
                (core::ptr::addr_of!(d.order_type) as usize) - p,
                "order_type offset expected {:} but was {:}",
                29usize,
                (core::ptr::addr_of!(d.order_type) as usize) - p,
            );
            assert_eq!(
                33usize,
                (core::ptr::addr_of!(d.buy_sell) as usize) - p,
                "buy_sell offset expected {:} but was {:}",
                33usize,
                (core::ptr::addr_of!(d.buy_sell) as usize) - p,
            );
            assert_eq!(
                35usize,
                (core::ptr::addr_of!(d.price1) as usize) - p,
                "price1 offset expected {:} but was {:}",
                35usize,
                (core::ptr::addr_of!(d.price1) as usize) - p,
            );
            assert_eq!(
                43usize,
                (core::ptr::addr_of!(d.price2) as usize) - p,
                "price2 offset expected {:} but was {:}",
                43usize,
                (core::ptr::addr_of!(d.price2) as usize) - p,
            );
            assert_eq!(
                51usize,
                (core::ptr::addr_of!(d.order_quantity) as usize) - p,
                "order_quantity offset expected {:} but was {:}",
                51usize,
                (core::ptr::addr_of!(d.order_quantity) as usize) - p,
            );
            assert_eq!(
                59usize,
                (core::ptr::addr_of!(d.filled_quantity) as usize) - p,
                "filled_quantity offset expected {:} but was {:}",
                59usize,
                (core::ptr::addr_of!(d.filled_quantity) as usize) - p,
            );
            assert_eq!(
                67usize,
                (core::ptr::addr_of!(d.average_fill_price) as usize) - p,
                "average_fill_price offset expected {:} but was {:}",
                67usize,
                (core::ptr::addr_of!(d.average_fill_price) as usize) - p,
            );
            assert_eq!(
                75usize,
                (core::ptr::addr_of!(d.realtime_fill_status) as usize) - p,
                "realtime_fill_status offset expected {:} but was {:}",
                75usize,
                (core::ptr::addr_of!(d.realtime_fill_status) as usize) - p,
            );
            assert_eq!(
                79usize,
                (core::ptr::addr_of!(d.is_resting_order_during_fill) as usize) - p,
                "is_resting_order_during_fill offset expected {:} but was {:}",
                79usize,
                (core::ptr::addr_of!(d.is_resting_order_during_fill) as usize) - p,
            );
            assert_eq!(
                80usize,
                (core::ptr::addr_of!(d.order_reject_type) as usize) - p,
                "order_reject_type offset expected {:} but was {:}",
                80usize,
                (core::ptr::addr_of!(d.order_reject_type) as usize) - p,
            );
            assert_eq!(
                84usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
                "trade_account offset expected {:} but was {:}",
                84usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
            );
            assert_eq!(
                88usize,
                (core::ptr::addr_of!(d.sub_account_identifier) as usize) - p,
                "sub_account_identifier offset expected {:} but was {:}",
                88usize,
                (core::ptr::addr_of!(d.sub_account_identifier) as usize) - p,
            );
            assert_eq!(
                92usize,
                (core::ptr::addr_of!(d.internal_order_id_modifier_for_service) as usize) - p,
                "internal_order_id_modifier_for_service offset expected {:} but was {:}",
                92usize,
                (core::ptr::addr_of!(d.internal_order_id_modifier_for_service) as usize) - p,
            );
            assert_eq!(
                96usize,
                (core::ptr::addr_of!(d.fix_client_order_id) as usize) - p,
                "fix_client_order_id offset expected {:} but was {:}",
                96usize,
                (core::ptr::addr_of!(d.fix_client_order_id) as usize) - p,
            );
            assert_eq!(
                100usize,
                (core::ptr::addr_of!(d.sequence_number_based_client_order_id) as usize) - p,
                "sequence_number_based_client_order_id offset expected {:} but was {:}",
                100usize,
                (core::ptr::addr_of!(d.sequence_number_based_client_order_id) as usize) - p,
            );
            assert_eq!(
                104usize,
                (core::ptr::addr_of!(d.client_order_id_for_dtc_server) as usize) - p,
                "client_order_id_for_dtc_server offset expected {:} but was {:}",
                104usize,
                (core::ptr::addr_of!(d.client_order_id_for_dtc_server) as usize) - p,
            );
            assert_eq!(
                108usize,
                (core::ptr::addr_of!(d.previous_client_order_id_for_dtc_server) as usize) - p,
                "previous_client_order_id_for_dtc_server offset expected {:} but was {:}",
                108usize,
                (core::ptr::addr_of!(d.previous_client_order_id_for_dtc_server) as usize) - p,
            );
            assert_eq!(
                112usize,
                (core::ptr::addr_of!(d.exchange_order_id) as usize) - p,
                "exchange_order_id offset expected {:} but was {:}",
                112usize,
                (core::ptr::addr_of!(d.exchange_order_id) as usize) - p,
            );
            assert_eq!(
                116usize,
                (core::ptr::addr_of!(d.originating_client_username) as usize) - p,
                "originating_client_username offset expected {:} but was {:}",
                116usize,
                (core::ptr::addr_of!(d.originating_client_username) as usize) - p,
            );
            assert_eq!(
                120usize,
                (core::ptr::addr_of!(d.entry_date_time) as usize) - p,
                "entry_date_time offset expected {:} but was {:}",
                120usize,
                (core::ptr::addr_of!(d.entry_date_time) as usize) - p,
            );
            assert_eq!(
                128usize,
                (core::ptr::addr_of!(d.last_action_date_time) as usize) - p,
                "last_action_date_time offset expected {:} but was {:}",
                128usize,
                (core::ptr::addr_of!(d.last_action_date_time) as usize) - p,
            );
            assert_eq!(
                136usize,
                (core::ptr::addr_of!(d.service_update_date_time_utc) as usize) - p,
                "service_update_date_time_utc offset expected {:} but was {:}",
                136usize,
                (core::ptr::addr_of!(d.service_update_date_time_utc) as usize) - p,
            );
            assert_eq!(
                144usize,
                (core::ptr::addr_of!(d.order_entry_time_for_service) as usize) - p,
                "order_entry_time_for_service offset expected {:} but was {:}",
                144usize,
                (core::ptr::addr_of!(d.order_entry_time_for_service) as usize) - p,
            );
            assert_eq!(
                148usize,
                (core::ptr::addr_of!(d.last_modify_time_for_service) as usize) - p,
                "last_modify_time_for_service offset expected {:} but was {:}",
                148usize,
                (core::ptr::addr_of!(d.last_modify_time_for_service) as usize) - p,
            );
            assert_eq!(
                152usize,
                (core::ptr::addr_of!(d.good_till_date_time) as usize) - p,
                "good_till_date_time offset expected {:} but was {:}",
                152usize,
                (core::ptr::addr_of!(d.good_till_date_time) as usize) - p,
            );
            assert_eq!(
                160usize,
                (core::ptr::addr_of!(d.time_in_force) as usize) - p,
                "time_in_force offset expected {:} but was {:}",
                160usize,
                (core::ptr::addr_of!(d.time_in_force) as usize) - p,
            );
            assert_eq!(
                164usize,
                (core::ptr::addr_of!(d.open_close) as usize) - p,
                "open_close offset expected {:} but was {:}",
                164usize,
                (core::ptr::addr_of!(d.open_close) as usize) - p,
            );
            assert_eq!(
                166usize,
                (core::ptr::addr_of!(d.trail_stop_offset1) as usize) - p,
                "trail_stop_offset1 offset expected {:} but was {:}",
                166usize,
                (core::ptr::addr_of!(d.trail_stop_offset1) as usize) - p,
            );
            assert_eq!(
                174usize,
                (core::ptr::addr_of!(d.trail_stop_step) as usize) - p,
                "trail_stop_step offset expected {:} but was {:}",
                174usize,
                (core::ptr::addr_of!(d.trail_stop_step) as usize) - p,
            );
            assert_eq!(
                182usize,
                (core::ptr::addr_of!(d.trail_trigger_price) as usize) - p,
                "trail_trigger_price offset expected {:} but was {:}",
                182usize,
                (core::ptr::addr_of!(d.trail_trigger_price) as usize) - p,
            );
            assert_eq!(
                190usize,
                (core::ptr::addr_of!(d.trailing_stop_trigger_offset) as usize) - p,
                "trailing_stop_trigger_offset offset expected {:} but was {:}",
                190usize,
                (core::ptr::addr_of!(d.trailing_stop_trigger_offset) as usize) - p,
            );
            assert_eq!(
                198usize,
                (core::ptr::addr_of!(d.trail_trigger_hit) as usize) - p,
                "trail_trigger_hit offset expected {:} but was {:}",
                198usize,
                (core::ptr::addr_of!(d.trail_trigger_hit) as usize) - p,
            );
            assert_eq!(
                199usize,
                (core::ptr::addr_of!(d.trail_to_break_even_stop_offset) as usize) - p,
                "trail_to_break_even_stop_offset offset expected {:} but was {:}",
                199usize,
                (core::ptr::addr_of!(d.trail_to_break_even_stop_offset) as usize) - p,
            );
            assert_eq!(
                207usize,
                (core::ptr::addr_of!(d.maximum_chase_amount_as_price) as usize) - p,
                "maximum_chase_amount_as_price offset expected {:} but was {:}",
                207usize,
                (core::ptr::addr_of!(d.maximum_chase_amount_as_price) as usize) - p,
            );
            assert_eq!(
                215usize,
                (core::ptr::addr_of!(d.initial_chase_order_price1) as usize) - p,
                "initial_chase_order_price1 offset expected {:} but was {:}",
                215usize,
                (core::ptr::addr_of!(d.initial_chase_order_price1) as usize) - p,
            );
            assert_eq!(
                223usize,
                (core::ptr::addr_of!(d.initial_last_trade_price_for_chase_orders) as usize) - p,
                "initial_last_trade_price_for_chase_orders offset expected {:} but was {:}",
                223usize,
                (core::ptr::addr_of!(d.initial_last_trade_price_for_chase_orders) as usize) - p,
            );
            assert_eq!(
                231usize,
                (core::ptr::addr_of!(d.trailing_stop_trigger_oco_group_number) as usize) - p,
                "trailing_stop_trigger_oco_group_number offset expected {:} but was {:}",
                231usize,
                (core::ptr::addr_of!(d.trailing_stop_trigger_oco_group_number) as usize) - p,
            );
            assert_eq!(
                235usize,
                (core::ptr::addr_of!(d.last_modify_price1) as usize) - p,
                "last_modify_price1 offset expected {:} but was {:}",
                235usize,
                (core::ptr::addr_of!(d.last_modify_price1) as usize) - p,
            );
            assert_eq!(
                243usize,
                (core::ptr::addr_of!(d.last_modify_quantity) as usize) - p,
                "last_modify_quantity offset expected {:} but was {:}",
                243usize,
                (core::ptr::addr_of!(d.last_modify_quantity) as usize) - p,
            );
            assert_eq!(
                251usize,
                (core::ptr::addr_of!(d.cumulative_order_quantity_from_parent_fills) as usize) - p,
                "cumulative_order_quantity_from_parent_fills offset expected {:} but was {:}",
                251usize,
                (core::ptr::addr_of!(d.cumulative_order_quantity_from_parent_fills) as usize) - p,
            );
            assert_eq!(
                259usize,
                (core::ptr::addr_of!(d.prior_filled_quantity) as usize) - p,
                "prior_filled_quantity offset expected {:} but was {:}",
                259usize,
                (core::ptr::addr_of!(d.prior_filled_quantity) as usize) - p,
            );
            assert_eq!(
                267usize,
                (core::ptr::addr_of!(d.tick_size) as usize) - p,
                "tick_size offset expected {:} but was {:}",
                267usize,
                (core::ptr::addr_of!(d.tick_size) as usize) - p,
            );
            assert_eq!(
                271usize,
                (core::ptr::addr_of!(d.value_format) as usize) - p,
                "value_format offset expected {:} but was {:}",
                271usize,
                (core::ptr::addr_of!(d.value_format) as usize) - p,
            );
            assert_eq!(
                275usize,
                (core::ptr::addr_of!(d.price_multiplier) as usize) - p,
                "price_multiplier offset expected {:} but was {:}",
                275usize,
                (core::ptr::addr_of!(d.price_multiplier) as usize) - p,
            );
            assert_eq!(
                279usize,
                (core::ptr::addr_of!(d.parent_internal_order_id) as usize) - p,
                "parent_internal_order_id offset expected {:} but was {:}",
                279usize,
                (core::ptr::addr_of!(d.parent_internal_order_id) as usize) - p,
            );
            assert_eq!(
                287usize,
                (core::ptr::addr_of!(d.target_child_internal_order_id) as usize) - p,
                "target_child_internal_order_id offset expected {:} but was {:}",
                287usize,
                (core::ptr::addr_of!(d.target_child_internal_order_id) as usize) - p,
            );
            assert_eq!(
                295usize,
                (core::ptr::addr_of!(d.stop_child_internal_order_id) as usize) - p,
                "stop_child_internal_order_id offset expected {:} but was {:}",
                295usize,
                (core::ptr::addr_of!(d.stop_child_internal_order_id) as usize) - p,
            );
            assert_eq!(
                303usize,
                (core::ptr::addr_of!(d.attached_order_price_offset1) as usize) - p,
                "attached_order_price_offset1 offset expected {:} but was {:}",
                303usize,
                (core::ptr::addr_of!(d.attached_order_price_offset1) as usize) - p,
            );
            assert_eq!(
                311usize,
                (core::ptr::addr_of!(d.link_internal_order_id) as usize) - p,
                "link_internal_order_id offset expected {:} but was {:}",
                311usize,
                (core::ptr::addr_of!(d.link_internal_order_id) as usize) - p,
            );
            assert_eq!(
                319usize,
                (core::ptr::addr_of!(d.oco_group_internal_order_id) as usize) - p,
                "oco_group_internal_order_id offset expected {:} but was {:}",
                319usize,
                (core::ptr::addr_of!(d.oco_group_internal_order_id) as usize) - p,
            );
            assert_eq!(
                327usize,
                (core::ptr::addr_of!(d.oco_sibling_internal_order_id) as usize) - p,
                "oco_sibling_internal_order_id offset expected {:} but was {:}",
                327usize,
                (core::ptr::addr_of!(d.oco_sibling_internal_order_id) as usize) - p,
            );
            assert_eq!(
                335usize,
                (core::ptr::addr_of!(d.disable_child_and_sibling_related_actions) as usize) - p,
                "disable_child_and_sibling_related_actions offset expected {:} but was {:}",
                335usize,
                (core::ptr::addr_of!(d.disable_child_and_sibling_related_actions) as usize) - p,
            );
            assert_eq!(
                336usize,
                (core::ptr::addr_of!(d.oco_managed_by_service) as usize) - p,
                "oco_managed_by_service offset expected {:} but was {:}",
                336usize,
                (core::ptr::addr_of!(d.oco_managed_by_service) as usize) - p,
            );
            assert_eq!(
                337usize,
                (core::ptr::addr_of!(d.bracket_order_server_managed) as usize) - p,
                "bracket_order_server_managed offset expected {:} but was {:}",
                337usize,
                (core::ptr::addr_of!(d.bracket_order_server_managed) as usize) - p,
            );
            assert_eq!(
                338usize,
                (core::ptr::addr_of!(d.last_order_action_source) as usize) - p,
                "last_order_action_source offset expected {:} but was {:}",
                338usize,
                (core::ptr::addr_of!(d.last_order_action_source) as usize) - p,
            );
            assert_eq!(
                342usize,
                (core::ptr::addr_of!(d.stop_limit_order_stop_price_triggered) as usize) - p,
                "stop_limit_order_stop_price_triggered offset expected {:} but was {:}",
                342usize,
                (core::ptr::addr_of!(d.stop_limit_order_stop_price_triggered) as usize) - p,
            );
            assert_eq!(
                343usize,
                (core::ptr::addr_of!(d.oco_full_sibling_cancel_on_partial_fill) as usize) - p,
                "oco_full_sibling_cancel_on_partial_fill offset expected {:} but was {:}",
                343usize,
                (core::ptr::addr_of!(d.oco_full_sibling_cancel_on_partial_fill) as usize) - p,
            );
            assert_eq!(
                344usize,
                (core::ptr::addr_of!(d.reverse_on_complete_fill) as usize) - p,
                "reverse_on_complete_fill offset expected {:} but was {:}",
                344usize,
                (core::ptr::addr_of!(d.reverse_on_complete_fill) as usize) - p,
            );
            assert_eq!(
                345usize,
                (core::ptr::addr_of!(d.support_scale_in) as usize) - p,
                "support_scale_in offset expected {:} but was {:}",
                345usize,
                (core::ptr::addr_of!(d.support_scale_in) as usize) - p,
            );
            assert_eq!(
                346usize,
                (core::ptr::addr_of!(d.support_scale_out) as usize) - p,
                "support_scale_out offset expected {:} but was {:}",
                346usize,
                (core::ptr::addr_of!(d.support_scale_out) as usize) - p,
            );
            assert_eq!(
                347usize,
                (core::ptr::addr_of!(d.source_chart_number) as usize) - p,
                "source_chart_number offset expected {:} but was {:}",
                347usize,
                (core::ptr::addr_of!(d.source_chart_number) as usize) - p,
            );
            assert_eq!(
                351usize,
                (core::ptr::addr_of!(d.source_chartbook_file_name) as usize) - p,
                "source_chartbook_file_name offset expected {:} but was {:}",
                351usize,
                (core::ptr::addr_of!(d.source_chartbook_file_name) as usize) - p,
            );
            assert_eq!(
                355usize,
                (core::ptr::addr_of!(d.is_automated_order) as usize) - p,
                "is_automated_order offset expected {:} but was {:}",
                355usize,
                (core::ptr::addr_of!(d.is_automated_order) as usize) - p,
            );
            assert_eq!(
                356usize,
                (core::ptr::addr_of!(d.simulated_order) as usize) - p,
                "simulated_order offset expected {:} but was {:}",
                356usize,
                (core::ptr::addr_of!(d.simulated_order) as usize) - p,
            );
            assert_eq!(
                357usize,
                (core::ptr::addr_of!(d.is_chart_replaying) as usize) - p,
                "is_chart_replaying offset expected {:} but was {:}",
                357usize,
                (core::ptr::addr_of!(d.is_chart_replaying) as usize) - p,
            );
            assert_eq!(
                358usize,
                (core::ptr::addr_of!(d.attached_order_oco_group_number) as usize) - p,
                "attached_order_oco_group_number offset expected {:} but was {:}",
                358usize,
                (core::ptr::addr_of!(d.attached_order_oco_group_number) as usize) - p,
            );
            assert_eq!(
                362usize,
                (core::ptr::addr_of!(d.last_fill_execution_service_id) as usize) - p,
                "last_fill_execution_service_id offset expected {:} but was {:}",
                362usize,
                (core::ptr::addr_of!(d.last_fill_execution_service_id) as usize) - p,
            );
            assert_eq!(
                366usize,
                (core::ptr::addr_of!(d.fill_count) as usize) - p,
                "fill_count offset expected {:} but was {:}",
                366usize,
                (core::ptr::addr_of!(d.fill_count) as usize) - p,
            );
            assert_eq!(
                370usize,
                (core::ptr::addr_of!(d.last_fill_quantity) as usize) - p,
                "last_fill_quantity offset expected {:} but was {:}",
                370usize,
                (core::ptr::addr_of!(d.last_fill_quantity) as usize) - p,
            );
            assert_eq!(
                378usize,
                (core::ptr::addr_of!(d.last_fill_price) as usize) - p,
                "last_fill_price offset expected {:} but was {:}",
                378usize,
                (core::ptr::addr_of!(d.last_fill_price) as usize) - p,
            );
            assert_eq!(
                386usize,
                (core::ptr::addr_of!(d.last_fill_date_time_utc) as usize) - p,
                "last_fill_date_time_utc offset expected {:} but was {:}",
                386usize,
                (core::ptr::addr_of!(d.last_fill_date_time_utc) as usize) - p,
            );
            assert_eq!(
                394usize,
                (core::ptr::addr_of!(d.rejected_stop_oco_sibling_internal_order_id) as usize) - p,
                "rejected_stop_oco_sibling_internal_order_id offset expected {:} but was {:}",
                394usize,
                (core::ptr::addr_of!(d.rejected_stop_oco_sibling_internal_order_id) as usize) - p,
            );
            assert_eq!(
                402usize,
                (core::ptr::addr_of!(d.rejected_stop_replacement_market_order_quantity) as usize)
                    - p,
                "rejected_stop_replacement_market_order_quantity offset expected {:} but was {:}",
                402usize,
                (core::ptr::addr_of!(d.rejected_stop_replacement_market_order_quantity) as usize)
                    - p,
            );
            assert_eq!(
                410usize,
                (core::ptr::addr_of!(d.evaluating_for_fill) as usize) - p,
                "evaluating_for_fill offset expected {:} but was {:}",
                410usize,
                (core::ptr::addr_of!(d.evaluating_for_fill) as usize) - p,
            );
            assert_eq!(
                411usize,
                (core::ptr::addr_of!(d.last_processed_time_sales_record_sequence_for_prices) as usize) - p,
                "last_processed_time_sales_record_sequence_for_prices offset expected {:} but was {:}",
                411usize,
                (core::ptr::addr_of!(d.last_processed_time_sales_record_sequence_for_prices) as usize) - p,
            );
            assert_eq!(
                415usize,
                (core::ptr::addr_of!(d.is_market_data_management_of_order_enabled) as usize) - p,
                "is_market_data_management_of_order_enabled offset expected {:} but was {:}",
                415usize,
                (core::ptr::addr_of!(d.is_market_data_management_of_order_enabled) as usize) - p,
            );
            assert_eq!(
                416usize,
                (core::ptr::addr_of!(d.text_tag) as usize) - p,
                "text_tag offset expected {:} but was {:}",
                416usize,
                (core::ptr::addr_of!(d.text_tag) as usize) - p,
            );
            assert_eq!(
                420usize,
                (core::ptr::addr_of!(d.timed_out_order_requested_status_date_time) as usize) - p,
                "timed_out_order_requested_status_date_time offset expected {:} but was {:}",
                420usize,
                (core::ptr::addr_of!(d.timed_out_order_requested_status_date_time) as usize) - p,
            );
            assert_eq!(
                428usize,
                (core::ptr::addr_of!(d.requested_status_for_timed_out_order) as usize) - p,
                "requested_status_for_timed_out_order offset expected {:} but was {:}",
                428usize,
                (core::ptr::addr_of!(d.requested_status_for_timed_out_order) as usize) - p,
            );
            assert_eq!(
                429usize,
                (core::ptr::addr_of!(d.send_flatten_market_order_when_related_orders_confirmed_canceled) as usize) - p,
                "send_flatten_market_order_when_related_orders_confirmed_canceled offset expected {:} but was {:}",
                429usize,
                (core::ptr::addr_of!(d.send_flatten_market_order_when_related_orders_confirmed_canceled) as usize) - p,
            );
            assert_eq!(
                430usize,
                (core::ptr::addr_of!(d.quantity_to_increase_from_parent_fill) as usize) - p,
                "quantity_to_increase_from_parent_fill offset expected {:} but was {:}",
                430usize,
                (core::ptr::addr_of!(d.quantity_to_increase_from_parent_fill) as usize) - p,
            );
            assert_eq!(
                438usize,
                (core::ptr::addr_of!(d.move_to_breakeven_stop_reference_price) as usize) - p,
                "move_to_breakeven_stop_reference_price offset expected {:} but was {:}",
                438usize,
                (core::ptr::addr_of!(d.move_to_breakeven_stop_reference_price) as usize) - p,
            );
            assert_eq!(
                446usize,
                (core::ptr::addr_of!(d.quantity_triggered_stop_quantity_for_trigger) as usize) - p,
                "quantity_triggered_stop_quantity_for_trigger offset expected {:} but was {:}",
                446usize,
                (core::ptr::addr_of!(d.quantity_triggered_stop_quantity_for_trigger) as usize) - p,
            );
            assert_eq!(
                454usize,
                (core::ptr::addr_of!(d.accumulated_trade_volume_for_triggered_stop) as usize) - p,
                "accumulated_trade_volume_for_triggered_stop offset expected {:} but was {:}",
                454usize,
                (core::ptr::addr_of!(d.accumulated_trade_volume_for_triggered_stop) as usize) - p,
            );
            assert_eq!(
                462usize,
                (core::ptr::addr_of!(d.bid_ask_quantity_stop_initial_trigger_met) as usize) - p,
                "bid_ask_quantity_stop_initial_trigger_met offset expected {:} but was {:}",
                462usize,
                (core::ptr::addr_of!(d.bid_ask_quantity_stop_initial_trigger_met) as usize) - p,
            );
            assert_eq!(
                463usize,
                (core::ptr::addr_of!(d.need_to_override_lock) as usize) - p,
                "need_to_override_lock offset expected {:} but was {:}",
                463usize,
                (core::ptr::addr_of!(d.need_to_override_lock) as usize) - p,
            );
            assert_eq!(
                464usize,
                (core::ptr::addr_of!(d.current_market_price) as usize) - p,
                "current_market_price offset expected {:} but was {:}",
                464usize,
                (core::ptr::addr_of!(d.current_market_price) as usize) - p,
            );
            assert_eq!(
                472usize,
                (core::ptr::addr_of!(d.current_market_date_time) as usize) - p,
                "current_market_date_time offset expected {:} but was {:}",
                472usize,
                (core::ptr::addr_of!(d.current_market_date_time) as usize) - p,
            );
            assert_eq!(
                480usize,
                (core::ptr::addr_of!(d.support_order_fill_billing) as usize) - p,
                "support_order_fill_billing offset expected {:} but was {:}",
                480usize,
                (core::ptr::addr_of!(d.support_order_fill_billing) as usize) - p,
            );
            assert_eq!(
                481usize,
                (core::ptr::addr_of!(d.is_billable) as usize) - p,
                "is_billable offset expected {:} but was {:}",
                481usize,
                (core::ptr::addr_of!(d.is_billable) as usize) - p,
            );
            assert_eq!(
                482usize,
                (core::ptr::addr_of!(d.quantity_for_billing) as usize) - p,
                "quantity_for_billing offset expected {:} but was {:}",
                482usize,
                (core::ptr::addr_of!(d.quantity_for_billing) as usize) - p,
            );
            assert_eq!(
                486usize,
                (core::ptr::addr_of!(d.number_of_failed_order_modifications) as usize) - p,
                "number_of_failed_order_modifications offset expected {:} but was {:}",
                486usize,
                (core::ptr::addr_of!(d.number_of_failed_order_modifications) as usize) - p,
            );
            assert_eq!(
                490usize,
                (core::ptr::addr_of!(d.dtc_server_index) as usize) - p,
                "dtc_server_index offset expected {:} but was {:}",
                490usize,
                (core::ptr::addr_of!(d.dtc_server_index) as usize) - p,
            );
            assert_eq!(
                494usize,
                (core::ptr::addr_of!(d.clearing_firm_id) as usize) - p,
                "clearing_firm_id offset expected {:} but was {:}",
                494usize,
                (core::ptr::addr_of!(d.clearing_firm_id) as usize) - p,
            );
            assert_eq!(
                498usize,
                (core::ptr::addr_of!(d.sender_sub_id) as usize) - p,
                "sender_sub_id offset expected {:} but was {:}",
                498usize,
                (core::ptr::addr_of!(d.sender_sub_id) as usize) - p,
            );
            assert_eq!(
                502usize,
                (core::ptr::addr_of!(d.sender_location_id) as usize) - p,
                "sender_location_id offset expected {:} but was {:}",
                502usize,
                (core::ptr::addr_of!(d.sender_location_id) as usize) - p,
            );
            assert_eq!(
                506usize,
                (core::ptr::addr_of!(d.self_match_prevention_id) as usize) - p,
                "self_match_prevention_id offset expected {:} but was {:}",
                506usize,
                (core::ptr::addr_of!(d.self_match_prevention_id) as usize) - p,
            );
            assert_eq!(
                510usize,
                (core::ptr::addr_of!(d.cti_code) as usize) - p,
                "cti_code offset expected {:} but was {:}",
                510usize,
                (core::ptr::addr_of!(d.cti_code) as usize) - p,
            );
            assert_eq!(
                514usize,
                (core::ptr::addr_of!(d.obtain_order_action_date_time_from_last_trade_time_in_chart) as usize) - p,
                "obtain_order_action_date_time_from_last_trade_time_in_chart offset expected {:} but was {:}",
                514usize,
                (core::ptr::addr_of!(d.obtain_order_action_date_time_from_last_trade_time_in_chart) as usize) - p,
            );
            assert_eq!(
                515usize,
                (core::ptr::addr_of!(d.maximum_show_quantity) as usize) - p,
                "maximum_show_quantity offset expected {:} but was {:}",
                515usize,
                (core::ptr::addr_of!(d.maximum_show_quantity) as usize) - p,
            );
            assert_eq!(
                523usize,
                (core::ptr::addr_of!(d.order_submitted) as usize) - p,
                "order_submitted offset expected {:} but was {:}",
                523usize,
                (core::ptr::addr_of!(d.order_submitted) as usize) - p,
            );
            assert_eq!(
                524usize,
                (core::ptr::addr_of!(d.is_snapshot) as usize) - p,
                "is_snapshot offset expected {:} but was {:}",
                524usize,
                (core::ptr::addr_of!(d.is_snapshot) as usize) - p,
            );
            assert_eq!(
                525usize,
                (core::ptr::addr_of!(d.is_first_message_in_batch) as usize) - p,
                "is_first_message_in_batch offset expected {:} but was {:}",
                525usize,
                (core::ptr::addr_of!(d.is_first_message_in_batch) as usize) - p,
            );
            assert_eq!(
                526usize,
                (core::ptr::addr_of!(d.is_last_message_in_batch) as usize) - p,
                "is_last_message_in_batch offset expected {:} but was {:}",
                526usize,
                (core::ptr::addr_of!(d.is_last_message_in_batch) as usize) - p,
            );
            assert_eq!(
                527usize,
                (core::ptr::addr_of!(d.external_last_action_date_time_utc) as usize) - p,
                "external_last_action_date_time_utc offset expected {:} but was {:}",
                527usize,
                (core::ptr::addr_of!(d.external_last_action_date_time_utc) as usize) - p,
            );
        }
    }
}
