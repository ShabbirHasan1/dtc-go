// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-25 15:25:42.126453 +0800 WITA m=+0.007296918
use super::*;

pub(crate) const ACCOUNT_BALANCE_UPDATE_VLS_SIZE: usize = 168;

pub(crate) const ACCOUNT_BALANCE_UPDATE_FIXED_SIZE: usize = 368;

/// size                                       u16                          = AccountBalanceUpdateVLSSize  (168)
/// type                                       u16                          = ACCOUNT_BALANCE_UPDATE  (600)
/// base_size                                  u16                          = AccountBalanceUpdateVLSSize  (168)
/// request_id                                 i32                          = 0
/// cash_balance                               f64                          = 0
/// balance_available_for_new_positions        f64                          = 0
/// account_currency                           string                       = ""
/// trade_account                              string                       = ""
/// securities_value                           f64                          = 0
/// margin_requirement                         f64                          = 0
/// total_number_messages                      i32                          = 0
/// message_number                             i32                          = 0
/// no_account_balances                        u8                           = 0
/// unsolicited                                u8                           = 0
/// open_positions_profit_loss                 f64                          = 0
/// daily_profit_loss                          f64                          = 0
/// info_text                                  string                       = ""
/// transaction_identifier                     u64                          = 0
/// daily_net_loss_limit                       f64                          = 0
/// trailing_account_value_to_limit_positions  f64                          = 0
/// daily_net_loss_limit_reached               u8                           = 0
/// is_under_required_margin                   bool                         = false
/// close_positions_at_end_of_day              u8                           = 0
/// trading_is_disabled                        bool                         = false
/// description                                string                       = ""
/// is_under_required_account_value            bool                         = false
/// transaction_date_time                      DateTimeWithMicrosecondsInt  = 0
/// margin_requirement_full                    f64                          = 0
/// margin_requirement_full_positions_only     f64                          = 0
/// peak_margin_requirement                    f64                          = 0
pub(crate) const ACCOUNT_BALANCE_UPDATE_VLS_DEFAULT: [u8; 168] = [
    168, 0, 88, 2, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/// size                                       u16                          = AccountBalanceUpdateFixedSize  (368)
/// type                                       u16                          = ACCOUNT_BALANCE_UPDATE  (600)
/// request_id                                 i32                          = 0
/// cash_balance                               f64                          = 0
/// balance_available_for_new_positions        f64                          = 0
/// account_currency                           string8                      = ""
/// trade_account                              string32                     = ""
/// securities_value                           f64                          = 0
/// margin_requirement                         f64                          = 0
/// total_number_messages                      i32                          = 0
/// message_number                             i32                          = 0
/// no_account_balances                        u8                           = 0
/// unsolicited                                u8                           = 0
/// open_positions_profit_loss                 f64                          = 0
/// daily_profit_loss                          f64                          = 0
/// info_text                                  string96                     = ""
/// transaction_identifier                     u64                          = 0
/// daily_net_loss_limit                       f64                          = 0
/// trailing_account_value_to_limit_positions  f64                          = 0
/// daily_net_loss_limit_reached               u8                           = 0
/// is_under_required_margin                   bool                         = false
/// close_positions_at_end_of_day              u8                           = 0
/// trading_is_disabled                        bool                         = false
/// description                                string96                     = ""
/// is_under_required_account_value            bool                         = false
/// transaction_date_time                      DateTimeWithMicrosecondsInt  = 0
/// margin_requirement_full                    f64                          = 0
/// margin_requirement_full_positions_only     f64                          = 0
/// peak_margin_requirement                    f64                          = 0
pub(crate) const ACCOUNT_BALANCE_UPDATE_FIXED_DEFAULT: [u8; 368] = [
    112, 1, 88, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/// This is an optional message from the Server to Client to provide Account
/// Balance information for a particular Trade Account. The server needs to
/// provide a separate message for each Trade Account associated with the
/// logged in username if it supports Account Balance updates.
///
/// The Server will respond with an AccountBalanceUpdateVLS in response to
/// a AccountBalanceRequestVLS message. The Server will set the RequestID
/// in the AccountBalanceUpdateVLS message to match the RequestID in the AccountBalanceRequestVLS
/// message.
///
/// The Server will periodically send AccountBalanceUpdateVLS messages as
/// the Account Balance data changes. The frequency of the updates is determined
/// by the Server. Account Balance updates are considered automatically subscribed
/// to. When an unsolicited AccountBalanceUpdateVLS message is sent, the RequestID
/// field will be 0.
///
/// When the server is responding with one or more AccountBalanceUpdateVLS
/// messages in response to a AccountBalanceRequestVLS message, it must not
/// send any unsolicited AccountBalanceUpdateVLS messages interleaved with
/// the solicited AccountBalanceUpdateVLS messages in response to the AccountBalanceRequestVLS
/// message.
pub trait AccountBalanceUpdate: Message {
    type Safe: AccountBalanceUpdate;
    type Unsafe: AccountBalanceUpdate;

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn request_id(&self) -> i32;

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn cash_balance(&self) -> f64;

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn balance_available_for_new_positions(&self) -> f64;

    /// ISO Currency Code for the cash values in this message.
    fn account_currency(&self) -> &str;

    /// The trade account identifier for the Account Balance information.
    fn trade_account(&self) -> &str;

    /// This is the value of all cash and securities as a cash value.
    fn securities_value(&self) -> f64;

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn margin_requirement(&self) -> f64;

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn total_number_messages(&self) -> i32;

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn message_number(&self) -> i32;

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn no_account_balances(&self) -> u8;

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn unsolicited(&self) -> u8;

    fn open_positions_profit_loss(&self) -> f64;

    fn daily_profit_loss(&self) -> f64;

    fn info_text(&self) -> &str;

    fn transaction_identifier(&self) -> u64;

    fn daily_net_loss_limit(&self) -> f64;

    fn trailing_account_value_to_limit_positions(&self) -> f64;

    fn daily_net_loss_limit_reached(&self) -> u8;

    fn is_under_required_margin(&self) -> bool;

    fn close_positions_at_end_of_day(&self) -> u8;

    fn trading_is_disabled(&self) -> bool;

    fn description(&self) -> &str;

    fn is_under_required_account_value(&self) -> bool;

    fn transaction_date_time(&self) -> DateTimeWithMicrosecondsInt;

    fn margin_requirement_full(&self) -> f64;

    fn margin_requirement_full_positions_only(&self) -> f64;

    fn peak_margin_requirement(&self) -> f64;

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn set_request_id(&mut self, value: i32) -> &mut Self;

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn set_cash_balance(&mut self, value: f64) -> &mut Self;

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn set_balance_available_for_new_positions(&mut self, value: f64) -> &mut Self;

    /// ISO Currency Code for the cash values in this message.
    fn set_account_currency(&mut self, value: &str) -> &mut Self;

    /// The trade account identifier for the Account Balance information.
    fn set_trade_account(&mut self, value: &str) -> &mut Self;

    /// This is the value of all cash and securities as a cash value.
    fn set_securities_value(&mut self, value: f64) -> &mut Self;

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn set_margin_requirement(&mut self, value: f64) -> &mut Self;

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_total_number_messages(&mut self, value: i32) -> &mut Self;

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_message_number(&mut self, value: i32) -> &mut Self;

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn set_no_account_balances(&mut self, value: u8) -> &mut Self;

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn set_unsolicited(&mut self, value: u8) -> &mut Self;

    fn set_open_positions_profit_loss(&mut self, value: f64) -> &mut Self;

    fn set_daily_profit_loss(&mut self, value: f64) -> &mut Self;

    fn set_info_text(&mut self, value: &str) -> &mut Self;

    fn set_transaction_identifier(&mut self, value: u64) -> &mut Self;

    fn set_daily_net_loss_limit(&mut self, value: f64) -> &mut Self;

    fn set_trailing_account_value_to_limit_positions(&mut self, value: f64) -> &mut Self;

    fn set_daily_net_loss_limit_reached(&mut self, value: u8) -> &mut Self;

    fn set_is_under_required_margin(&mut self, value: bool) -> &mut Self;

    fn set_close_positions_at_end_of_day(&mut self, value: u8) -> &mut Self;

    fn set_trading_is_disabled(&mut self, value: bool) -> &mut Self;

    fn set_description(&mut self, value: &str) -> &mut Self;

    fn set_is_under_required_account_value(&mut self, value: bool) -> &mut Self;

    fn set_transaction_date_time(&mut self, value: DateTimeWithMicrosecondsInt) -> &mut Self;

    fn set_margin_requirement_full(&mut self, value: f64) -> &mut Self;

    fn set_margin_requirement_full_positions_only(&mut self, value: f64) -> &mut Self;

    fn set_peak_margin_requirement(&mut self, value: f64) -> &mut Self;

    fn clone_safe(&self) -> Self::Safe;

    fn to_safe(self) -> Self::Safe;

    fn copy_to(&self, to: &mut impl AccountBalanceUpdate) {
        to.set_request_id(self.request_id());
        to.set_cash_balance(self.cash_balance());
        to.set_balance_available_for_new_positions(self.balance_available_for_new_positions());
        to.set_account_currency(self.account_currency());
        to.set_trade_account(self.trade_account());
        to.set_securities_value(self.securities_value());
        to.set_margin_requirement(self.margin_requirement());
        to.set_total_number_messages(self.total_number_messages());
        to.set_message_number(self.message_number());
        to.set_no_account_balances(self.no_account_balances());
        to.set_unsolicited(self.unsolicited());
        to.set_open_positions_profit_loss(self.open_positions_profit_loss());
        to.set_daily_profit_loss(self.daily_profit_loss());
        to.set_info_text(self.info_text());
        to.set_transaction_identifier(self.transaction_identifier());
        to.set_daily_net_loss_limit(self.daily_net_loss_limit());
        to.set_trailing_account_value_to_limit_positions(
            self.trailing_account_value_to_limit_positions(),
        );
        to.set_daily_net_loss_limit_reached(self.daily_net_loss_limit_reached());
        to.set_is_under_required_margin(self.is_under_required_margin());
        to.set_close_positions_at_end_of_day(self.close_positions_at_end_of_day());
        to.set_trading_is_disabled(self.trading_is_disabled());
        to.set_description(self.description());
        to.set_is_under_required_account_value(self.is_under_required_account_value());
        to.set_transaction_date_time(self.transaction_date_time());
        to.set_margin_requirement_full(self.margin_requirement_full());
        to.set_margin_requirement_full_positions_only(
            self.margin_requirement_full_positions_only(),
        );
        to.set_peak_margin_requirement(self.peak_margin_requirement());
    }
}

/// This is an optional message from the Server to Client to provide Account
/// Balance information for a particular Trade Account. The server needs to
/// provide a separate message for each Trade Account associated with the
/// logged in username if it supports Account Balance updates.
///
/// The Server will respond with an AccountBalanceUpdateVLS in response to
/// a AccountBalanceRequestVLS message. The Server will set the RequestID
/// in the AccountBalanceUpdateVLS message to match the RequestID in the AccountBalanceRequestVLS
/// message.
///
/// The Server will periodically send AccountBalanceUpdateVLS messages as
/// the Account Balance data changes. The frequency of the updates is determined
/// by the Server. Account Balance updates are considered automatically subscribed
/// to. When an unsolicited AccountBalanceUpdateVLS message is sent, the RequestID
/// field will be 0.
///
/// When the server is responding with one or more AccountBalanceUpdateVLS
/// messages in response to a AccountBalanceRequestVLS message, it must not
/// send any unsolicited AccountBalanceUpdateVLS messages interleaved with
/// the solicited AccountBalanceUpdateVLS messages in response to the AccountBalanceRequestVLS
/// message.
pub struct AccountBalanceUpdateVLS {
    data: *const AccountBalanceUpdateVLSData,
    capacity: usize,
}

pub struct AccountBalanceUpdateVLSUnsafe {
    data: *const AccountBalanceUpdateVLSData,
    capacity: usize,
}

#[repr(packed(8), C)]
pub struct AccountBalanceUpdateVLSData {
    size: u16,
    r#type: u16,
    base_size: u16,
    request_id: i32,
    cash_balance: f64,
    balance_available_for_new_positions: f64,
    account_currency: VLS,
    trade_account: VLS,
    securities_value: f64,
    margin_requirement: f64,
    total_number_messages: i32,
    message_number: i32,
    no_account_balances: u8,
    unsolicited: u8,
    open_positions_profit_loss: f64,
    daily_profit_loss: f64,
    info_text: VLS,
    transaction_identifier: u64,
    daily_net_loss_limit: f64,
    trailing_account_value_to_limit_positions: f64,
    daily_net_loss_limit_reached: u8,
    is_under_required_margin: bool,
    close_positions_at_end_of_day: u8,
    trading_is_disabled: bool,
    description: VLS,
    is_under_required_account_value: bool,
    transaction_date_time: DateTimeWithMicrosecondsInt,
    margin_requirement_full: f64,
    margin_requirement_full_positions_only: f64,
    peak_margin_requirement: f64,
}

/// This is an optional message from the Server to Client to provide Account
/// Balance information for a particular Trade Account. The server needs to
/// provide a separate message for each Trade Account associated with the
/// logged in username if it supports Account Balance updates.
///
/// The Server will respond with an AccountBalanceUpdateVLS in response to
/// a AccountBalanceRequestVLS message. The Server will set the RequestID
/// in the AccountBalanceUpdateVLS message to match the RequestID in the AccountBalanceRequestVLS
/// message.
///
/// The Server will periodically send AccountBalanceUpdateVLS messages as
/// the Account Balance data changes. The frequency of the updates is determined
/// by the Server. Account Balance updates are considered automatically subscribed
/// to. When an unsolicited AccountBalanceUpdateVLS message is sent, the RequestID
/// field will be 0.
///
/// When the server is responding with one or more AccountBalanceUpdateVLS
/// messages in response to a AccountBalanceRequestVLS message, it must not
/// send any unsolicited AccountBalanceUpdateVLS messages interleaved with
/// the solicited AccountBalanceUpdateVLS messages in response to the AccountBalanceRequestVLS
/// message.
pub struct AccountBalanceUpdateFixed {
    data: *const AccountBalanceUpdateFixedData,
}

pub struct AccountBalanceUpdateFixedUnsafe {
    data: *const AccountBalanceUpdateFixedData,
}

#[repr(packed(8), C)]
pub struct AccountBalanceUpdateFixedData {
    size: u16,
    r#type: u16,
    request_id: i32,
    cash_balance: f64,
    balance_available_for_new_positions: f64,
    account_currency: [u8; 8],
    trade_account: [u8; 32],
    securities_value: f64,
    margin_requirement: f64,
    total_number_messages: i32,
    message_number: i32,
    no_account_balances: u8,
    unsolicited: u8,
    open_positions_profit_loss: f64,
    daily_profit_loss: f64,
    info_text: [u8; 96],
    transaction_identifier: u64,
    daily_net_loss_limit: f64,
    trailing_account_value_to_limit_positions: f64,
    daily_net_loss_limit_reached: u8,
    is_under_required_margin: bool,
    close_positions_at_end_of_day: u8,
    trading_is_disabled: bool,
    description: [u8; 96],
    is_under_required_account_value: bool,
    transaction_date_time: DateTimeWithMicrosecondsInt,
    margin_requirement_full: f64,
    margin_requirement_full_positions_only: f64,
    peak_margin_requirement: f64,
}

impl AccountBalanceUpdateVLSData {
    pub fn new() -> Self {
        Self {
            size: 168u16.to_le(),
            r#type: ACCOUNT_BALANCE_UPDATE.to_le(),
            base_size: 168u16.to_le(),
            request_id: 0i32,
            cash_balance: 0.0f64,
            balance_available_for_new_positions: 0.0f64,
            account_currency: crate::message::VLS::new(),
            trade_account: crate::message::VLS::new(),
            securities_value: 0.0f64,
            margin_requirement: 0.0f64,
            total_number_messages: 0i32,
            message_number: 0i32,
            no_account_balances: 0u8,
            unsolicited: 0u8,
            open_positions_profit_loss: 0.0f64,
            daily_profit_loss: 0.0f64,
            info_text: crate::message::VLS::new(),
            transaction_identifier: 0u64,
            daily_net_loss_limit: 0.0f64,
            trailing_account_value_to_limit_positions: 0.0f64,
            daily_net_loss_limit_reached: 0,
            is_under_required_margin: false,
            close_positions_at_end_of_day: 0,
            trading_is_disabled: false,
            description: crate::message::VLS::new(),
            is_under_required_account_value: false,
            transaction_date_time: 0i64.to_le(),
            margin_requirement_full: 0.0,
            margin_requirement_full_positions_only: 0.0,
            peak_margin_requirement: 0.0,
        }
    }
}

impl AccountBalanceUpdateFixedData {
    pub fn new() -> Self {
        Self {
            size: 368u16.to_le(),
            r#type: ACCOUNT_BALANCE_UPDATE.to_le(),
            request_id: 0i32,
            cash_balance: 0.0f64,
            balance_available_for_new_positions: 0.0f64,
            account_currency: [0; 8],
            trade_account: [0; 32],
            securities_value: 0.0f64,
            margin_requirement: 0.0f64,
            total_number_messages: 0i32,
            message_number: 0i32,
            no_account_balances: 0u8,
            unsolicited: 0u8,
            open_positions_profit_loss: 0.0f64,
            daily_profit_loss: 0.0f64,
            info_text: [0; 96],
            transaction_identifier: 0u64,
            daily_net_loss_limit: 0.0f64,
            trailing_account_value_to_limit_positions: 0.0f64,
            daily_net_loss_limit_reached: 0,
            is_under_required_margin: false,
            close_positions_at_end_of_day: 0,
            trading_is_disabled: false,
            description: [0; 96],
            is_under_required_account_value: false,
            transaction_date_time: 0i64.to_le(),
            margin_requirement_full: 0.0,
            margin_requirement_full_positions_only: 0.0,
            peak_margin_requirement: 0.0,
        }
    }
}

unsafe impl Send for AccountBalanceUpdateFixed {}
unsafe impl Send for AccountBalanceUpdateFixedUnsafe {}
unsafe impl Send for AccountBalanceUpdateFixedData {}
unsafe impl Send for AccountBalanceUpdateVLS {}
unsafe impl Send for AccountBalanceUpdateVLSUnsafe {}
unsafe impl Send for AccountBalanceUpdateVLSData {}

impl Drop for AccountBalanceUpdateFixed {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for AccountBalanceUpdateFixedUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for AccountBalanceUpdateVLS {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for AccountBalanceUpdateVLSUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Clone for AccountBalanceUpdateFixed {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for AccountBalanceUpdateFixedUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for AccountBalanceUpdateVLS {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for AccountBalanceUpdateVLSUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Into<Vec<u8>> for AccountBalanceUpdateFixed {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for AccountBalanceUpdateFixedUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for AccountBalanceUpdateVLS {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for AccountBalanceUpdateVLSUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl core::ops::Deref for AccountBalanceUpdateFixed {
    type Target = AccountBalanceUpdateFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for AccountBalanceUpdateFixed {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for AccountBalanceUpdateFixedUnsafe {
    type Target = AccountBalanceUpdateFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for AccountBalanceUpdateFixedUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for AccountBalanceUpdateVLS {
    type Target = AccountBalanceUpdateVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for AccountBalanceUpdateVLS {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for AccountBalanceUpdateVLSUnsafe {
    type Target = AccountBalanceUpdateVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for AccountBalanceUpdateVLSUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl crate::Message for AccountBalanceUpdateFixed {
    type Data = AccountBalanceUpdateFixedData;

    const BASE_SIZE: usize = 368;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, AccountBalanceUpdateFixedData::new()),
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const AccountBalanceUpdateFixedData,
        }
    }
}
impl crate::Message for AccountBalanceUpdateFixedUnsafe {
    type Data = AccountBalanceUpdateFixedData;

    const BASE_SIZE: usize = 368;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, AccountBalanceUpdateFixedData::new()),
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const AccountBalanceUpdateFixedData,
        }
    }
}
impl crate::Message for AccountBalanceUpdateVLS {
    type Data = AccountBalanceUpdateVLSData;

    const BASE_SIZE: usize = 168;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, AccountBalanceUpdateVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const AccountBalanceUpdateVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for AccountBalanceUpdateVLS {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const AccountBalanceUpdateVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl crate::Message for AccountBalanceUpdateVLSUnsafe {
    type Data = AccountBalanceUpdateVLSData;

    const BASE_SIZE: usize = 168;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, AccountBalanceUpdateVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const AccountBalanceUpdateVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for AccountBalanceUpdateVLSUnsafe {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const AccountBalanceUpdateVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
/// This is an optional message from the Server to Client to provide Account
/// Balance information for a particular Trade Account. The server needs to
/// provide a separate message for each Trade Account associated with the
/// logged in username if it supports Account Balance updates.
///
/// The Server will respond with an AccountBalanceUpdateVLS in response to
/// a AccountBalanceRequestVLS message. The Server will set the RequestID
/// in the AccountBalanceUpdateVLS message to match the RequestID in the AccountBalanceRequestVLS
/// message.
///
/// The Server will periodically send AccountBalanceUpdateVLS messages as
/// the Account Balance data changes. The frequency of the updates is determined
/// by the Server. Account Balance updates are considered automatically subscribed
/// to. When an unsolicited AccountBalanceUpdateVLS message is sent, the RequestID
/// field will be 0.
///
/// When the server is responding with one or more AccountBalanceUpdateVLS
/// messages in response to a AccountBalanceRequestVLS message, it must not
/// send any unsolicited AccountBalanceUpdateVLS messages interleaved with
/// the solicited AccountBalanceUpdateVLS messages in response to the AccountBalanceRequestVLS
/// message.
impl AccountBalanceUpdate for AccountBalanceUpdateVLS {
    type Safe = AccountBalanceUpdateVLS;
    type Unsafe = AccountBalanceUpdateVLSUnsafe;

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn request_id(&self) -> i32 {
        i32::from_le(self.request_id)
    }

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn cash_balance(&self) -> f64 {
        f64_le(self.cash_balance)
    }

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn balance_available_for_new_positions(&self) -> f64 {
        f64_le(self.balance_available_for_new_positions)
    }

    /// ISO Currency Code for the cash values in this message.
    fn account_currency(&self) -> &str {
        get_vls(self, self.account_currency)
    }

    /// The trade account identifier for the Account Balance information.
    fn trade_account(&self) -> &str {
        get_vls(self, self.trade_account)
    }

    /// This is the value of all cash and securities as a cash value.
    fn securities_value(&self) -> f64 {
        f64_le(self.securities_value)
    }

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn margin_requirement(&self) -> f64 {
        f64_le(self.margin_requirement)
    }

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn total_number_messages(&self) -> i32 {
        i32::from_le(self.total_number_messages)
    }

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn message_number(&self) -> i32 {
        i32::from_le(self.message_number)
    }

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn no_account_balances(&self) -> u8 {
        self.no_account_balances
    }

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn unsolicited(&self) -> u8 {
        self.unsolicited
    }

    fn open_positions_profit_loss(&self) -> f64 {
        f64_le(self.open_positions_profit_loss)
    }

    fn daily_profit_loss(&self) -> f64 {
        f64_le(self.daily_profit_loss)
    }

    fn info_text(&self) -> &str {
        get_vls(self, self.info_text)
    }

    fn transaction_identifier(&self) -> u64 {
        u64::from_le(self.transaction_identifier)
    }

    fn daily_net_loss_limit(&self) -> f64 {
        f64_le(self.daily_net_loss_limit)
    }

    fn trailing_account_value_to_limit_positions(&self) -> f64 {
        f64_le(self.trailing_account_value_to_limit_positions)
    }

    fn daily_net_loss_limit_reached(&self) -> u8 {
        self.daily_net_loss_limit_reached
    }

    fn is_under_required_margin(&self) -> bool {
        self.is_under_required_margin
    }

    fn close_positions_at_end_of_day(&self) -> u8 {
        self.close_positions_at_end_of_day
    }

    fn trading_is_disabled(&self) -> bool {
        self.trading_is_disabled
    }

    fn description(&self) -> &str {
        get_vls(self, self.description)
    }

    fn is_under_required_account_value(&self) -> bool {
        self.is_under_required_account_value
    }

    fn transaction_date_time(&self) -> DateTimeWithMicrosecondsInt {
        i64::from_le(self.transaction_date_time)
    }

    fn margin_requirement_full(&self) -> f64 {
        f64_le(self.margin_requirement_full)
    }

    fn margin_requirement_full_positions_only(&self) -> f64 {
        f64_le(self.margin_requirement_full_positions_only)
    }

    fn peak_margin_requirement(&self) -> f64 {
        f64_le(self.peak_margin_requirement)
    }

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn set_request_id(&mut self, value: i32) -> &mut Self {
        self.request_id = value.to_le();
        self
    }

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn set_cash_balance(&mut self, value: f64) -> &mut Self {
        self.cash_balance = f64_le(value);
        self
    }

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn set_balance_available_for_new_positions(&mut self, value: f64) -> &mut Self {
        self.balance_available_for_new_positions = f64_le(value);
        self
    }

    /// ISO Currency Code for the cash values in this message.
    fn set_account_currency(&mut self, value: &str) -> &mut Self {
        self.account_currency = set_vls(self, self.account_currency, value);
        self
    }

    /// The trade account identifier for the Account Balance information.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        self.trade_account = set_vls(self, self.trade_account, value);
        self
    }

    /// This is the value of all cash and securities as a cash value.
    fn set_securities_value(&mut self, value: f64) -> &mut Self {
        self.securities_value = f64_le(value);
        self
    }

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn set_margin_requirement(&mut self, value: f64) -> &mut Self {
        self.margin_requirement = f64_le(value);
        self
    }

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_total_number_messages(&mut self, value: i32) -> &mut Self {
        self.total_number_messages = value.to_le();
        self
    }

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_message_number(&mut self, value: i32) -> &mut Self {
        self.message_number = value.to_le();
        self
    }

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn set_no_account_balances(&mut self, value: u8) -> &mut Self {
        self.no_account_balances = value;
        self
    }

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn set_unsolicited(&mut self, value: u8) -> &mut Self {
        self.unsolicited = value;
        self
    }

    fn set_open_positions_profit_loss(&mut self, value: f64) -> &mut Self {
        self.open_positions_profit_loss = f64_le(value);
        self
    }

    fn set_daily_profit_loss(&mut self, value: f64) -> &mut Self {
        self.daily_profit_loss = f64_le(value);
        self
    }

    fn set_info_text(&mut self, value: &str) -> &mut Self {
        self.info_text = set_vls(self, self.info_text, value);
        self
    }

    fn set_transaction_identifier(&mut self, value: u64) -> &mut Self {
        self.transaction_identifier = value.to_le();
        self
    }

    fn set_daily_net_loss_limit(&mut self, value: f64) -> &mut Self {
        self.daily_net_loss_limit = f64_le(value);
        self
    }

    fn set_trailing_account_value_to_limit_positions(&mut self, value: f64) -> &mut Self {
        self.trailing_account_value_to_limit_positions = f64_le(value);
        self
    }

    fn set_daily_net_loss_limit_reached(&mut self, value: u8) -> &mut Self {
        self.daily_net_loss_limit_reached = value;
        self
    }

    fn set_is_under_required_margin(&mut self, value: bool) -> &mut Self {
        self.is_under_required_margin = value;
        self
    }

    fn set_close_positions_at_end_of_day(&mut self, value: u8) -> &mut Self {
        self.close_positions_at_end_of_day = value;
        self
    }

    fn set_trading_is_disabled(&mut self, value: bool) -> &mut Self {
        self.trading_is_disabled = value;
        self
    }

    fn set_description(&mut self, value: &str) -> &mut Self {
        self.description = set_vls(self, self.description, value);
        self
    }

    fn set_is_under_required_account_value(&mut self, value: bool) -> &mut Self {
        self.is_under_required_account_value = value;
        self
    }

    fn set_transaction_date_time(&mut self, value: DateTimeWithMicrosecondsInt) -> &mut Self {
        self.transaction_date_time = value.to_le();
        self
    }

    fn set_margin_requirement_full(&mut self, value: f64) -> &mut Self {
        self.margin_requirement_full = f64_le(value);
        self
    }

    fn set_margin_requirement_full_positions_only(&mut self, value: f64) -> &mut Self {
        self.margin_requirement_full_positions_only = f64_le(value);
        self
    }

    fn set_peak_margin_requirement(&mut self, value: f64) -> &mut Self {
        self.peak_margin_requirement = f64_le(value);
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

/// This is an optional message from the Server to Client to provide Account
/// Balance information for a particular Trade Account. The server needs to
/// provide a separate message for each Trade Account associated with the
/// logged in username if it supports Account Balance updates.
///
/// The Server will respond with an AccountBalanceUpdateVLS in response to
/// a AccountBalanceRequestVLS message. The Server will set the RequestID
/// in the AccountBalanceUpdateVLS message to match the RequestID in the AccountBalanceRequestVLS
/// message.
///
/// The Server will periodically send AccountBalanceUpdateVLS messages as
/// the Account Balance data changes. The frequency of the updates is determined
/// by the Server. Account Balance updates are considered automatically subscribed
/// to. When an unsolicited AccountBalanceUpdateVLS message is sent, the RequestID
/// field will be 0.
///
/// When the server is responding with one or more AccountBalanceUpdateVLS
/// messages in response to a AccountBalanceRequestVLS message, it must not
/// send any unsolicited AccountBalanceUpdateVLS messages interleaved with
/// the solicited AccountBalanceUpdateVLS messages in response to the AccountBalanceRequestVLS
/// message.
impl AccountBalanceUpdate for AccountBalanceUpdateVLSUnsafe {
    type Safe = AccountBalanceUpdateVLS;
    type Unsafe = AccountBalanceUpdateVLSUnsafe;

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn request_id(&self) -> i32 {
        if self.is_out_of_bounds(12) {
            0i32
        } else {
            i32::from_le(self.request_id)
        }
    }

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn cash_balance(&self) -> f64 {
        if self.is_out_of_bounds(24) {
            0.0f64
        } else {
            f64_le(self.cash_balance)
        }
    }

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn balance_available_for_new_positions(&self) -> f64 {
        if self.is_out_of_bounds(32) {
            0.0f64
        } else {
            f64_le(self.balance_available_for_new_positions)
        }
    }

    /// ISO Currency Code for the cash values in this message.
    fn account_currency(&self) -> &str {
        if self.is_out_of_bounds(36) {
            ""
        } else {
            get_vls(self, self.account_currency)
        }
    }

    /// The trade account identifier for the Account Balance information.
    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(40) {
            ""
        } else {
            get_vls(self, self.trade_account)
        }
    }

    /// This is the value of all cash and securities as a cash value.
    fn securities_value(&self) -> f64 {
        if self.is_out_of_bounds(48) {
            0.0f64
        } else {
            f64_le(self.securities_value)
        }
    }

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn margin_requirement(&self) -> f64 {
        if self.is_out_of_bounds(56) {
            0.0f64
        } else {
            f64_le(self.margin_requirement)
        }
    }

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn total_number_messages(&self) -> i32 {
        if self.is_out_of_bounds(60) {
            0i32
        } else {
            i32::from_le(self.total_number_messages)
        }
    }

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn message_number(&self) -> i32 {
        if self.is_out_of_bounds(64) {
            0i32
        } else {
            i32::from_le(self.message_number)
        }
    }

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn no_account_balances(&self) -> u8 {
        if self.is_out_of_bounds(65) {
            0u8
        } else {
            self.no_account_balances
        }
    }

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn unsolicited(&self) -> u8 {
        if self.is_out_of_bounds(66) {
            0u8
        } else {
            self.unsolicited
        }
    }

    fn open_positions_profit_loss(&self) -> f64 {
        if self.is_out_of_bounds(80) {
            0.0f64
        } else {
            f64_le(self.open_positions_profit_loss)
        }
    }

    fn daily_profit_loss(&self) -> f64 {
        if self.is_out_of_bounds(88) {
            0.0f64
        } else {
            f64_le(self.daily_profit_loss)
        }
    }

    fn info_text(&self) -> &str {
        if self.is_out_of_bounds(92) {
            ""
        } else {
            get_vls(self, self.info_text)
        }
    }

    fn transaction_identifier(&self) -> u64 {
        if self.is_out_of_bounds(104) {
            0u64
        } else {
            u64::from_le(self.transaction_identifier)
        }
    }

    fn daily_net_loss_limit(&self) -> f64 {
        if self.is_out_of_bounds(112) {
            0.0f64
        } else {
            f64_le(self.daily_net_loss_limit)
        }
    }

    fn trailing_account_value_to_limit_positions(&self) -> f64 {
        if self.is_out_of_bounds(120) {
            0.0f64
        } else {
            f64_le(self.trailing_account_value_to_limit_positions)
        }
    }

    fn daily_net_loss_limit_reached(&self) -> u8 {
        if self.is_out_of_bounds(121) {
            0
        } else {
            self.daily_net_loss_limit_reached
        }
    }

    fn is_under_required_margin(&self) -> bool {
        if self.is_out_of_bounds(122) {
            false
        } else {
            self.is_under_required_margin
        }
    }

    fn close_positions_at_end_of_day(&self) -> u8 {
        if self.is_out_of_bounds(123) {
            0
        } else {
            self.close_positions_at_end_of_day
        }
    }

    fn trading_is_disabled(&self) -> bool {
        if self.is_out_of_bounds(124) {
            false
        } else {
            self.trading_is_disabled
        }
    }

    fn description(&self) -> &str {
        if self.is_out_of_bounds(128) {
            ""
        } else {
            get_vls(self, self.description)
        }
    }

    fn is_under_required_account_value(&self) -> bool {
        if self.is_out_of_bounds(129) {
            false
        } else {
            self.is_under_required_account_value
        }
    }

    fn transaction_date_time(&self) -> DateTimeWithMicrosecondsInt {
        if self.is_out_of_bounds(144) {
            0i64.to_le()
        } else {
            i64::from_le(self.transaction_date_time)
        }
    }

    fn margin_requirement_full(&self) -> f64 {
        if self.is_out_of_bounds(152) {
            0.0
        } else {
            f64_le(self.margin_requirement_full)
        }
    }

    fn margin_requirement_full_positions_only(&self) -> f64 {
        if self.is_out_of_bounds(160) {
            0.0
        } else {
            f64_le(self.margin_requirement_full_positions_only)
        }
    }

    fn peak_margin_requirement(&self) -> f64 {
        if self.is_out_of_bounds(168) {
            0.0
        } else {
            f64_le(self.peak_margin_requirement)
        }
    }

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn set_request_id(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(12) {
            self.request_id = value.to_le();
        }
        self
    }

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn set_cash_balance(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(24) {
            self.cash_balance = f64_le(value);
        }
        self
    }

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn set_balance_available_for_new_positions(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(32) {
            self.balance_available_for_new_positions = f64_le(value);
        }
        self
    }

    /// ISO Currency Code for the cash values in this message.
    fn set_account_currency(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(36) {
            self.account_currency = set_vls(self, self.account_currency, value);
        }
        self
    }

    /// The trade account identifier for the Account Balance information.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(40) {
            self.trade_account = set_vls(self, self.trade_account, value);
        }
        self
    }

    /// This is the value of all cash and securities as a cash value.
    fn set_securities_value(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(48) {
            self.securities_value = f64_le(value);
        }
        self
    }

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn set_margin_requirement(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(56) {
            self.margin_requirement = f64_le(value);
        }
        self
    }

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_total_number_messages(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(60) {
            self.total_number_messages = value.to_le();
        }
        self
    }

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_message_number(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(64) {
            self.message_number = value.to_le();
        }
        self
    }

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn set_no_account_balances(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(65) {
            self.no_account_balances = value;
        }
        self
    }

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn set_unsolicited(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(66) {
            self.unsolicited = value;
        }
        self
    }

    fn set_open_positions_profit_loss(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(80) {
            self.open_positions_profit_loss = f64_le(value);
        }
        self
    }

    fn set_daily_profit_loss(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(88) {
            self.daily_profit_loss = f64_le(value);
        }
        self
    }

    fn set_info_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(92) {
            self.info_text = set_vls(self, self.info_text, value);
        }
        self
    }

    fn set_transaction_identifier(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(104) {
            self.transaction_identifier = value.to_le();
        }
        self
    }

    fn set_daily_net_loss_limit(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(112) {
            self.daily_net_loss_limit = f64_le(value);
        }
        self
    }

    fn set_trailing_account_value_to_limit_positions(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(120) {
            self.trailing_account_value_to_limit_positions = f64_le(value);
        }
        self
    }

    fn set_daily_net_loss_limit_reached(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(121) {
            self.daily_net_loss_limit_reached = value;
        }
        self
    }

    fn set_is_under_required_margin(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(122) {
            self.is_under_required_margin = value;
        }
        self
    }

    fn set_close_positions_at_end_of_day(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(123) {
            self.close_positions_at_end_of_day = value;
        }
        self
    }

    fn set_trading_is_disabled(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(124) {
            self.trading_is_disabled = value;
        }
        self
    }

    fn set_description(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(128) {
            self.description = set_vls(self, self.description, value);
        }
        self
    }

    fn set_is_under_required_account_value(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(129) {
            self.is_under_required_account_value = value;
        }
        self
    }

    fn set_transaction_date_time(&mut self, value: DateTimeWithMicrosecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(144) {
            self.transaction_date_time = value.to_le();
        }
        self
    }

    fn set_margin_requirement_full(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(152) {
            self.margin_requirement_full = f64_le(value);
        }
        self
    }

    fn set_margin_requirement_full_positions_only(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(160) {
            self.margin_requirement_full_positions_only = f64_le(value);
        }
        self
    }

    fn set_peak_margin_requirement(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(168) {
            self.peak_margin_requirement = f64_le(value);
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

/// This is an optional message from the Server to Client to provide Account
/// Balance information for a particular Trade Account. The server needs to
/// provide a separate message for each Trade Account associated with the
/// logged in username if it supports Account Balance updates.
///
/// The Server will respond with an AccountBalanceUpdateVLS in response to
/// a AccountBalanceRequestVLS message. The Server will set the RequestID
/// in the AccountBalanceUpdateVLS message to match the RequestID in the AccountBalanceRequestVLS
/// message.
///
/// The Server will periodically send AccountBalanceUpdateVLS messages as
/// the Account Balance data changes. The frequency of the updates is determined
/// by the Server. Account Balance updates are considered automatically subscribed
/// to. When an unsolicited AccountBalanceUpdateVLS message is sent, the RequestID
/// field will be 0.
///
/// When the server is responding with one or more AccountBalanceUpdateVLS
/// messages in response to a AccountBalanceRequestVLS message, it must not
/// send any unsolicited AccountBalanceUpdateVLS messages interleaved with
/// the solicited AccountBalanceUpdateVLS messages in response to the AccountBalanceRequestVLS
/// message.
impl AccountBalanceUpdate for AccountBalanceUpdateFixed {
    type Safe = AccountBalanceUpdateFixed;
    type Unsafe = AccountBalanceUpdateFixedUnsafe;

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn request_id(&self) -> i32 {
        i32::from_le(self.request_id)
    }

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn cash_balance(&self) -> f64 {
        f64_le(self.cash_balance)
    }

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn balance_available_for_new_positions(&self) -> f64 {
        f64_le(self.balance_available_for_new_positions)
    }

    /// ISO Currency Code for the cash values in this message.
    fn account_currency(&self) -> &str {
        get_fixed(&self.account_currency[..])
    }

    /// The trade account identifier for the Account Balance information.
    fn trade_account(&self) -> &str {
        get_fixed(&self.trade_account[..])
    }

    /// This is the value of all cash and securities as a cash value.
    fn securities_value(&self) -> f64 {
        f64_le(self.securities_value)
    }

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn margin_requirement(&self) -> f64 {
        f64_le(self.margin_requirement)
    }

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn total_number_messages(&self) -> i32 {
        i32::from_le(self.total_number_messages)
    }

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn message_number(&self) -> i32 {
        i32::from_le(self.message_number)
    }

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn no_account_balances(&self) -> u8 {
        self.no_account_balances
    }

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn unsolicited(&self) -> u8 {
        self.unsolicited
    }

    fn open_positions_profit_loss(&self) -> f64 {
        f64_le(self.open_positions_profit_loss)
    }

    fn daily_profit_loss(&self) -> f64 {
        f64_le(self.daily_profit_loss)
    }

    fn info_text(&self) -> &str {
        get_fixed(&self.info_text[..])
    }

    fn transaction_identifier(&self) -> u64 {
        u64::from_le(self.transaction_identifier)
    }

    fn daily_net_loss_limit(&self) -> f64 {
        f64_le(self.daily_net_loss_limit)
    }

    fn trailing_account_value_to_limit_positions(&self) -> f64 {
        f64_le(self.trailing_account_value_to_limit_positions)
    }

    fn daily_net_loss_limit_reached(&self) -> u8 {
        self.daily_net_loss_limit_reached
    }

    fn is_under_required_margin(&self) -> bool {
        self.is_under_required_margin
    }

    fn close_positions_at_end_of_day(&self) -> u8 {
        self.close_positions_at_end_of_day
    }

    fn trading_is_disabled(&self) -> bool {
        self.trading_is_disabled
    }

    fn description(&self) -> &str {
        get_fixed(&self.description[..])
    }

    fn is_under_required_account_value(&self) -> bool {
        self.is_under_required_account_value
    }

    fn transaction_date_time(&self) -> DateTimeWithMicrosecondsInt {
        i64::from_le(self.transaction_date_time)
    }

    fn margin_requirement_full(&self) -> f64 {
        f64_le(self.margin_requirement_full)
    }

    fn margin_requirement_full_positions_only(&self) -> f64 {
        f64_le(self.margin_requirement_full_positions_only)
    }

    fn peak_margin_requirement(&self) -> f64 {
        f64_le(self.peak_margin_requirement)
    }

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn set_request_id(&mut self, value: i32) -> &mut Self {
        self.request_id = value.to_le();
        self
    }

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn set_cash_balance(&mut self, value: f64) -> &mut Self {
        self.cash_balance = f64_le(value);
        self
    }

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn set_balance_available_for_new_positions(&mut self, value: f64) -> &mut Self {
        self.balance_available_for_new_positions = f64_le(value);
        self
    }

    /// ISO Currency Code for the cash values in this message.
    fn set_account_currency(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.account_currency[..], value);
        self
    }

    /// The trade account identifier for the Account Balance information.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.trade_account[..], value);
        self
    }

    /// This is the value of all cash and securities as a cash value.
    fn set_securities_value(&mut self, value: f64) -> &mut Self {
        self.securities_value = f64_le(value);
        self
    }

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn set_margin_requirement(&mut self, value: f64) -> &mut Self {
        self.margin_requirement = f64_le(value);
        self
    }

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_total_number_messages(&mut self, value: i32) -> &mut Self {
        self.total_number_messages = value.to_le();
        self
    }

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_message_number(&mut self, value: i32) -> &mut Self {
        self.message_number = value.to_le();
        self
    }

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn set_no_account_balances(&mut self, value: u8) -> &mut Self {
        self.no_account_balances = value;
        self
    }

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn set_unsolicited(&mut self, value: u8) -> &mut Self {
        self.unsolicited = value;
        self
    }

    fn set_open_positions_profit_loss(&mut self, value: f64) -> &mut Self {
        self.open_positions_profit_loss = f64_le(value);
        self
    }

    fn set_daily_profit_loss(&mut self, value: f64) -> &mut Self {
        self.daily_profit_loss = f64_le(value);
        self
    }

    fn set_info_text(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.info_text[..], value);
        self
    }

    fn set_transaction_identifier(&mut self, value: u64) -> &mut Self {
        self.transaction_identifier = value.to_le();
        self
    }

    fn set_daily_net_loss_limit(&mut self, value: f64) -> &mut Self {
        self.daily_net_loss_limit = f64_le(value);
        self
    }

    fn set_trailing_account_value_to_limit_positions(&mut self, value: f64) -> &mut Self {
        self.trailing_account_value_to_limit_positions = f64_le(value);
        self
    }

    fn set_daily_net_loss_limit_reached(&mut self, value: u8) -> &mut Self {
        self.daily_net_loss_limit_reached = value;
        self
    }

    fn set_is_under_required_margin(&mut self, value: bool) -> &mut Self {
        self.is_under_required_margin = value;
        self
    }

    fn set_close_positions_at_end_of_day(&mut self, value: u8) -> &mut Self {
        self.close_positions_at_end_of_day = value;
        self
    }

    fn set_trading_is_disabled(&mut self, value: bool) -> &mut Self {
        self.trading_is_disabled = value;
        self
    }

    fn set_description(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.description[..], value);
        self
    }

    fn set_is_under_required_account_value(&mut self, value: bool) -> &mut Self {
        self.is_under_required_account_value = value;
        self
    }

    fn set_transaction_date_time(&mut self, value: DateTimeWithMicrosecondsInt) -> &mut Self {
        self.transaction_date_time = value.to_le();
        self
    }

    fn set_margin_requirement_full(&mut self, value: f64) -> &mut Self {
        self.margin_requirement_full = f64_le(value);
        self
    }

    fn set_margin_requirement_full_positions_only(&mut self, value: f64) -> &mut Self {
        self.margin_requirement_full_positions_only = f64_le(value);
        self
    }

    fn set_peak_margin_requirement(&mut self, value: f64) -> &mut Self {
        self.peak_margin_requirement = f64_le(value);
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

/// This is an optional message from the Server to Client to provide Account
/// Balance information for a particular Trade Account. The server needs to
/// provide a separate message for each Trade Account associated with the
/// logged in username if it supports Account Balance updates.
///
/// The Server will respond with an AccountBalanceUpdateVLS in response to
/// a AccountBalanceRequestVLS message. The Server will set the RequestID
/// in the AccountBalanceUpdateVLS message to match the RequestID in the AccountBalanceRequestVLS
/// message.
///
/// The Server will periodically send AccountBalanceUpdateVLS messages as
/// the Account Balance data changes. The frequency of the updates is determined
/// by the Server. Account Balance updates are considered automatically subscribed
/// to. When an unsolicited AccountBalanceUpdateVLS message is sent, the RequestID
/// field will be 0.
///
/// When the server is responding with one or more AccountBalanceUpdateVLS
/// messages in response to a AccountBalanceRequestVLS message, it must not
/// send any unsolicited AccountBalanceUpdateVLS messages interleaved with
/// the solicited AccountBalanceUpdateVLS messages in response to the AccountBalanceRequestVLS
/// message.
impl AccountBalanceUpdate for AccountBalanceUpdateFixedUnsafe {
    type Safe = AccountBalanceUpdateFixed;
    type Unsafe = AccountBalanceUpdateFixedUnsafe;

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn request_id(&self) -> i32 {
        if self.is_out_of_bounds(8) {
            0i32
        } else {
            i32::from_le(self.request_id)
        }
    }

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn cash_balance(&self) -> f64 {
        if self.is_out_of_bounds(16) {
            0.0f64
        } else {
            f64_le(self.cash_balance)
        }
    }

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn balance_available_for_new_positions(&self) -> f64 {
        if self.is_out_of_bounds(24) {
            0.0f64
        } else {
            f64_le(self.balance_available_for_new_positions)
        }
    }

    /// ISO Currency Code for the cash values in this message.
    fn account_currency(&self) -> &str {
        if self.is_out_of_bounds(32) {
            ""
        } else {
            get_fixed(&self.account_currency[..])
        }
    }

    /// The trade account identifier for the Account Balance information.
    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(64) {
            ""
        } else {
            get_fixed(&self.trade_account[..])
        }
    }

    /// This is the value of all cash and securities as a cash value.
    fn securities_value(&self) -> f64 {
        if self.is_out_of_bounds(72) {
            0.0f64
        } else {
            f64_le(self.securities_value)
        }
    }

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn margin_requirement(&self) -> f64 {
        if self.is_out_of_bounds(80) {
            0.0f64
        } else {
            f64_le(self.margin_requirement)
        }
    }

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn total_number_messages(&self) -> i32 {
        if self.is_out_of_bounds(84) {
            0i32
        } else {
            i32::from_le(self.total_number_messages)
        }
    }

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn message_number(&self) -> i32 {
        if self.is_out_of_bounds(88) {
            0i32
        } else {
            i32::from_le(self.message_number)
        }
    }

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn no_account_balances(&self) -> u8 {
        if self.is_out_of_bounds(89) {
            0u8
        } else {
            self.no_account_balances
        }
    }

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn unsolicited(&self) -> u8 {
        if self.is_out_of_bounds(90) {
            0u8
        } else {
            self.unsolicited
        }
    }

    fn open_positions_profit_loss(&self) -> f64 {
        if self.is_out_of_bounds(104) {
            0.0f64
        } else {
            f64_le(self.open_positions_profit_loss)
        }
    }

    fn daily_profit_loss(&self) -> f64 {
        if self.is_out_of_bounds(112) {
            0.0f64
        } else {
            f64_le(self.daily_profit_loss)
        }
    }

    fn info_text(&self) -> &str {
        if self.is_out_of_bounds(208) {
            ""
        } else {
            get_fixed(&self.info_text[..])
        }
    }

    fn transaction_identifier(&self) -> u64 {
        if self.is_out_of_bounds(216) {
            0u64
        } else {
            u64::from_le(self.transaction_identifier)
        }
    }

    fn daily_net_loss_limit(&self) -> f64 {
        if self.is_out_of_bounds(224) {
            0.0f64
        } else {
            f64_le(self.daily_net_loss_limit)
        }
    }

    fn trailing_account_value_to_limit_positions(&self) -> f64 {
        if self.is_out_of_bounds(232) {
            0.0f64
        } else {
            f64_le(self.trailing_account_value_to_limit_positions)
        }
    }

    fn daily_net_loss_limit_reached(&self) -> u8 {
        if self.is_out_of_bounds(233) {
            0
        } else {
            self.daily_net_loss_limit_reached
        }
    }

    fn is_under_required_margin(&self) -> bool {
        if self.is_out_of_bounds(234) {
            false
        } else {
            self.is_under_required_margin
        }
    }

    fn close_positions_at_end_of_day(&self) -> u8 {
        if self.is_out_of_bounds(235) {
            0
        } else {
            self.close_positions_at_end_of_day
        }
    }

    fn trading_is_disabled(&self) -> bool {
        if self.is_out_of_bounds(236) {
            false
        } else {
            self.trading_is_disabled
        }
    }

    fn description(&self) -> &str {
        if self.is_out_of_bounds(332) {
            ""
        } else {
            get_fixed(&self.description[..])
        }
    }

    fn is_under_required_account_value(&self) -> bool {
        if self.is_out_of_bounds(333) {
            false
        } else {
            self.is_under_required_account_value
        }
    }

    fn transaction_date_time(&self) -> DateTimeWithMicrosecondsInt {
        if self.is_out_of_bounds(344) {
            0i64.to_le()
        } else {
            i64::from_le(self.transaction_date_time)
        }
    }

    fn margin_requirement_full(&self) -> f64 {
        if self.is_out_of_bounds(352) {
            0.0
        } else {
            f64_le(self.margin_requirement_full)
        }
    }

    fn margin_requirement_full_positions_only(&self) -> f64 {
        if self.is_out_of_bounds(360) {
            0.0
        } else {
            f64_le(self.margin_requirement_full_positions_only)
        }
    }

    fn peak_margin_requirement(&self) -> f64 {
        if self.is_out_of_bounds(368) {
            0.0
        } else {
            f64_le(self.peak_margin_requirement)
        }
    }

    /// This is the RequestID which was set in the AccountBalanceRequestVLS that
    /// this message is in response to.
    ///
    /// In the case when this is a periodic unsolicited Account Balance update,
    /// RequestID must be set to 0, the default.
    fn set_request_id(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(8) {
            self.request_id = value.to_le();
        }
        self
    }

    /// The current cash balance for the account in the currency specified by
    /// the AccountCurrency field.
    fn set_cash_balance(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(16) {
            self.cash_balance = f64_le(value);
        }
        self
    }

    /// The CashBalance minus the cash required to maintain securities on margin
    /// the Trade Account currently has.
    fn set_balance_available_for_new_positions(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(24) {
            self.balance_available_for_new_positions = f64_le(value);
        }
        self
    }

    /// ISO Currency Code for the cash values in this message.
    fn set_account_currency(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(32) {
            set_fixed(&mut self.account_currency[..], value);
        }
        self
    }

    /// The trade account identifier for the Account Balance information.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(64) {
            set_fixed(&mut self.trade_account[..], value);
        }
        self
    }

    /// This is the value of all cash and securities as a cash value.
    fn set_securities_value(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(72) {
            self.securities_value = f64_le(value);
        }
        self
    }

    /// This is the current cash requirement to maintain securities on margin
    /// the Trade Account currently has.
    fn set_margin_requirement(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(80) {
            self.margin_requirement = f64_le(value);
        }
        self
    }

    /// This indicates the total number of Account Balance Update messages when
    /// a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_total_number_messages(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(84) {
            self.total_number_messages = value.to_le();
        }
        self
    }

    /// This indicates the 1-based index of the Account Balance Update message
    /// when a batch of messages is being sent. If there is only one Account Balance
    /// Update message being sent, this will be 1. Use a value of 1 for an unsolicited
    /// message.
    ///
    /// A Client should not rely on this field for an unsolicited message. This
    /// is required to be set.
    fn set_message_number(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(88) {
            self.message_number = value.to_le();
        }
        self
    }

    /// Set to an integer value of 1 to indicate there are no Account Balances
    /// in response to an AccountBalanceRequestVLS message.
    ///
    /// Otherwise, the Server must leave this at the default of 0.
    ///
    /// The Server is always expected to respond with a single AccountBalanceUpdateVLS
    /// message when there is no AccountBalanceUpdateVLS message for any Trade
    /// Account when the Account Balances have been requested by the Client with
    /// an AccountBalanceRequestVLS message.
    ///
    /// When the Server is sending an AccountBalanceUpdateVLS message to the Client
    /// and it is indicating that the balance related fields are all zero, then
    /// the NoAccountBalances field must be left at the default of 0. It is not
    /// used indicate the balance related fields are all zero.
    ///
    /// This is always set to the default of 0 for an unsolicited AccountBalanceUpdateVLS
    /// .
    fn set_no_account_balances(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(89) {
            self.no_account_balances = value;
        }
        self
    }

    /// Set to 1 to indicate this is an unsolicited Account Balance Update message.
    /// In other words, it is a real-time Account Balance Update message which
    /// is not an initial response to an AccountBalanceRequestVLS message.
    fn set_unsolicited(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(90) {
            self.unsolicited = value;
        }
        self
    }

    fn set_open_positions_profit_loss(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(104) {
            self.open_positions_profit_loss = f64_le(value);
        }
        self
    }

    fn set_daily_profit_loss(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(112) {
            self.daily_profit_loss = f64_le(value);
        }
        self
    }

    fn set_info_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(208) {
            set_fixed(&mut self.info_text[..], value);
        }
        self
    }

    fn set_transaction_identifier(&mut self, value: u64) -> &mut Self {
        if !self.is_out_of_bounds(216) {
            self.transaction_identifier = value.to_le();
        }
        self
    }

    fn set_daily_net_loss_limit(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(224) {
            self.daily_net_loss_limit = f64_le(value);
        }
        self
    }

    fn set_trailing_account_value_to_limit_positions(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(232) {
            self.trailing_account_value_to_limit_positions = f64_le(value);
        }
        self
    }

    fn set_daily_net_loss_limit_reached(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(233) {
            self.daily_net_loss_limit_reached = value;
        }
        self
    }

    fn set_is_under_required_margin(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(234) {
            self.is_under_required_margin = value;
        }
        self
    }

    fn set_close_positions_at_end_of_day(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(235) {
            self.close_positions_at_end_of_day = value;
        }
        self
    }

    fn set_trading_is_disabled(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(236) {
            self.trading_is_disabled = value;
        }
        self
    }

    fn set_description(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(332) {
            set_fixed(&mut self.description[..], value);
        }
        self
    }

    fn set_is_under_required_account_value(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(333) {
            self.is_under_required_account_value = value;
        }
        self
    }

    fn set_transaction_date_time(&mut self, value: DateTimeWithMicrosecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(344) {
            self.transaction_date_time = value.to_le();
        }
        self
    }

    fn set_margin_requirement_full(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(352) {
            self.margin_requirement_full = f64_le(value);
        }
        self
    }

    fn set_margin_requirement_full_positions_only(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(360) {
            self.margin_requirement_full_positions_only = f64_le(value);
        }
        self
    }

    fn set_peak_margin_requirement(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(368) {
            self.peak_margin_requirement = f64_le(value);
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    #[test]
    pub(crate) fn layout() {
        unsafe {
            assert_eq!(
                368usize,
                core::mem::size_of::<AccountBalanceUpdateFixedData>(),
                "AccountBalanceUpdateFixedData sizeof expected {:} but was {:}",
                368usize,
                core::mem::size_of::<AccountBalanceUpdateFixedData>()
            );
            assert_eq!(
                368u16,
                AccountBalanceUpdateFixed::new().size(),
                "AccountBalanceUpdateFixed sizeof expected {:} but was {:}",
                368u16,
                AccountBalanceUpdateFixed::new().size(),
            );
            assert_eq!(
                ACCOUNT_BALANCE_UPDATE,
                AccountBalanceUpdateFixed::new().r#type(),
                "AccountBalanceUpdateFixed type expected {:} but was {:}",
                ACCOUNT_BALANCE_UPDATE,
                AccountBalanceUpdateFixed::new().r#type(),
            );
            assert_eq!(
                600u16,
                AccountBalanceUpdateFixed::new().r#type(),
                "AccountBalanceUpdateFixed type expected {:} but was {:}",
                600u16,
                AccountBalanceUpdateFixed::new().r#type(),
            );
            let d = AccountBalanceUpdateFixedData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.request_id) as usize) - p,
                "request_id offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.request_id) as usize) - p,
            );
            assert_eq!(
                8usize,
                (core::ptr::addr_of!(d.cash_balance) as usize) - p,
                "cash_balance offset expected {:} but was {:}",
                8usize,
                (core::ptr::addr_of!(d.cash_balance) as usize) - p,
            );
            assert_eq!(
                16usize,
                (core::ptr::addr_of!(d.balance_available_for_new_positions) as usize) - p,
                "balance_available_for_new_positions offset expected {:} but was {:}",
                16usize,
                (core::ptr::addr_of!(d.balance_available_for_new_positions) as usize) - p,
            );
            assert_eq!(
                24usize,
                (core::ptr::addr_of!(d.account_currency) as usize) - p,
                "account_currency offset expected {:} but was {:}",
                24usize,
                (core::ptr::addr_of!(d.account_currency) as usize) - p,
            );
            assert_eq!(
                32usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
                "trade_account offset expected {:} but was {:}",
                32usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
            );
            assert_eq!(
                64usize,
                (core::ptr::addr_of!(d.securities_value) as usize) - p,
                "securities_value offset expected {:} but was {:}",
                64usize,
                (core::ptr::addr_of!(d.securities_value) as usize) - p,
            );
            assert_eq!(
                72usize,
                (core::ptr::addr_of!(d.margin_requirement) as usize) - p,
                "margin_requirement offset expected {:} but was {:}",
                72usize,
                (core::ptr::addr_of!(d.margin_requirement) as usize) - p,
            );
            assert_eq!(
                80usize,
                (core::ptr::addr_of!(d.total_number_messages) as usize) - p,
                "total_number_messages offset expected {:} but was {:}",
                80usize,
                (core::ptr::addr_of!(d.total_number_messages) as usize) - p,
            );
            assert_eq!(
                84usize,
                (core::ptr::addr_of!(d.message_number) as usize) - p,
                "message_number offset expected {:} but was {:}",
                84usize,
                (core::ptr::addr_of!(d.message_number) as usize) - p,
            );
            assert_eq!(
                88usize,
                (core::ptr::addr_of!(d.no_account_balances) as usize) - p,
                "no_account_balances offset expected {:} but was {:}",
                88usize,
                (core::ptr::addr_of!(d.no_account_balances) as usize) - p,
            );
            assert_eq!(
                89usize,
                (core::ptr::addr_of!(d.unsolicited) as usize) - p,
                "unsolicited offset expected {:} but was {:}",
                89usize,
                (core::ptr::addr_of!(d.unsolicited) as usize) - p,
            );
            assert_eq!(
                96usize,
                (core::ptr::addr_of!(d.open_positions_profit_loss) as usize) - p,
                "open_positions_profit_loss offset expected {:} but was {:}",
                96usize,
                (core::ptr::addr_of!(d.open_positions_profit_loss) as usize) - p,
            );
            assert_eq!(
                104usize,
                (core::ptr::addr_of!(d.daily_profit_loss) as usize) - p,
                "daily_profit_loss offset expected {:} but was {:}",
                104usize,
                (core::ptr::addr_of!(d.daily_profit_loss) as usize) - p,
            );
            assert_eq!(
                112usize,
                (core::ptr::addr_of!(d.info_text) as usize) - p,
                "info_text offset expected {:} but was {:}",
                112usize,
                (core::ptr::addr_of!(d.info_text) as usize) - p,
            );
            assert_eq!(
                208usize,
                (core::ptr::addr_of!(d.transaction_identifier) as usize) - p,
                "transaction_identifier offset expected {:} but was {:}",
                208usize,
                (core::ptr::addr_of!(d.transaction_identifier) as usize) - p,
            );
            assert_eq!(
                216usize,
                (core::ptr::addr_of!(d.daily_net_loss_limit) as usize) - p,
                "daily_net_loss_limit offset expected {:} but was {:}",
                216usize,
                (core::ptr::addr_of!(d.daily_net_loss_limit) as usize) - p,
            );
            assert_eq!(
                224usize,
                (core::ptr::addr_of!(d.trailing_account_value_to_limit_positions) as usize) - p,
                "trailing_account_value_to_limit_positions offset expected {:} but was {:}",
                224usize,
                (core::ptr::addr_of!(d.trailing_account_value_to_limit_positions) as usize) - p,
            );
            assert_eq!(
                232usize,
                (core::ptr::addr_of!(d.daily_net_loss_limit_reached) as usize) - p,
                "daily_net_loss_limit_reached offset expected {:} but was {:}",
                232usize,
                (core::ptr::addr_of!(d.daily_net_loss_limit_reached) as usize) - p,
            );
            assert_eq!(
                233usize,
                (core::ptr::addr_of!(d.is_under_required_margin) as usize) - p,
                "is_under_required_margin offset expected {:} but was {:}",
                233usize,
                (core::ptr::addr_of!(d.is_under_required_margin) as usize) - p,
            );
            assert_eq!(
                234usize,
                (core::ptr::addr_of!(d.close_positions_at_end_of_day) as usize) - p,
                "close_positions_at_end_of_day offset expected {:} but was {:}",
                234usize,
                (core::ptr::addr_of!(d.close_positions_at_end_of_day) as usize) - p,
            );
            assert_eq!(
                235usize,
                (core::ptr::addr_of!(d.trading_is_disabled) as usize) - p,
                "trading_is_disabled offset expected {:} but was {:}",
                235usize,
                (core::ptr::addr_of!(d.trading_is_disabled) as usize) - p,
            );
            assert_eq!(
                236usize,
                (core::ptr::addr_of!(d.description) as usize) - p,
                "description offset expected {:} but was {:}",
                236usize,
                (core::ptr::addr_of!(d.description) as usize) - p,
            );
            assert_eq!(
                332usize,
                (core::ptr::addr_of!(d.is_under_required_account_value) as usize) - p,
                "is_under_required_account_value offset expected {:} but was {:}",
                332usize,
                (core::ptr::addr_of!(d.is_under_required_account_value) as usize) - p,
            );
            assert_eq!(
                336usize,
                (core::ptr::addr_of!(d.transaction_date_time) as usize) - p,
                "transaction_date_time offset expected {:} but was {:}",
                336usize,
                (core::ptr::addr_of!(d.transaction_date_time) as usize) - p,
            );
            assert_eq!(
                344usize,
                (core::ptr::addr_of!(d.margin_requirement_full) as usize) - p,
                "margin_requirement_full offset expected {:} but was {:}",
                344usize,
                (core::ptr::addr_of!(d.margin_requirement_full) as usize) - p,
            );
            assert_eq!(
                352usize,
                (core::ptr::addr_of!(d.margin_requirement_full_positions_only) as usize) - p,
                "margin_requirement_full_positions_only offset expected {:} but was {:}",
                352usize,
                (core::ptr::addr_of!(d.margin_requirement_full_positions_only) as usize) - p,
            );
            assert_eq!(
                360usize,
                (core::ptr::addr_of!(d.peak_margin_requirement) as usize) - p,
                "peak_margin_requirement offset expected {:} but was {:}",
                360usize,
                (core::ptr::addr_of!(d.peak_margin_requirement) as usize) - p,
            );
        }
        unsafe {
            assert_eq!(
                168usize,
                core::mem::size_of::<AccountBalanceUpdateVLSData>(),
                "AccountBalanceUpdateVLSData sizeof expected {:} but was {:}",
                168usize,
                core::mem::size_of::<AccountBalanceUpdateVLSData>()
            );
            assert_eq!(
                168u16,
                AccountBalanceUpdateVLS::new().size(),
                "AccountBalanceUpdateVLS sizeof expected {:} but was {:}",
                168u16,
                AccountBalanceUpdateVLS::new().size(),
            );
            assert_eq!(
                ACCOUNT_BALANCE_UPDATE,
                AccountBalanceUpdateVLS::new().r#type(),
                "AccountBalanceUpdateVLS type expected {:} but was {:}",
                ACCOUNT_BALANCE_UPDATE,
                AccountBalanceUpdateVLS::new().r#type(),
            );
            assert_eq!(
                600u16,
                AccountBalanceUpdateVLS::new().r#type(),
                "AccountBalanceUpdateVLS type expected {:} but was {:}",
                600u16,
                AccountBalanceUpdateVLS::new().r#type(),
            );
            let d = AccountBalanceUpdateVLSData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
                "base_size offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
            );
            assert_eq!(
                8usize,
                (core::ptr::addr_of!(d.request_id) as usize) - p,
                "request_id offset expected {:} but was {:}",
                8usize,
                (core::ptr::addr_of!(d.request_id) as usize) - p,
            );
            assert_eq!(
                16usize,
                (core::ptr::addr_of!(d.cash_balance) as usize) - p,
                "cash_balance offset expected {:} but was {:}",
                16usize,
                (core::ptr::addr_of!(d.cash_balance) as usize) - p,
            );
            assert_eq!(
                24usize,
                (core::ptr::addr_of!(d.balance_available_for_new_positions) as usize) - p,
                "balance_available_for_new_positions offset expected {:} but was {:}",
                24usize,
                (core::ptr::addr_of!(d.balance_available_for_new_positions) as usize) - p,
            );
            assert_eq!(
                32usize,
                (core::ptr::addr_of!(d.account_currency) as usize) - p,
                "account_currency offset expected {:} but was {:}",
                32usize,
                (core::ptr::addr_of!(d.account_currency) as usize) - p,
            );
            assert_eq!(
                36usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
                "trade_account offset expected {:} but was {:}",
                36usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
            );
            assert_eq!(
                40usize,
                (core::ptr::addr_of!(d.securities_value) as usize) - p,
                "securities_value offset expected {:} but was {:}",
                40usize,
                (core::ptr::addr_of!(d.securities_value) as usize) - p,
            );
            assert_eq!(
                48usize,
                (core::ptr::addr_of!(d.margin_requirement) as usize) - p,
                "margin_requirement offset expected {:} but was {:}",
                48usize,
                (core::ptr::addr_of!(d.margin_requirement) as usize) - p,
            );
            assert_eq!(
                56usize,
                (core::ptr::addr_of!(d.total_number_messages) as usize) - p,
                "total_number_messages offset expected {:} but was {:}",
                56usize,
                (core::ptr::addr_of!(d.total_number_messages) as usize) - p,
            );
            assert_eq!(
                60usize,
                (core::ptr::addr_of!(d.message_number) as usize) - p,
                "message_number offset expected {:} but was {:}",
                60usize,
                (core::ptr::addr_of!(d.message_number) as usize) - p,
            );
            assert_eq!(
                64usize,
                (core::ptr::addr_of!(d.no_account_balances) as usize) - p,
                "no_account_balances offset expected {:} but was {:}",
                64usize,
                (core::ptr::addr_of!(d.no_account_balances) as usize) - p,
            );
            assert_eq!(
                65usize,
                (core::ptr::addr_of!(d.unsolicited) as usize) - p,
                "unsolicited offset expected {:} but was {:}",
                65usize,
                (core::ptr::addr_of!(d.unsolicited) as usize) - p,
            );
            assert_eq!(
                72usize,
                (core::ptr::addr_of!(d.open_positions_profit_loss) as usize) - p,
                "open_positions_profit_loss offset expected {:} but was {:}",
                72usize,
                (core::ptr::addr_of!(d.open_positions_profit_loss) as usize) - p,
            );
            assert_eq!(
                80usize,
                (core::ptr::addr_of!(d.daily_profit_loss) as usize) - p,
                "daily_profit_loss offset expected {:} but was {:}",
                80usize,
                (core::ptr::addr_of!(d.daily_profit_loss) as usize) - p,
            );
            assert_eq!(
                88usize,
                (core::ptr::addr_of!(d.info_text) as usize) - p,
                "info_text offset expected {:} but was {:}",
                88usize,
                (core::ptr::addr_of!(d.info_text) as usize) - p,
            );
            assert_eq!(
                96usize,
                (core::ptr::addr_of!(d.transaction_identifier) as usize) - p,
                "transaction_identifier offset expected {:} but was {:}",
                96usize,
                (core::ptr::addr_of!(d.transaction_identifier) as usize) - p,
            );
            assert_eq!(
                104usize,
                (core::ptr::addr_of!(d.daily_net_loss_limit) as usize) - p,
                "daily_net_loss_limit offset expected {:} but was {:}",
                104usize,
                (core::ptr::addr_of!(d.daily_net_loss_limit) as usize) - p,
            );
            assert_eq!(
                112usize,
                (core::ptr::addr_of!(d.trailing_account_value_to_limit_positions) as usize) - p,
                "trailing_account_value_to_limit_positions offset expected {:} but was {:}",
                112usize,
                (core::ptr::addr_of!(d.trailing_account_value_to_limit_positions) as usize) - p,
            );
            assert_eq!(
                120usize,
                (core::ptr::addr_of!(d.daily_net_loss_limit_reached) as usize) - p,
                "daily_net_loss_limit_reached offset expected {:} but was {:}",
                120usize,
                (core::ptr::addr_of!(d.daily_net_loss_limit_reached) as usize) - p,
            );
            assert_eq!(
                121usize,
                (core::ptr::addr_of!(d.is_under_required_margin) as usize) - p,
                "is_under_required_margin offset expected {:} but was {:}",
                121usize,
                (core::ptr::addr_of!(d.is_under_required_margin) as usize) - p,
            );
            assert_eq!(
                122usize,
                (core::ptr::addr_of!(d.close_positions_at_end_of_day) as usize) - p,
                "close_positions_at_end_of_day offset expected {:} but was {:}",
                122usize,
                (core::ptr::addr_of!(d.close_positions_at_end_of_day) as usize) - p,
            );
            assert_eq!(
                123usize,
                (core::ptr::addr_of!(d.trading_is_disabled) as usize) - p,
                "trading_is_disabled offset expected {:} but was {:}",
                123usize,
                (core::ptr::addr_of!(d.trading_is_disabled) as usize) - p,
            );
            assert_eq!(
                124usize,
                (core::ptr::addr_of!(d.description) as usize) - p,
                "description offset expected {:} but was {:}",
                124usize,
                (core::ptr::addr_of!(d.description) as usize) - p,
            );
            assert_eq!(
                128usize,
                (core::ptr::addr_of!(d.is_under_required_account_value) as usize) - p,
                "is_under_required_account_value offset expected {:} but was {:}",
                128usize,
                (core::ptr::addr_of!(d.is_under_required_account_value) as usize) - p,
            );
            assert_eq!(
                136usize,
                (core::ptr::addr_of!(d.transaction_date_time) as usize) - p,
                "transaction_date_time offset expected {:} but was {:}",
                136usize,
                (core::ptr::addr_of!(d.transaction_date_time) as usize) - p,
            );
            assert_eq!(
                144usize,
                (core::ptr::addr_of!(d.margin_requirement_full) as usize) - p,
                "margin_requirement_full offset expected {:} but was {:}",
                144usize,
                (core::ptr::addr_of!(d.margin_requirement_full) as usize) - p,
            );
            assert_eq!(
                152usize,
                (core::ptr::addr_of!(d.margin_requirement_full_positions_only) as usize) - p,
                "margin_requirement_full_positions_only offset expected {:} but was {:}",
                152usize,
                (core::ptr::addr_of!(d.margin_requirement_full_positions_only) as usize) - p,
            );
            assert_eq!(
                160usize,
                (core::ptr::addr_of!(d.peak_margin_requirement) as usize) - p,
                "peak_margin_requirement offset expected {:} but was {:}",
                160usize,
                (core::ptr::addr_of!(d.peak_margin_requirement) as usize) - p,
            );
        }
    }
}
