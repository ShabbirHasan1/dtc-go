// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-25 15:25:42.126453 +0800 WITA m=+0.007296918
use super::*;

pub(crate) const REPLAY_CHART_DATA_VLS_SIZE: usize = 88;

pub(crate) const REPLAY_CHART_DATA_FIXED_SIZE: usize = 426;

/// size                                                              u16                          = ReplayChartDataVLSSize  (88)
/// type                                                              u16                          = REPLAY_CHART_DATA  (10104)
/// base_size                                                         u16                          = ReplayChartDataVLSSize  (88)
/// request_id                                                        u32                          = 0
/// symbol                                                            string                       = ""
/// trade_account                                                     string                       = ""
/// time_zone                                                         string                       = ""
/// start_date_time_for_initial_data                                  DateTimeWithMillisecondsInt  = 0
/// start_date_time                                                   DateTimeWithMillisecondsInt  = 0
/// stop_date_time                                                    DateTimeWithMillisecondsInt  = 0
/// session_begin_time_in_seconds                                     u16                          = 0
/// session_end_time_in_seconds                                       u16                          = 0
/// replay_speed                                                      f32                          = 1.000000
/// bar_time_in_seconds                                               i32                          = 0
/// pause_replay_after_initial_data_sent                              u8                           = 0
/// use_saved_prior_state                                             bool                         = false
/// symbol_volatility                                                 f32                          = 0
/// interest_rate                                                     f32                          = 0
/// number_of_orders_to_trigger_finish_to_stop_date_time              i32                          = 0
/// maximum_number_of_orders_per_replay_session                       i32                          = 0
/// number_of_days_for_initial_data_from_before_last_saved_date_time  i32                          = 0
/// sub_account_identifier                                            u32                          = 0
/// options_price_send_interval_in_seconds                            i32                          = 0
pub(crate) const REPLAY_CHART_DATA_VLS_DEFAULT: [u8; 88] = [
    88, 0, 120, 39, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/// size                                                              u16                          = ReplayChartDataFixedSize  (426)
/// type                                                              u16                          = REPLAY_CHART_DATA  (10104)
/// request_id                                                        u32                          = 0
/// symbol                                                            string64                     = ""
/// trade_account                                                     string32                     = ""
/// time_zone                                                         string256                    = ""
/// start_date_time_for_initial_data                                  DateTimeWithMillisecondsInt  = 0
/// start_date_time                                                   DateTimeWithMillisecondsInt  = 0
/// stop_date_time                                                    DateTimeWithMillisecondsInt  = 0
/// session_begin_time_in_seconds                                     u16                          = 0
/// session_end_time_in_seconds                                       u16                          = 0
/// replay_speed                                                      f32                          = 1.000000
/// bar_time_in_seconds                                               i32                          = 0
/// pause_replay_after_initial_data_sent                              u8                           = 0
/// use_saved_prior_state                                             bool                         = false
/// symbol_volatility                                                 f32                          = 0
/// interest_rate                                                     f32                          = 0
/// number_of_orders_to_trigger_finish_to_stop_date_time              i32                          = 0
/// maximum_number_of_orders_per_replay_session                       i32                          = 0
/// number_of_days_for_initial_data_from_before_last_saved_date_time  i32                          = 0
/// sub_account_identifier                                            u32                          = 0
/// options_price_send_interval_in_seconds                            i32                          = 0
pub(crate) const REPLAY_CHART_DATA_FIXED_DEFAULT: [u8; 426] = [
    170, 1, 120, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

pub trait ReplayChartData: Message {
    type Safe: ReplayChartData;
    type Unsafe: ReplayChartData;

    fn request_id(&self) -> u32;

    fn symbol(&self) -> &str;

    fn trade_account(&self) -> &str;

    fn time_zone(&self) -> &str;

    fn start_date_time_for_initial_data(&self) -> DateTimeWithMillisecondsInt;

    fn start_date_time(&self) -> DateTimeWithMillisecondsInt;

    fn stop_date_time(&self) -> DateTimeWithMillisecondsInt;

    fn session_begin_time_in_seconds(&self) -> u16;

    fn session_end_time_in_seconds(&self) -> u16;

    fn replay_speed(&self) -> f32;

    fn bar_time_in_seconds(&self) -> i32;

    fn pause_replay_after_initial_data_sent(&self) -> u8;

    fn use_saved_prior_state(&self) -> bool;

    fn symbol_volatility(&self) -> f32;

    fn interest_rate(&self) -> f32;

    fn number_of_orders_to_trigger_finish_to_stop_date_time(&self) -> i32;

    fn maximum_number_of_orders_per_replay_session(&self) -> i32;

    fn number_of_days_for_initial_data_from_before_last_saved_date_time(&self) -> i32;

    fn sub_account_identifier(&self) -> u32;

    fn options_price_send_interval_in_seconds(&self) -> i32;

    fn set_request_id(&mut self, value: u32) -> &mut Self;

    fn set_symbol(&mut self, value: &str) -> &mut Self;

    fn set_trade_account(&mut self, value: &str) -> &mut Self;

    fn set_time_zone(&mut self, value: &str) -> &mut Self;

    fn set_start_date_time_for_initial_data(
        &mut self,
        value: DateTimeWithMillisecondsInt,
    ) -> &mut Self;

    fn set_start_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self;

    fn set_stop_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self;

    fn set_session_begin_time_in_seconds(&mut self, value: u16) -> &mut Self;

    fn set_session_end_time_in_seconds(&mut self, value: u16) -> &mut Self;

    fn set_replay_speed(&mut self, value: f32) -> &mut Self;

    fn set_bar_time_in_seconds(&mut self, value: i32) -> &mut Self;

    fn set_pause_replay_after_initial_data_sent(&mut self, value: u8) -> &mut Self;

    fn set_use_saved_prior_state(&mut self, value: bool) -> &mut Self;

    fn set_symbol_volatility(&mut self, value: f32) -> &mut Self;

    fn set_interest_rate(&mut self, value: f32) -> &mut Self;

    fn set_number_of_orders_to_trigger_finish_to_stop_date_time(&mut self, value: i32)
        -> &mut Self;

    fn set_maximum_number_of_orders_per_replay_session(&mut self, value: i32) -> &mut Self;

    fn set_number_of_days_for_initial_data_from_before_last_saved_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self;

    fn set_sub_account_identifier(&mut self, value: u32) -> &mut Self;

    fn set_options_price_send_interval_in_seconds(&mut self, value: i32) -> &mut Self;

    fn clone_safe(&self) -> Self::Safe;

    fn to_safe(self) -> Self::Safe;

    fn copy_to(&self, to: &mut impl ReplayChartData) {
        to.set_request_id(self.request_id());
        to.set_symbol(self.symbol());
        to.set_trade_account(self.trade_account());
        to.set_time_zone(self.time_zone());
        to.set_start_date_time_for_initial_data(self.start_date_time_for_initial_data());
        to.set_start_date_time(self.start_date_time());
        to.set_stop_date_time(self.stop_date_time());
        to.set_session_begin_time_in_seconds(self.session_begin_time_in_seconds());
        to.set_session_end_time_in_seconds(self.session_end_time_in_seconds());
        to.set_replay_speed(self.replay_speed());
        to.set_bar_time_in_seconds(self.bar_time_in_seconds());
        to.set_pause_replay_after_initial_data_sent(self.pause_replay_after_initial_data_sent());
        to.set_use_saved_prior_state(self.use_saved_prior_state());
        to.set_symbol_volatility(self.symbol_volatility());
        to.set_interest_rate(self.interest_rate());
        to.set_number_of_orders_to_trigger_finish_to_stop_date_time(
            self.number_of_orders_to_trigger_finish_to_stop_date_time(),
        );
        to.set_maximum_number_of_orders_per_replay_session(
            self.maximum_number_of_orders_per_replay_session(),
        );
        to.set_number_of_days_for_initial_data_from_before_last_saved_date_time(
            self.number_of_days_for_initial_data_from_before_last_saved_date_time(),
        );
        to.set_sub_account_identifier(self.sub_account_identifier());
        to.set_options_price_send_interval_in_seconds(
            self.options_price_send_interval_in_seconds(),
        );
    }
}

pub struct ReplayChartDataVLS {
    data: *const ReplayChartDataVLSData,
    capacity: usize,
}

pub struct ReplayChartDataVLSUnsafe {
    data: *const ReplayChartDataVLSData,
    capacity: usize,
}

#[repr(packed(1), C)]
pub struct ReplayChartDataVLSData {
    size: u16,
    r#type: u16,
    base_size: u16,
    request_id: u32,
    symbol: VLS,
    trade_account: VLS,
    time_zone: VLS,
    start_date_time_for_initial_data: DateTimeWithMillisecondsInt,
    start_date_time: DateTimeWithMillisecondsInt,
    stop_date_time: DateTimeWithMillisecondsInt,
    session_begin_time_in_seconds: u16,
    session_end_time_in_seconds: u16,
    replay_speed: f32,
    bar_time_in_seconds: i32,
    pause_replay_after_initial_data_sent: u8,
    use_saved_prior_state: bool,
    symbol_volatility: f32,
    interest_rate: f32,
    number_of_orders_to_trigger_finish_to_stop_date_time: i32,
    maximum_number_of_orders_per_replay_session: i32,
    number_of_days_for_initial_data_from_before_last_saved_date_time: i32,
    sub_account_identifier: u32,
    options_price_send_interval_in_seconds: i32,
}

pub struct ReplayChartDataFixed {
    data: *const ReplayChartDataFixedData,
}

pub struct ReplayChartDataFixedUnsafe {
    data: *const ReplayChartDataFixedData,
}

#[repr(packed(1), C)]
pub struct ReplayChartDataFixedData {
    size: u16,
    r#type: u16,
    request_id: u32,
    symbol: [u8; 64],
    trade_account: [u8; 32],
    time_zone: [u8; 256],
    start_date_time_for_initial_data: DateTimeWithMillisecondsInt,
    start_date_time: DateTimeWithMillisecondsInt,
    stop_date_time: DateTimeWithMillisecondsInt,
    session_begin_time_in_seconds: u16,
    session_end_time_in_seconds: u16,
    replay_speed: f32,
    bar_time_in_seconds: i32,
    pause_replay_after_initial_data_sent: u8,
    use_saved_prior_state: bool,
    symbol_volatility: f32,
    interest_rate: f32,
    number_of_orders_to_trigger_finish_to_stop_date_time: i32,
    maximum_number_of_orders_per_replay_session: i32,
    number_of_days_for_initial_data_from_before_last_saved_date_time: i32,
    sub_account_identifier: u32,
    options_price_send_interval_in_seconds: i32,
}

impl ReplayChartDataVLSData {
    pub fn new() -> Self {
        Self {
            size: 88u16.to_le(),
            r#type: REPLAY_CHART_DATA.to_le(),
            base_size: 88u16.to_le(),
            request_id: 0u32,
            symbol: crate::message::VLS::new(),
            trade_account: crate::message::VLS::new(),
            time_zone: crate::message::VLS::new(),
            start_date_time_for_initial_data: 0i64,
            start_date_time: 0i64,
            stop_date_time: 0i64,
            session_begin_time_in_seconds: 0u16,
            session_end_time_in_seconds: 0u16,
            replay_speed: 1.0,
            bar_time_in_seconds: 0i32,
            pause_replay_after_initial_data_sent: 0u8,
            use_saved_prior_state: false,
            symbol_volatility: 0.0f32,
            interest_rate: 0.0f32,
            number_of_orders_to_trigger_finish_to_stop_date_time: 0i32,
            maximum_number_of_orders_per_replay_session: 0i32,
            number_of_days_for_initial_data_from_before_last_saved_date_time: 0i32,
            sub_account_identifier: 0u32.to_le(),
            options_price_send_interval_in_seconds: 0i32.to_le(),
        }
    }
}

impl ReplayChartDataFixedData {
    pub fn new() -> Self {
        Self {
            size: 426u16.to_le(),
            r#type: REPLAY_CHART_DATA.to_le(),
            request_id: 0u32,
            symbol: [0; 64],
            trade_account: [0; 32],
            time_zone: [0; 256],
            start_date_time_for_initial_data: 0i64,
            start_date_time: 0i64,
            stop_date_time: 0i64,
            session_begin_time_in_seconds: 0u16,
            session_end_time_in_seconds: 0u16,
            replay_speed: 1.0,
            bar_time_in_seconds: 0i32,
            pause_replay_after_initial_data_sent: 0u8,
            use_saved_prior_state: false,
            symbol_volatility: 0.0f32,
            interest_rate: 0.0f32,
            number_of_orders_to_trigger_finish_to_stop_date_time: 0i32,
            maximum_number_of_orders_per_replay_session: 0i32,
            number_of_days_for_initial_data_from_before_last_saved_date_time: 0i32,
            sub_account_identifier: 0u32.to_le(),
            options_price_send_interval_in_seconds: 0i32.to_le(),
        }
    }
}

unsafe impl Send for ReplayChartDataFixed {}
unsafe impl Send for ReplayChartDataFixedUnsafe {}
unsafe impl Send for ReplayChartDataFixedData {}
unsafe impl Send for ReplayChartDataVLS {}
unsafe impl Send for ReplayChartDataVLSUnsafe {}
unsafe impl Send for ReplayChartDataVLSData {}

impl Drop for ReplayChartDataFixed {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for ReplayChartDataFixedUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for ReplayChartDataVLS {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for ReplayChartDataVLSUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Clone for ReplayChartDataFixed {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for ReplayChartDataFixedUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for ReplayChartDataVLS {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for ReplayChartDataVLSUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Into<Vec<u8>> for ReplayChartDataFixed {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for ReplayChartDataFixedUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for ReplayChartDataVLS {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for ReplayChartDataVLSUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl core::ops::Deref for ReplayChartDataFixed {
    type Target = ReplayChartDataFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for ReplayChartDataFixed {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for ReplayChartDataFixedUnsafe {
    type Target = ReplayChartDataFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for ReplayChartDataFixedUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for ReplayChartDataVLS {
    type Target = ReplayChartDataVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for ReplayChartDataVLS {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for ReplayChartDataVLSUnsafe {
    type Target = ReplayChartDataVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for ReplayChartDataVLSUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl crate::Message for ReplayChartDataFixed {
    type Data = ReplayChartDataFixedData;

    const BASE_SIZE: usize = 426;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, ReplayChartDataFixedData::new()),
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const ReplayChartDataFixedData,
        }
    }
}
impl crate::Message for ReplayChartDataFixedUnsafe {
    type Data = ReplayChartDataFixedData;

    const BASE_SIZE: usize = 426;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, ReplayChartDataFixedData::new()),
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const ReplayChartDataFixedData,
        }
    }
}
impl crate::Message for ReplayChartDataVLS {
    type Data = ReplayChartDataVLSData;

    const BASE_SIZE: usize = 88;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, ReplayChartDataVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const ReplayChartDataVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for ReplayChartDataVLS {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const ReplayChartDataVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl crate::Message for ReplayChartDataVLSUnsafe {
    type Data = ReplayChartDataVLSData;

    const BASE_SIZE: usize = 88;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, ReplayChartDataVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const ReplayChartDataVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for ReplayChartDataVLSUnsafe {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const ReplayChartDataVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl ReplayChartData for ReplayChartDataVLS {
    type Safe = ReplayChartDataVLS;
    type Unsafe = ReplayChartDataVLSUnsafe;

    fn request_id(&self) -> u32 {
        u32::from_le(self.request_id)
    }

    fn symbol(&self) -> &str {
        get_vls(self, self.symbol)
    }

    fn trade_account(&self) -> &str {
        get_vls(self, self.trade_account)
    }

    fn time_zone(&self) -> &str {
        get_vls(self, self.time_zone)
    }

    fn start_date_time_for_initial_data(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.start_date_time_for_initial_data)
    }

    fn start_date_time(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.start_date_time)
    }

    fn stop_date_time(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.stop_date_time)
    }

    fn session_begin_time_in_seconds(&self) -> u16 {
        u16::from_le(self.session_begin_time_in_seconds)
    }

    fn session_end_time_in_seconds(&self) -> u16 {
        u16::from_le(self.session_end_time_in_seconds)
    }

    fn replay_speed(&self) -> f32 {
        f32_le(self.replay_speed)
    }

    fn bar_time_in_seconds(&self) -> i32 {
        i32::from_le(self.bar_time_in_seconds)
    }

    fn pause_replay_after_initial_data_sent(&self) -> u8 {
        self.pause_replay_after_initial_data_sent
    }

    fn use_saved_prior_state(&self) -> bool {
        self.use_saved_prior_state
    }

    fn symbol_volatility(&self) -> f32 {
        f32_le(self.symbol_volatility)
    }

    fn interest_rate(&self) -> f32 {
        f32_le(self.interest_rate)
    }

    fn number_of_orders_to_trigger_finish_to_stop_date_time(&self) -> i32 {
        i32::from_le(self.number_of_orders_to_trigger_finish_to_stop_date_time)
    }

    fn maximum_number_of_orders_per_replay_session(&self) -> i32 {
        i32::from_le(self.maximum_number_of_orders_per_replay_session)
    }

    fn number_of_days_for_initial_data_from_before_last_saved_date_time(&self) -> i32 {
        i32::from_le(self.number_of_days_for_initial_data_from_before_last_saved_date_time)
    }

    fn sub_account_identifier(&self) -> u32 {
        u32::from_le(self.sub_account_identifier)
    }

    fn options_price_send_interval_in_seconds(&self) -> i32 {
        i32::from_le(self.options_price_send_interval_in_seconds)
    }

    fn set_request_id(&mut self, value: u32) -> &mut Self {
        self.request_id = value.to_le();
        self
    }

    fn set_symbol(&mut self, value: &str) -> &mut Self {
        self.symbol = set_vls(self, self.symbol, value);
        self
    }

    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        self.trade_account = set_vls(self, self.trade_account, value);
        self
    }

    fn set_time_zone(&mut self, value: &str) -> &mut Self {
        self.time_zone = set_vls(self, self.time_zone, value);
        self
    }

    fn set_start_date_time_for_initial_data(
        &mut self,
        value: DateTimeWithMillisecondsInt,
    ) -> &mut Self {
        self.start_date_time_for_initial_data = value.to_le();
        self
    }

    fn set_start_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        self.start_date_time = value.to_le();
        self
    }

    fn set_stop_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        self.stop_date_time = value.to_le();
        self
    }

    fn set_session_begin_time_in_seconds(&mut self, value: u16) -> &mut Self {
        self.session_begin_time_in_seconds = value.to_le();
        self
    }

    fn set_session_end_time_in_seconds(&mut self, value: u16) -> &mut Self {
        self.session_end_time_in_seconds = value.to_le();
        self
    }

    fn set_replay_speed(&mut self, value: f32) -> &mut Self {
        self.replay_speed = f32_le(value);
        self
    }

    fn set_bar_time_in_seconds(&mut self, value: i32) -> &mut Self {
        self.bar_time_in_seconds = value.to_le();
        self
    }

    fn set_pause_replay_after_initial_data_sent(&mut self, value: u8) -> &mut Self {
        self.pause_replay_after_initial_data_sent = value;
        self
    }

    fn set_use_saved_prior_state(&mut self, value: bool) -> &mut Self {
        self.use_saved_prior_state = value;
        self
    }

    fn set_symbol_volatility(&mut self, value: f32) -> &mut Self {
        self.symbol_volatility = f32_le(value);
        self
    }

    fn set_interest_rate(&mut self, value: f32) -> &mut Self {
        self.interest_rate = f32_le(value);
        self
    }

    fn set_number_of_orders_to_trigger_finish_to_stop_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self {
        self.number_of_orders_to_trigger_finish_to_stop_date_time = value.to_le();
        self
    }

    fn set_maximum_number_of_orders_per_replay_session(&mut self, value: i32) -> &mut Self {
        self.maximum_number_of_orders_per_replay_session = value.to_le();
        self
    }

    fn set_number_of_days_for_initial_data_from_before_last_saved_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self {
        self.number_of_days_for_initial_data_from_before_last_saved_date_time = value.to_le();
        self
    }

    fn set_sub_account_identifier(&mut self, value: u32) -> &mut Self {
        self.sub_account_identifier = value.to_le();
        self
    }

    fn set_options_price_send_interval_in_seconds(&mut self, value: i32) -> &mut Self {
        self.options_price_send_interval_in_seconds = value.to_le();
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

impl ReplayChartData for ReplayChartDataVLSUnsafe {
    type Safe = ReplayChartDataVLS;
    type Unsafe = ReplayChartDataVLSUnsafe;

    fn request_id(&self) -> u32 {
        if self.is_out_of_bounds(10) {
            0u32
        } else {
            u32::from_le(self.request_id)
        }
    }

    fn symbol(&self) -> &str {
        if self.is_out_of_bounds(14) {
            ""
        } else {
            get_vls(self, self.symbol)
        }
    }

    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(18) {
            ""
        } else {
            get_vls(self, self.trade_account)
        }
    }

    fn time_zone(&self) -> &str {
        if self.is_out_of_bounds(22) {
            ""
        } else {
            get_vls(self, self.time_zone)
        }
    }

    fn start_date_time_for_initial_data(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(30) {
            0i64
        } else {
            i64::from_le(self.start_date_time_for_initial_data)
        }
    }

    fn start_date_time(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(38) {
            0i64
        } else {
            i64::from_le(self.start_date_time)
        }
    }

    fn stop_date_time(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(46) {
            0i64
        } else {
            i64::from_le(self.stop_date_time)
        }
    }

    fn session_begin_time_in_seconds(&self) -> u16 {
        if self.is_out_of_bounds(48) {
            0u16
        } else {
            u16::from_le(self.session_begin_time_in_seconds)
        }
    }

    fn session_end_time_in_seconds(&self) -> u16 {
        if self.is_out_of_bounds(50) {
            0u16
        } else {
            u16::from_le(self.session_end_time_in_seconds)
        }
    }

    fn replay_speed(&self) -> f32 {
        if self.is_out_of_bounds(54) {
            1.0
        } else {
            f32_le(self.replay_speed)
        }
    }

    fn bar_time_in_seconds(&self) -> i32 {
        if self.is_out_of_bounds(58) {
            0i32
        } else {
            i32::from_le(self.bar_time_in_seconds)
        }
    }

    fn pause_replay_after_initial_data_sent(&self) -> u8 {
        if self.is_out_of_bounds(59) {
            0u8
        } else {
            self.pause_replay_after_initial_data_sent
        }
    }

    fn use_saved_prior_state(&self) -> bool {
        if self.is_out_of_bounds(60) {
            false
        } else {
            self.use_saved_prior_state
        }
    }

    fn symbol_volatility(&self) -> f32 {
        if self.is_out_of_bounds(64) {
            0.0f32
        } else {
            f32_le(self.symbol_volatility)
        }
    }

    fn interest_rate(&self) -> f32 {
        if self.is_out_of_bounds(68) {
            0.0f32
        } else {
            f32_le(self.interest_rate)
        }
    }

    fn number_of_orders_to_trigger_finish_to_stop_date_time(&self) -> i32 {
        if self.is_out_of_bounds(72) {
            0i32
        } else {
            i32::from_le(self.number_of_orders_to_trigger_finish_to_stop_date_time)
        }
    }

    fn maximum_number_of_orders_per_replay_session(&self) -> i32 {
        if self.is_out_of_bounds(76) {
            0i32
        } else {
            i32::from_le(self.maximum_number_of_orders_per_replay_session)
        }
    }

    fn number_of_days_for_initial_data_from_before_last_saved_date_time(&self) -> i32 {
        if self.is_out_of_bounds(80) {
            0i32
        } else {
            i32::from_le(self.number_of_days_for_initial_data_from_before_last_saved_date_time)
        }
    }

    fn sub_account_identifier(&self) -> u32 {
        if self.is_out_of_bounds(84) {
            0u32.to_le()
        } else {
            u32::from_le(self.sub_account_identifier)
        }
    }

    fn options_price_send_interval_in_seconds(&self) -> i32 {
        if self.is_out_of_bounds(88) {
            0i32.to_le()
        } else {
            i32::from_le(self.options_price_send_interval_in_seconds)
        }
    }

    fn set_request_id(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(10) {
            self.request_id = value.to_le();
        }
        self
    }

    fn set_symbol(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(14) {
            self.symbol = set_vls(self, self.symbol, value);
        }
        self
    }

    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(18) {
            self.trade_account = set_vls(self, self.trade_account, value);
        }
        self
    }

    fn set_time_zone(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(22) {
            self.time_zone = set_vls(self, self.time_zone, value);
        }
        self
    }

    fn set_start_date_time_for_initial_data(
        &mut self,
        value: DateTimeWithMillisecondsInt,
    ) -> &mut Self {
        if !self.is_out_of_bounds(30) {
            self.start_date_time_for_initial_data = value.to_le();
        }
        self
    }

    fn set_start_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(38) {
            self.start_date_time = value.to_le();
        }
        self
    }

    fn set_stop_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(46) {
            self.stop_date_time = value.to_le();
        }
        self
    }

    fn set_session_begin_time_in_seconds(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(48) {
            self.session_begin_time_in_seconds = value.to_le();
        }
        self
    }

    fn set_session_end_time_in_seconds(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(50) {
            self.session_end_time_in_seconds = value.to_le();
        }
        self
    }

    fn set_replay_speed(&mut self, value: f32) -> &mut Self {
        if !self.is_out_of_bounds(54) {
            self.replay_speed = f32_le(value);
        }
        self
    }

    fn set_bar_time_in_seconds(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(58) {
            self.bar_time_in_seconds = value.to_le();
        }
        self
    }

    fn set_pause_replay_after_initial_data_sent(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(59) {
            self.pause_replay_after_initial_data_sent = value;
        }
        self
    }

    fn set_use_saved_prior_state(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(60) {
            self.use_saved_prior_state = value;
        }
        self
    }

    fn set_symbol_volatility(&mut self, value: f32) -> &mut Self {
        if !self.is_out_of_bounds(64) {
            self.symbol_volatility = f32_le(value);
        }
        self
    }

    fn set_interest_rate(&mut self, value: f32) -> &mut Self {
        if !self.is_out_of_bounds(68) {
            self.interest_rate = f32_le(value);
        }
        self
    }

    fn set_number_of_orders_to_trigger_finish_to_stop_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self {
        if !self.is_out_of_bounds(72) {
            self.number_of_orders_to_trigger_finish_to_stop_date_time = value.to_le();
        }
        self
    }

    fn set_maximum_number_of_orders_per_replay_session(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(76) {
            self.maximum_number_of_orders_per_replay_session = value.to_le();
        }
        self
    }

    fn set_number_of_days_for_initial_data_from_before_last_saved_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self {
        if !self.is_out_of_bounds(80) {
            self.number_of_days_for_initial_data_from_before_last_saved_date_time = value.to_le();
        }
        self
    }

    fn set_sub_account_identifier(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(84) {
            self.sub_account_identifier = value.to_le();
        }
        self
    }

    fn set_options_price_send_interval_in_seconds(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(88) {
            self.options_price_send_interval_in_seconds = value.to_le();
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

impl ReplayChartData for ReplayChartDataFixed {
    type Safe = ReplayChartDataFixed;
    type Unsafe = ReplayChartDataFixedUnsafe;

    fn request_id(&self) -> u32 {
        u32::from_le(self.request_id)
    }

    fn symbol(&self) -> &str {
        get_fixed(&self.symbol[..])
    }

    fn trade_account(&self) -> &str {
        get_fixed(&self.trade_account[..])
    }

    fn time_zone(&self) -> &str {
        get_fixed(&self.time_zone[..])
    }

    fn start_date_time_for_initial_data(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.start_date_time_for_initial_data)
    }

    fn start_date_time(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.start_date_time)
    }

    fn stop_date_time(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.stop_date_time)
    }

    fn session_begin_time_in_seconds(&self) -> u16 {
        u16::from_le(self.session_begin_time_in_seconds)
    }

    fn session_end_time_in_seconds(&self) -> u16 {
        u16::from_le(self.session_end_time_in_seconds)
    }

    fn replay_speed(&self) -> f32 {
        f32_le(self.replay_speed)
    }

    fn bar_time_in_seconds(&self) -> i32 {
        i32::from_le(self.bar_time_in_seconds)
    }

    fn pause_replay_after_initial_data_sent(&self) -> u8 {
        self.pause_replay_after_initial_data_sent
    }

    fn use_saved_prior_state(&self) -> bool {
        self.use_saved_prior_state
    }

    fn symbol_volatility(&self) -> f32 {
        f32_le(self.symbol_volatility)
    }

    fn interest_rate(&self) -> f32 {
        f32_le(self.interest_rate)
    }

    fn number_of_orders_to_trigger_finish_to_stop_date_time(&self) -> i32 {
        i32::from_le(self.number_of_orders_to_trigger_finish_to_stop_date_time)
    }

    fn maximum_number_of_orders_per_replay_session(&self) -> i32 {
        i32::from_le(self.maximum_number_of_orders_per_replay_session)
    }

    fn number_of_days_for_initial_data_from_before_last_saved_date_time(&self) -> i32 {
        i32::from_le(self.number_of_days_for_initial_data_from_before_last_saved_date_time)
    }

    fn sub_account_identifier(&self) -> u32 {
        u32::from_le(self.sub_account_identifier)
    }

    fn options_price_send_interval_in_seconds(&self) -> i32 {
        i32::from_le(self.options_price_send_interval_in_seconds)
    }

    fn set_request_id(&mut self, value: u32) -> &mut Self {
        self.request_id = value.to_le();
        self
    }

    fn set_symbol(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.symbol[..], value);
        self
    }

    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.trade_account[..], value);
        self
    }

    fn set_time_zone(&mut self, value: &str) -> &mut Self {
        set_fixed(&mut self.time_zone[..], value);
        self
    }

    fn set_start_date_time_for_initial_data(
        &mut self,
        value: DateTimeWithMillisecondsInt,
    ) -> &mut Self {
        self.start_date_time_for_initial_data = value.to_le();
        self
    }

    fn set_start_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        self.start_date_time = value.to_le();
        self
    }

    fn set_stop_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        self.stop_date_time = value.to_le();
        self
    }

    fn set_session_begin_time_in_seconds(&mut self, value: u16) -> &mut Self {
        self.session_begin_time_in_seconds = value.to_le();
        self
    }

    fn set_session_end_time_in_seconds(&mut self, value: u16) -> &mut Self {
        self.session_end_time_in_seconds = value.to_le();
        self
    }

    fn set_replay_speed(&mut self, value: f32) -> &mut Self {
        self.replay_speed = f32_le(value);
        self
    }

    fn set_bar_time_in_seconds(&mut self, value: i32) -> &mut Self {
        self.bar_time_in_seconds = value.to_le();
        self
    }

    fn set_pause_replay_after_initial_data_sent(&mut self, value: u8) -> &mut Self {
        self.pause_replay_after_initial_data_sent = value;
        self
    }

    fn set_use_saved_prior_state(&mut self, value: bool) -> &mut Self {
        self.use_saved_prior_state = value;
        self
    }

    fn set_symbol_volatility(&mut self, value: f32) -> &mut Self {
        self.symbol_volatility = f32_le(value);
        self
    }

    fn set_interest_rate(&mut self, value: f32) -> &mut Self {
        self.interest_rate = f32_le(value);
        self
    }

    fn set_number_of_orders_to_trigger_finish_to_stop_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self {
        self.number_of_orders_to_trigger_finish_to_stop_date_time = value.to_le();
        self
    }

    fn set_maximum_number_of_orders_per_replay_session(&mut self, value: i32) -> &mut Self {
        self.maximum_number_of_orders_per_replay_session = value.to_le();
        self
    }

    fn set_number_of_days_for_initial_data_from_before_last_saved_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self {
        self.number_of_days_for_initial_data_from_before_last_saved_date_time = value.to_le();
        self
    }

    fn set_sub_account_identifier(&mut self, value: u32) -> &mut Self {
        self.sub_account_identifier = value.to_le();
        self
    }

    fn set_options_price_send_interval_in_seconds(&mut self, value: i32) -> &mut Self {
        self.options_price_send_interval_in_seconds = value.to_le();
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }
}

impl ReplayChartData for ReplayChartDataFixedUnsafe {
    type Safe = ReplayChartDataFixed;
    type Unsafe = ReplayChartDataFixedUnsafe;

    fn request_id(&self) -> u32 {
        if self.is_out_of_bounds(8) {
            0u32
        } else {
            u32::from_le(self.request_id)
        }
    }

    fn symbol(&self) -> &str {
        if self.is_out_of_bounds(72) {
            ""
        } else {
            get_fixed(&self.symbol[..])
        }
    }

    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(104) {
            ""
        } else {
            get_fixed(&self.trade_account[..])
        }
    }

    fn time_zone(&self) -> &str {
        if self.is_out_of_bounds(360) {
            ""
        } else {
            get_fixed(&self.time_zone[..])
        }
    }

    fn start_date_time_for_initial_data(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(368) {
            0i64
        } else {
            i64::from_le(self.start_date_time_for_initial_data)
        }
    }

    fn start_date_time(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(376) {
            0i64
        } else {
            i64::from_le(self.start_date_time)
        }
    }

    fn stop_date_time(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(384) {
            0i64
        } else {
            i64::from_le(self.stop_date_time)
        }
    }

    fn session_begin_time_in_seconds(&self) -> u16 {
        if self.is_out_of_bounds(386) {
            0u16
        } else {
            u16::from_le(self.session_begin_time_in_seconds)
        }
    }

    fn session_end_time_in_seconds(&self) -> u16 {
        if self.is_out_of_bounds(388) {
            0u16
        } else {
            u16::from_le(self.session_end_time_in_seconds)
        }
    }

    fn replay_speed(&self) -> f32 {
        if self.is_out_of_bounds(392) {
            1.0
        } else {
            f32_le(self.replay_speed)
        }
    }

    fn bar_time_in_seconds(&self) -> i32 {
        if self.is_out_of_bounds(396) {
            0i32
        } else {
            i32::from_le(self.bar_time_in_seconds)
        }
    }

    fn pause_replay_after_initial_data_sent(&self) -> u8 {
        if self.is_out_of_bounds(397) {
            0u8
        } else {
            self.pause_replay_after_initial_data_sent
        }
    }

    fn use_saved_prior_state(&self) -> bool {
        if self.is_out_of_bounds(398) {
            false
        } else {
            self.use_saved_prior_state
        }
    }

    fn symbol_volatility(&self) -> f32 {
        if self.is_out_of_bounds(402) {
            0.0f32
        } else {
            f32_le(self.symbol_volatility)
        }
    }

    fn interest_rate(&self) -> f32 {
        if self.is_out_of_bounds(406) {
            0.0f32
        } else {
            f32_le(self.interest_rate)
        }
    }

    fn number_of_orders_to_trigger_finish_to_stop_date_time(&self) -> i32 {
        if self.is_out_of_bounds(410) {
            0i32
        } else {
            i32::from_le(self.number_of_orders_to_trigger_finish_to_stop_date_time)
        }
    }

    fn maximum_number_of_orders_per_replay_session(&self) -> i32 {
        if self.is_out_of_bounds(414) {
            0i32
        } else {
            i32::from_le(self.maximum_number_of_orders_per_replay_session)
        }
    }

    fn number_of_days_for_initial_data_from_before_last_saved_date_time(&self) -> i32 {
        if self.is_out_of_bounds(418) {
            0i32
        } else {
            i32::from_le(self.number_of_days_for_initial_data_from_before_last_saved_date_time)
        }
    }

    fn sub_account_identifier(&self) -> u32 {
        if self.is_out_of_bounds(422) {
            0u32.to_le()
        } else {
            u32::from_le(self.sub_account_identifier)
        }
    }

    fn options_price_send_interval_in_seconds(&self) -> i32 {
        if self.is_out_of_bounds(426) {
            0i32.to_le()
        } else {
            i32::from_le(self.options_price_send_interval_in_seconds)
        }
    }

    fn set_request_id(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(8) {
            self.request_id = value.to_le();
        }
        self
    }

    fn set_symbol(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(72) {
            set_fixed(&mut self.symbol[..], value);
        }
        self
    }

    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(104) {
            set_fixed(&mut self.trade_account[..], value);
        }
        self
    }

    fn set_time_zone(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(360) {
            set_fixed(&mut self.time_zone[..], value);
        }
        self
    }

    fn set_start_date_time_for_initial_data(
        &mut self,
        value: DateTimeWithMillisecondsInt,
    ) -> &mut Self {
        if !self.is_out_of_bounds(368) {
            self.start_date_time_for_initial_data = value.to_le();
        }
        self
    }

    fn set_start_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(376) {
            self.start_date_time = value.to_le();
        }
        self
    }

    fn set_stop_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(384) {
            self.stop_date_time = value.to_le();
        }
        self
    }

    fn set_session_begin_time_in_seconds(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(386) {
            self.session_begin_time_in_seconds = value.to_le();
        }
        self
    }

    fn set_session_end_time_in_seconds(&mut self, value: u16) -> &mut Self {
        if !self.is_out_of_bounds(388) {
            self.session_end_time_in_seconds = value.to_le();
        }
        self
    }

    fn set_replay_speed(&mut self, value: f32) -> &mut Self {
        if !self.is_out_of_bounds(392) {
            self.replay_speed = f32_le(value);
        }
        self
    }

    fn set_bar_time_in_seconds(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(396) {
            self.bar_time_in_seconds = value.to_le();
        }
        self
    }

    fn set_pause_replay_after_initial_data_sent(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(397) {
            self.pause_replay_after_initial_data_sent = value;
        }
        self
    }

    fn set_use_saved_prior_state(&mut self, value: bool) -> &mut Self {
        if !self.is_out_of_bounds(398) {
            self.use_saved_prior_state = value;
        }
        self
    }

    fn set_symbol_volatility(&mut self, value: f32) -> &mut Self {
        if !self.is_out_of_bounds(402) {
            self.symbol_volatility = f32_le(value);
        }
        self
    }

    fn set_interest_rate(&mut self, value: f32) -> &mut Self {
        if !self.is_out_of_bounds(406) {
            self.interest_rate = f32_le(value);
        }
        self
    }

    fn set_number_of_orders_to_trigger_finish_to_stop_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self {
        if !self.is_out_of_bounds(410) {
            self.number_of_orders_to_trigger_finish_to_stop_date_time = value.to_le();
        }
        self
    }

    fn set_maximum_number_of_orders_per_replay_session(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(414) {
            self.maximum_number_of_orders_per_replay_session = value.to_le();
        }
        self
    }

    fn set_number_of_days_for_initial_data_from_before_last_saved_date_time(
        &mut self,
        value: i32,
    ) -> &mut Self {
        if !self.is_out_of_bounds(418) {
            self.number_of_days_for_initial_data_from_before_last_saved_date_time = value.to_le();
        }
        self
    }

    fn set_sub_account_identifier(&mut self, value: u32) -> &mut Self {
        if !self.is_out_of_bounds(422) {
            self.sub_account_identifier = value.to_le();
        }
        self
    }

    fn set_options_price_send_interval_in_seconds(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(426) {
            self.options_price_send_interval_in_seconds = value.to_le();
        }
        self
    }

    #[inline]
    fn clone_safe(&self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    #[test]
    pub(crate) fn layout() {
        unsafe {
            assert_eq!(
                426usize,
                core::mem::size_of::<ReplayChartDataFixedData>(),
                "ReplayChartDataFixedData sizeof expected {:} but was {:}",
                426usize,
                core::mem::size_of::<ReplayChartDataFixedData>()
            );
            assert_eq!(
                426u16,
                ReplayChartDataFixed::new().size(),
                "ReplayChartDataFixed sizeof expected {:} but was {:}",
                426u16,
                ReplayChartDataFixed::new().size(),
            );
            assert_eq!(
                REPLAY_CHART_DATA,
                ReplayChartDataFixed::new().r#type(),
                "ReplayChartDataFixed type expected {:} but was {:}",
                REPLAY_CHART_DATA,
                ReplayChartDataFixed::new().r#type(),
            );
            assert_eq!(
                10104u16,
                ReplayChartDataFixed::new().r#type(),
                "ReplayChartDataFixed type expected {:} but was {:}",
                10104u16,
                ReplayChartDataFixed::new().r#type(),
            );
            let d = ReplayChartDataFixedData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.request_id) as usize) - p,
                "request_id offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.request_id) as usize) - p,
            );
            assert_eq!(
                8usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
                "symbol offset expected {:} but was {:}",
                8usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
            );
            assert_eq!(
                72usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
                "trade_account offset expected {:} but was {:}",
                72usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
            );
            assert_eq!(
                104usize,
                (core::ptr::addr_of!(d.time_zone) as usize) - p,
                "time_zone offset expected {:} but was {:}",
                104usize,
                (core::ptr::addr_of!(d.time_zone) as usize) - p,
            );
            assert_eq!(
                360usize,
                (core::ptr::addr_of!(d.start_date_time_for_initial_data) as usize) - p,
                "start_date_time_for_initial_data offset expected {:} but was {:}",
                360usize,
                (core::ptr::addr_of!(d.start_date_time_for_initial_data) as usize) - p,
            );
            assert_eq!(
                368usize,
                (core::ptr::addr_of!(d.start_date_time) as usize) - p,
                "start_date_time offset expected {:} but was {:}",
                368usize,
                (core::ptr::addr_of!(d.start_date_time) as usize) - p,
            );
            assert_eq!(
                376usize,
                (core::ptr::addr_of!(d.stop_date_time) as usize) - p,
                "stop_date_time offset expected {:} but was {:}",
                376usize,
                (core::ptr::addr_of!(d.stop_date_time) as usize) - p,
            );
            assert_eq!(
                384usize,
                (core::ptr::addr_of!(d.session_begin_time_in_seconds) as usize) - p,
                "session_begin_time_in_seconds offset expected {:} but was {:}",
                384usize,
                (core::ptr::addr_of!(d.session_begin_time_in_seconds) as usize) - p,
            );
            assert_eq!(
                386usize,
                (core::ptr::addr_of!(d.session_end_time_in_seconds) as usize) - p,
                "session_end_time_in_seconds offset expected {:} but was {:}",
                386usize,
                (core::ptr::addr_of!(d.session_end_time_in_seconds) as usize) - p,
            );
            assert_eq!(
                388usize,
                (core::ptr::addr_of!(d.replay_speed) as usize) - p,
                "replay_speed offset expected {:} but was {:}",
                388usize,
                (core::ptr::addr_of!(d.replay_speed) as usize) - p,
            );
            assert_eq!(
                392usize,
                (core::ptr::addr_of!(d.bar_time_in_seconds) as usize) - p,
                "bar_time_in_seconds offset expected {:} but was {:}",
                392usize,
                (core::ptr::addr_of!(d.bar_time_in_seconds) as usize) - p,
            );
            assert_eq!(
                396usize,
                (core::ptr::addr_of!(d.pause_replay_after_initial_data_sent) as usize) - p,
                "pause_replay_after_initial_data_sent offset expected {:} but was {:}",
                396usize,
                (core::ptr::addr_of!(d.pause_replay_after_initial_data_sent) as usize) - p,
            );
            assert_eq!(
                397usize,
                (core::ptr::addr_of!(d.use_saved_prior_state) as usize) - p,
                "use_saved_prior_state offset expected {:} but was {:}",
                397usize,
                (core::ptr::addr_of!(d.use_saved_prior_state) as usize) - p,
            );
            assert_eq!(
                398usize,
                (core::ptr::addr_of!(d.symbol_volatility) as usize) - p,
                "symbol_volatility offset expected {:} but was {:}",
                398usize,
                (core::ptr::addr_of!(d.symbol_volatility) as usize) - p,
            );
            assert_eq!(
                402usize,
                (core::ptr::addr_of!(d.interest_rate) as usize) - p,
                "interest_rate offset expected {:} but was {:}",
                402usize,
                (core::ptr::addr_of!(d.interest_rate) as usize) - p,
            );
            assert_eq!(
                406usize,
                (core::ptr::addr_of!(d.number_of_orders_to_trigger_finish_to_stop_date_time) as usize) - p,
                "number_of_orders_to_trigger_finish_to_stop_date_time offset expected {:} but was {:}",
                406usize,
                (core::ptr::addr_of!(d.number_of_orders_to_trigger_finish_to_stop_date_time) as usize) - p,
            );
            assert_eq!(
                410usize,
                (core::ptr::addr_of!(d.maximum_number_of_orders_per_replay_session) as usize) - p,
                "maximum_number_of_orders_per_replay_session offset expected {:} but was {:}",
                410usize,
                (core::ptr::addr_of!(d.maximum_number_of_orders_per_replay_session) as usize) - p,
            );
            assert_eq!(
                414usize,
                (core::ptr::addr_of!(d.number_of_days_for_initial_data_from_before_last_saved_date_time) as usize) - p,
                "number_of_days_for_initial_data_from_before_last_saved_date_time offset expected {:} but was {:}",
                414usize,
                (core::ptr::addr_of!(d.number_of_days_for_initial_data_from_before_last_saved_date_time) as usize) - p,
            );
            assert_eq!(
                418usize,
                (core::ptr::addr_of!(d.sub_account_identifier) as usize) - p,
                "sub_account_identifier offset expected {:} but was {:}",
                418usize,
                (core::ptr::addr_of!(d.sub_account_identifier) as usize) - p,
            );
            assert_eq!(
                422usize,
                (core::ptr::addr_of!(d.options_price_send_interval_in_seconds) as usize) - p,
                "options_price_send_interval_in_seconds offset expected {:} but was {:}",
                422usize,
                (core::ptr::addr_of!(d.options_price_send_interval_in_seconds) as usize) - p,
            );
        }
        unsafe {
            assert_eq!(
                88usize,
                core::mem::size_of::<ReplayChartDataVLSData>(),
                "ReplayChartDataVLSData sizeof expected {:} but was {:}",
                88usize,
                core::mem::size_of::<ReplayChartDataVLSData>()
            );
            assert_eq!(
                88u16,
                ReplayChartDataVLS::new().size(),
                "ReplayChartDataVLS sizeof expected {:} but was {:}",
                88u16,
                ReplayChartDataVLS::new().size(),
            );
            assert_eq!(
                REPLAY_CHART_DATA,
                ReplayChartDataVLS::new().r#type(),
                "ReplayChartDataVLS type expected {:} but was {:}",
                REPLAY_CHART_DATA,
                ReplayChartDataVLS::new().r#type(),
            );
            assert_eq!(
                10104u16,
                ReplayChartDataVLS::new().r#type(),
                "ReplayChartDataVLS type expected {:} but was {:}",
                10104u16,
                ReplayChartDataVLS::new().r#type(),
            );
            let d = ReplayChartDataVLSData::new();
            let p = (&d as *const _ as *const u8).offset(0) as usize;
            assert_eq!(
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
                "size offset expected {:} but was {:}",
                0usize,
                (core::ptr::addr_of!(d.size) as usize) - p,
            );
            assert_eq!(
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
                "type offset expected {:} but was {:}",
                2usize,
                (core::ptr::addr_of!(d.r#type) as usize) - p,
            );
            assert_eq!(
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
                "base_size offset expected {:} but was {:}",
                4usize,
                (core::ptr::addr_of!(d.base_size) as usize) - p,
            );
            assert_eq!(
                6usize,
                (core::ptr::addr_of!(d.request_id) as usize) - p,
                "request_id offset expected {:} but was {:}",
                6usize,
                (core::ptr::addr_of!(d.request_id) as usize) - p,
            );
            assert_eq!(
                10usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
                "symbol offset expected {:} but was {:}",
                10usize,
                (core::ptr::addr_of!(d.symbol) as usize) - p,
            );
            assert_eq!(
                14usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
                "trade_account offset expected {:} but was {:}",
                14usize,
                (core::ptr::addr_of!(d.trade_account) as usize) - p,
            );
            assert_eq!(
                18usize,
                (core::ptr::addr_of!(d.time_zone) as usize) - p,
                "time_zone offset expected {:} but was {:}",
                18usize,
                (core::ptr::addr_of!(d.time_zone) as usize) - p,
            );
            assert_eq!(
                22usize,
                (core::ptr::addr_of!(d.start_date_time_for_initial_data) as usize) - p,
                "start_date_time_for_initial_data offset expected {:} but was {:}",
                22usize,
                (core::ptr::addr_of!(d.start_date_time_for_initial_data) as usize) - p,
            );
            assert_eq!(
                30usize,
                (core::ptr::addr_of!(d.start_date_time) as usize) - p,
                "start_date_time offset expected {:} but was {:}",
                30usize,
                (core::ptr::addr_of!(d.start_date_time) as usize) - p,
            );
            assert_eq!(
                38usize,
                (core::ptr::addr_of!(d.stop_date_time) as usize) - p,
                "stop_date_time offset expected {:} but was {:}",
                38usize,
                (core::ptr::addr_of!(d.stop_date_time) as usize) - p,
            );
            assert_eq!(
                46usize,
                (core::ptr::addr_of!(d.session_begin_time_in_seconds) as usize) - p,
                "session_begin_time_in_seconds offset expected {:} but was {:}",
                46usize,
                (core::ptr::addr_of!(d.session_begin_time_in_seconds) as usize) - p,
            );
            assert_eq!(
                48usize,
                (core::ptr::addr_of!(d.session_end_time_in_seconds) as usize) - p,
                "session_end_time_in_seconds offset expected {:} but was {:}",
                48usize,
                (core::ptr::addr_of!(d.session_end_time_in_seconds) as usize) - p,
            );
            assert_eq!(
                50usize,
                (core::ptr::addr_of!(d.replay_speed) as usize) - p,
                "replay_speed offset expected {:} but was {:}",
                50usize,
                (core::ptr::addr_of!(d.replay_speed) as usize) - p,
            );
            assert_eq!(
                54usize,
                (core::ptr::addr_of!(d.bar_time_in_seconds) as usize) - p,
                "bar_time_in_seconds offset expected {:} but was {:}",
                54usize,
                (core::ptr::addr_of!(d.bar_time_in_seconds) as usize) - p,
            );
            assert_eq!(
                58usize,
                (core::ptr::addr_of!(d.pause_replay_after_initial_data_sent) as usize) - p,
                "pause_replay_after_initial_data_sent offset expected {:} but was {:}",
                58usize,
                (core::ptr::addr_of!(d.pause_replay_after_initial_data_sent) as usize) - p,
            );
            assert_eq!(
                59usize,
                (core::ptr::addr_of!(d.use_saved_prior_state) as usize) - p,
                "use_saved_prior_state offset expected {:} but was {:}",
                59usize,
                (core::ptr::addr_of!(d.use_saved_prior_state) as usize) - p,
            );
            assert_eq!(
                60usize,
                (core::ptr::addr_of!(d.symbol_volatility) as usize) - p,
                "symbol_volatility offset expected {:} but was {:}",
                60usize,
                (core::ptr::addr_of!(d.symbol_volatility) as usize) - p,
            );
            assert_eq!(
                64usize,
                (core::ptr::addr_of!(d.interest_rate) as usize) - p,
                "interest_rate offset expected {:} but was {:}",
                64usize,
                (core::ptr::addr_of!(d.interest_rate) as usize) - p,
            );
            assert_eq!(
                68usize,
                (core::ptr::addr_of!(d.number_of_orders_to_trigger_finish_to_stop_date_time) as usize) - p,
                "number_of_orders_to_trigger_finish_to_stop_date_time offset expected {:} but was {:}",
                68usize,
                (core::ptr::addr_of!(d.number_of_orders_to_trigger_finish_to_stop_date_time) as usize) - p,
            );
            assert_eq!(
                72usize,
                (core::ptr::addr_of!(d.maximum_number_of_orders_per_replay_session) as usize) - p,
                "maximum_number_of_orders_per_replay_session offset expected {:} but was {:}",
                72usize,
                (core::ptr::addr_of!(d.maximum_number_of_orders_per_replay_session) as usize) - p,
            );
            assert_eq!(
                76usize,
                (core::ptr::addr_of!(d.number_of_days_for_initial_data_from_before_last_saved_date_time) as usize) - p,
                "number_of_days_for_initial_data_from_before_last_saved_date_time offset expected {:} but was {:}",
                76usize,
                (core::ptr::addr_of!(d.number_of_days_for_initial_data_from_before_last_saved_date_time) as usize) - p,
            );
            assert_eq!(
                80usize,
                (core::ptr::addr_of!(d.sub_account_identifier) as usize) - p,
                "sub_account_identifier offset expected {:} but was {:}",
                80usize,
                (core::ptr::addr_of!(d.sub_account_identifier) as usize) - p,
            );
            assert_eq!(
                84usize,
                (core::ptr::addr_of!(d.options_price_send_interval_in_seconds) as usize) - p,
                "options_price_send_interval_in_seconds offset expected {:} but was {:}",
                84usize,
                (core::ptr::addr_of!(d.options_price_send_interval_in_seconds) as usize) - p,
            );
        }
    }
}
