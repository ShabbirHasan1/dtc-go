// generated by github.com/moontrade/dtc-go/codegen/go at 2022-05-23 20:55:30.06895 +0800 WITA m=+0.009031834
use super::alias::*;
use super::constants::*;
use super::enums::*;
use crate::message::*;

const ORDER_UPDATE_VLS_SIZE: usize = 216;

const ORDER_UPDATE_FIXED_SIZE: usize = 720;

/// size                              u16                          = OrderUpdateVLSSize  (216)
/// r#type                            u16                          = ORDER_UPDATE  (301)
/// base_size                         u16                          = OrderUpdateVLSSize  (216)
/// request_id                        i32                          = 0
/// total_num_messages                i32                          = 0
/// message_number                    i32                          = 0
/// symbol                            string                       = ""
/// exchange                          string                       = ""
/// previous_server_order_id          string                       = ""
/// server_order_id                   string                       = ""
/// client_order_id                   string                       = ""
/// exchange_order_id                 string                       = ""
/// order_status                      OrderStatusEnum              = ORDER_STATUS_UNSPECIFIED  (0)
/// order_update_reason               OrderUpdateReasonEnum        = ORDER_UPDATE_REASON_UNSET  (0)
/// order_type                        OrderTypeEnum                = ORDER_TYPE_UNSET  (0)
/// buy_sell                          BuySellEnum                  = BUY_SELL_UNSET  (0)
/// price1                            f64                          = f64::MAX
/// price2                            f64                          = f64::MAX
/// time_in_force                     TimeInForceEnum              = TIF_UNSET  (0)
/// good_till_date_time               DateTime                     = 0
/// order_quantity                    f64                          = f64::MAX
/// filled_quantity                   f64                          = f64::MAX
/// remaining_quantity                f64                          = f64::MAX
/// average_fill_price                f64                          = f64::MAX
/// last_fill_price                   f64                          = f64::MAX
/// last_fill_date_time               DateTimeWithMillisecondsInt  = 0
/// last_fill_quantity                f64                          = f64::MAX
/// last_fill_execution_id            string                       = ""
/// trade_account                     string                       = ""
/// info_text                         string                       = ""
/// no_orders                         u8                           = 0
/// parent_server_order_id            string                       = ""
/// oco_linked_order_server_order_id  string                       = ""
/// open_or_close                     OpenCloseTradeEnum           = TRADE_UNSET  (0)
/// previous_client_order_id          string                       = ""
/// free_form_text                    string                       = ""
/// order_received_date_time          DateTimeWithMillisecondsInt  = 0
/// latest_transaction_date_time      DateTimeWithMilliseconds     = 0
/// username                          string                       = ""
const ORDER_UPDATE_VLS_DEFAULT: [u8; 216] = [
    216, 0, 45, 1, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 255, 255, 255, 255, 255, 255, 239, 127, 255, 255, 255, 255, 255, 255, 239, 127, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 239, 127, 255, 255, 255,
    255, 255, 255, 239, 127, 255, 255, 255, 255, 255, 255, 239, 127, 255, 255, 255, 255, 255, 255,
    239, 127, 255, 255, 255, 255, 255, 255, 239, 127, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255,
    255, 255, 239, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
];

/// size                              u16                          = OrderUpdateFixedSize  (720)
/// r#type                            u16                          = ORDER_UPDATE  (301)
/// request_id                        i32                          = 0
/// total_num_messages                i32                          = 0
/// message_number                    i32                          = 0
/// symbol                            string64                     = ""
/// exchange                          string16                     = ""
/// previous_server_order_id          string32                     = ""
/// server_order_id                   string32                     = ""
/// client_order_id                   string32                     = ""
/// exchange_order_id                 string32                     = ""
/// order_status                      OrderStatusEnum              = ORDER_STATUS_UNSPECIFIED  (0)
/// order_update_reason               OrderUpdateReasonEnum        = ORDER_UPDATE_REASON_UNSET  (0)
/// order_type                        OrderTypeEnum                = ORDER_TYPE_UNSET  (0)
/// buy_sell                          BuySellEnum                  = BUY_SELL_UNSET  (0)
/// price1                            f64                          = f64::MAX
/// price2                            f64                          = f64::MAX
/// time_in_force                     TimeInForceEnum              = TIF_UNSET  (0)
/// good_till_date_time               DateTime                     = 0
/// order_quantity                    f64                          = f64::MAX
/// filled_quantity                   f64                          = f64::MAX
/// remaining_quantity                f64                          = f64::MAX
/// average_fill_price                f64                          = f64::MAX
/// last_fill_price                   f64                          = f64::MAX
/// last_fill_date_time               DateTimeWithMillisecondsInt  = 0
/// last_fill_quantity                f64                          = f64::MAX
/// last_fill_execution_id            string64                     = ""
/// trade_account                     string32                     = ""
/// info_text                         string96                     = ""
/// no_orders                         u8                           = 0
/// parent_server_order_id            string32                     = ""
/// oco_linked_order_server_order_id  string32                     = ""
/// open_or_close                     OpenCloseTradeEnum           = TRADE_UNSET  (0)
/// previous_client_order_id          string32                     = ""
/// free_form_text                    string48                     = ""
/// order_received_date_time          DateTimeWithMillisecondsInt  = 0
/// latest_transaction_date_time      DateTimeWithMilliseconds     = 0
/// username                          string32                     = ""
const ORDER_UPDATE_FIXED_DEFAULT: [u8; 720] = [
    208, 2, 45, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 239, 127, 255,
    255, 255, 255, 255, 255, 239, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,
    255, 255, 255, 255, 239, 127, 255, 255, 255, 255, 255, 255, 239, 127, 255, 255, 255, 255, 255,
    255, 239, 127, 255, 255, 255, 255, 255, 255, 239, 127, 255, 255, 255, 255, 255, 255, 239, 127,
    0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 239, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

/// The OrderUpdateVLS is a unified message from the Server to the Client
/// which communicates the complete details of an order, the Order Status,
/// and the reason for sending the message (OrderUpdateReason).
///
/// DTC uses this single unified message to provide an update for an order.
/// The OrderUpdateReason field provides a clear indication for each reason
/// this message is being sent.
pub trait OrderUpdate {
    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn request_id(&self) -> i32;

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn total_num_messages(&self) -> i32;

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn message_number(&self) -> i32;

    /// The symbol for the order.
    fn symbol(&self) -> &str;

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str;

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn previous_server_order_id(&self) -> &str;

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn server_order_id(&self) -> &str;

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn client_order_id(&self) -> &str;

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn exchange_order_id(&self) -> &str;

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn order_status(&self) -> OrderStatusEnum;

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn order_update_reason(&self) -> OrderUpdateReasonEnum;

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn order_type(&self) -> OrderTypeEnum;

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn buy_sell(&self) -> BuySellEnum;

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price1(&self) -> f64;

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price2(&self) -> f64;

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn time_in_force(&self) -> TimeInForceEnum;

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn good_till_date_time(&self) -> DateTime;

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn order_quantity(&self) -> f64;

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn filled_quantity(&self) -> f64;

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn remaining_quantity(&self) -> f64;

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn average_fill_price(&self) -> f64;

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_price(&self) -> f64;

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_date_time(&self) -> DateTimeWithMillisecondsInt;

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_quantity(&self) -> f64;

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_execution_id(&self) -> &str;

    /// The trade account the order belongs to.
    fn trade_account(&self) -> &str;

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn info_text(&self) -> &str;

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn no_orders(&self) -> u8;

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn parent_server_order_id(&self) -> &str;

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn oco_linked_order_server_order_id(&self) -> &str;

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum;

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn previous_client_order_id(&self) -> &str;

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn free_form_text(&self) -> &str;

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn order_received_date_time(&self) -> DateTimeWithMillisecondsInt;

    fn latest_transaction_date_time(&self) -> DateTimeWithMilliseconds;

    fn username(&self) -> &str;

    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn set_request_id(&mut self, value: i32) -> &mut Self;

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn set_total_num_messages(&mut self, value: i32) -> &mut Self;

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn set_message_number(&mut self, value: i32) -> &mut Self;

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self;

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self;

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn set_previous_server_order_id(&mut self, value: &str) -> &mut Self;

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn set_server_order_id(&mut self, value: &str) -> &mut Self;

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self;

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn set_exchange_order_id(&mut self, value: &str) -> &mut Self;

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn set_order_status(&mut self, value: OrderStatusEnum) -> &mut Self;

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn set_order_update_reason(&mut self, value: OrderUpdateReasonEnum) -> &mut Self;

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self;

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self;

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price1(&mut self, value: f64) -> &mut Self;

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price2(&mut self, value: f64) -> &mut Self;

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self;

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self;

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_order_quantity(&mut self, value: f64) -> &mut Self;

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_filled_quantity(&mut self, value: f64) -> &mut Self;

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_remaining_quantity(&mut self, value: f64) -> &mut Self;

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_average_fill_price(&mut self, value: f64) -> &mut Self;

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_price(&mut self, value: f64) -> &mut Self;

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self;

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_quantity(&mut self, value: f64) -> &mut Self;

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_execution_id(&mut self, value: &str) -> &mut Self;

    /// The trade account the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self;

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn set_info_text(&mut self, value: &str) -> &mut Self;

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn set_no_orders(&mut self, value: u8) -> &mut Self;

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn set_parent_server_order_id(&mut self, value: &str) -> &mut Self;

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn set_oco_linked_order_server_order_id(&mut self, value: &str) -> &mut Self;

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self;

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn set_previous_client_order_id(&mut self, value: &str) -> &mut Self;

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self;

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn set_order_received_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self;

    fn set_latest_transaction_date_time(&mut self, value: DateTimeWithMilliseconds) -> &mut Self;

    fn set_username(&mut self, value: &str) -> &mut Self;

    fn copy_to(&self, to: &mut impl OrderUpdate) {
        to.set_request_id(self.request_id());
        to.set_total_num_messages(self.total_num_messages());
        to.set_message_number(self.message_number());
        to.set_symbol(self.symbol());
        to.set_exchange(self.exchange());
        to.set_previous_server_order_id(self.previous_server_order_id());
        to.set_server_order_id(self.server_order_id());
        to.set_client_order_id(self.client_order_id());
        to.set_exchange_order_id(self.exchange_order_id());
        to.set_order_status(self.order_status());
        to.set_order_update_reason(self.order_update_reason());
        to.set_order_type(self.order_type());
        to.set_buy_sell(self.buy_sell());
        to.set_price1(self.price1());
        to.set_price2(self.price2());
        to.set_time_in_force(self.time_in_force());
        to.set_good_till_date_time(self.good_till_date_time());
        to.set_order_quantity(self.order_quantity());
        to.set_filled_quantity(self.filled_quantity());
        to.set_remaining_quantity(self.remaining_quantity());
        to.set_average_fill_price(self.average_fill_price());
        to.set_last_fill_price(self.last_fill_price());
        to.set_last_fill_date_time(self.last_fill_date_time());
        to.set_last_fill_quantity(self.last_fill_quantity());
        to.set_last_fill_execution_id(self.last_fill_execution_id());
        to.set_trade_account(self.trade_account());
        to.set_info_text(self.info_text());
        to.set_no_orders(self.no_orders());
        to.set_parent_server_order_id(self.parent_server_order_id());
        to.set_oco_linked_order_server_order_id(self.oco_linked_order_server_order_id());
        to.set_open_or_close(self.open_or_close());
        to.set_previous_client_order_id(self.previous_client_order_id());
        to.set_free_form_text(self.free_form_text());
        to.set_order_received_date_time(self.order_received_date_time());
        to.set_latest_transaction_date_time(self.latest_transaction_date_time());
        to.set_username(self.username());
    }
}

/// The OrderUpdateVLS is a unified message from the Server to the Client
/// which communicates the complete details of an order, the Order Status,
/// and the reason for sending the message (OrderUpdateReason).
///
/// DTC uses this single unified message to provide an update for an order.
/// The OrderUpdateReason field provides a clear indication for each reason
/// this message is being sent.
pub struct OrderUpdateVLS {
    data: *const OrderUpdateVLSData,
    capacity: usize,
}

pub struct OrderUpdateVLSUnsafe {
    data: *const OrderUpdateVLSData,
    capacity: usize,
}

#[repr(packed, C)]
pub struct OrderUpdateVLSData {
    size: u16,
    r#type: u16,
    base_size: u16,
    request_id: i32,
    total_num_messages: i32,
    message_number: i32,
    symbol: VLS,
    exchange: VLS,
    previous_server_order_id: VLS,
    server_order_id: VLS,
    client_order_id: VLS,
    exchange_order_id: VLS,
    order_status: OrderStatusEnum,
    order_update_reason: OrderUpdateReasonEnum,
    order_type: OrderTypeEnum,
    buy_sell: BuySellEnum,
    price1: f64,
    price2: f64,
    time_in_force: TimeInForceEnum,
    good_till_date_time: DateTime,
    order_quantity: f64,
    filled_quantity: f64,
    remaining_quantity: f64,
    average_fill_price: f64,
    last_fill_price: f64,
    last_fill_date_time: DateTimeWithMillisecondsInt,
    last_fill_quantity: f64,
    last_fill_execution_id: VLS,
    trade_account: VLS,
    info_text: VLS,
    no_orders: u8,
    parent_server_order_id: VLS,
    oco_linked_order_server_order_id: VLS,
    open_or_close: OpenCloseTradeEnum,
    previous_client_order_id: VLS,
    free_form_text: VLS,
    order_received_date_time: DateTimeWithMillisecondsInt,
    latest_transaction_date_time: DateTimeWithMilliseconds,
    username: VLS,
}

/// The OrderUpdateVLS is a unified message from the Server to the Client
/// which communicates the complete details of an order, the Order Status,
/// and the reason for sending the message (OrderUpdateReason).
///
/// DTC uses this single unified message to provide an update for an order.
/// The OrderUpdateReason field provides a clear indication for each reason
/// this message is being sent.
pub struct OrderUpdateFixed {
    data: *const OrderUpdateFixedData,
}

pub struct OrderUpdateFixedUnsafe {
    data: *const OrderUpdateFixedData,
}

#[repr(packed, C)]
pub struct OrderUpdateFixedData {
    size: u16,
    r#type: u16,
    request_id: i32,
    total_num_messages: i32,
    message_number: i32,
    symbol: [u8; 64],
    exchange: [u8; 16],
    previous_server_order_id: [u8; 32],
    server_order_id: [u8; 32],
    client_order_id: [u8; 32],
    exchange_order_id: [u8; 32],
    order_status: OrderStatusEnum,
    order_update_reason: OrderUpdateReasonEnum,
    order_type: OrderTypeEnum,
    buy_sell: BuySellEnum,
    price1: f64,
    price2: f64,
    time_in_force: TimeInForceEnum,
    good_till_date_time: DateTime,
    order_quantity: f64,
    filled_quantity: f64,
    remaining_quantity: f64,
    average_fill_price: f64,
    last_fill_price: f64,
    last_fill_date_time: DateTimeWithMillisecondsInt,
    last_fill_quantity: f64,
    last_fill_execution_id: [u8; 64],
    trade_account: [u8; 32],
    info_text: [u8; 96],
    no_orders: u8,
    parent_server_order_id: [u8; 32],
    oco_linked_order_server_order_id: [u8; 32],
    open_or_close: OpenCloseTradeEnum,
    previous_client_order_id: [u8; 32],
    free_form_text: [u8; 48],
    order_received_date_time: DateTimeWithMillisecondsInt,
    latest_transaction_date_time: DateTimeWithMilliseconds,
    username: [u8; 32],
}

impl OrderUpdateVLSData {
    pub fn new() -> Self {
        Self {
            size: 216u16.to_le(),
            r#type: ORDER_UPDATE.to_le(),
            base_size: 216u16.to_le(),
            request_id: 0,
            total_num_messages: 0,
            message_number: 0,
            symbol: crate::message::VLS::new(),
            exchange: crate::message::VLS::new(),
            previous_server_order_id: crate::message::VLS::new(),
            server_order_id: crate::message::VLS::new(),
            client_order_id: crate::message::VLS::new(),
            exchange_order_id: crate::message::VLS::new(),
            order_status: OrderStatusEnum::OrderStatusUnspecified.to_le(),
            order_update_reason: OrderUpdateReasonEnum::OrderUpdateReasonUnset.to_le(),
            order_type: OrderTypeEnum::OrderTypeUnset.to_le(),
            buy_sell: BuySellEnum::BuySellUnset.to_le(),
            price1: f64_le(f64::MAX),
            price2: f64_le(f64::MAX),
            time_in_force: TimeInForceEnum::TifUnset.to_le(),
            good_till_date_time: 0,
            order_quantity: f64_le(f64::MAX),
            filled_quantity: f64_le(f64::MAX),
            remaining_quantity: f64_le(f64::MAX),
            average_fill_price: f64_le(f64::MAX),
            last_fill_price: f64_le(f64::MAX),
            last_fill_date_time: 0,
            last_fill_quantity: f64_le(f64::MAX),
            last_fill_execution_id: crate::message::VLS::new(),
            trade_account: crate::message::VLS::new(),
            info_text: crate::message::VLS::new(),
            no_orders: 0,
            parent_server_order_id: crate::message::VLS::new(),
            oco_linked_order_server_order_id: crate::message::VLS::new(),
            open_or_close: OpenCloseTradeEnum::TradeUnset.to_le(),
            previous_client_order_id: crate::message::VLS::new(),
            free_form_text: crate::message::VLS::new(),
            order_received_date_time: 0,
            latest_transaction_date_time: 0.0f64,
            username: crate::message::VLS::new(),
        }
    }
}

impl OrderUpdateFixedData {
    pub fn new() -> Self {
        Self {
            size: 720u16.to_le(),
            r#type: ORDER_UPDATE.to_le(),
            request_id: 0,
            total_num_messages: 0,
            message_number: 0,
            symbol: [0; 64],
            exchange: [0; 16],
            previous_server_order_id: [0; 32],
            server_order_id: [0; 32],
            client_order_id: [0; 32],
            exchange_order_id: [0; 32],
            order_status: OrderStatusEnum::OrderStatusUnspecified.to_le(),
            order_update_reason: OrderUpdateReasonEnum::OrderUpdateReasonUnset.to_le(),
            order_type: OrderTypeEnum::OrderTypeUnset.to_le(),
            buy_sell: BuySellEnum::BuySellUnset.to_le(),
            price1: f64_le(f64::MAX),
            price2: f64_le(f64::MAX),
            time_in_force: TimeInForceEnum::TifUnset.to_le(),
            good_till_date_time: 0,
            order_quantity: f64_le(f64::MAX),
            filled_quantity: f64_le(f64::MAX),
            remaining_quantity: f64_le(f64::MAX),
            average_fill_price: f64_le(f64::MAX),
            last_fill_price: f64_le(f64::MAX),
            last_fill_date_time: 0,
            last_fill_quantity: f64_le(f64::MAX),
            last_fill_execution_id: [0; 64],
            trade_account: [0; 32],
            info_text: [0; 96],
            no_orders: 0,
            parent_server_order_id: [0; 32],
            oco_linked_order_server_order_id: [0; 32],
            open_or_close: OpenCloseTradeEnum::TradeUnset.to_le(),
            previous_client_order_id: [0; 32],
            free_form_text: [0; 48],
            order_received_date_time: 0,
            latest_transaction_date_time: 0.0f64,
            username: [0; 32],
        }
    }
}

unsafe impl Send for OrderUpdateFixed {}
unsafe impl Send for OrderUpdateFixedUnsafe {}
unsafe impl Send for OrderUpdateFixedData {}
unsafe impl Send for OrderUpdateVLS {}
unsafe impl Send for OrderUpdateVLSUnsafe {}
unsafe impl Send for OrderUpdateVLSData {}

impl Drop for OrderUpdateFixed {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for OrderUpdateFixedUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for OrderUpdateVLS {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Drop for OrderUpdateVLSUnsafe {
    #[inline]
    fn drop(&mut self) {
        crate::deallocate(self.data as *mut u8, self.capacity() as usize);
    }
}

impl Clone for OrderUpdateFixed {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for OrderUpdateFixedUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for OrderUpdateVLS {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Clone for OrderUpdateVLSUnsafe {
    #[inline]
    fn clone(&self) -> Self {
        let mut c = Self::new();
        self.copy_to(&mut c);
        c
    }
}

impl Into<Vec<u8>> for OrderUpdateFixed {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for OrderUpdateFixedUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for OrderUpdateVLS {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl Into<Vec<u8>> for OrderUpdateVLSUnsafe {
    #[inline]
    fn into(self) -> Vec<u8> {
        self.into_vec()
    }
}

impl core::ops::Deref for OrderUpdateFixed {
    type Target = OrderUpdateFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for OrderUpdateFixed {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for OrderUpdateFixedUnsafe {
    type Target = OrderUpdateFixedData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for OrderUpdateFixedUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for OrderUpdateVLS {
    type Target = OrderUpdateVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for OrderUpdateVLS {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl core::ops::Deref for OrderUpdateVLSUnsafe {
    type Target = OrderUpdateVLSData;

    #[inline]
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.data }
    }
}

impl core::ops::DerefMut for OrderUpdateVLSUnsafe {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *(self.data as *mut Self::Target) }
    }
}

impl crate::Message for OrderUpdateFixed {
    type Safe = OrderUpdateFixed;
    type Unsafe = OrderUpdateFixedUnsafe;
    type Data = OrderUpdateFixedData;
    const BASE_SIZE: usize = 720;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, OrderUpdateFixedData::new()),
        }
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const OrderUpdateFixedData,
        }
    }
}

impl crate::Message for OrderUpdateFixedUnsafe {
    type Safe = OrderUpdateFixed;
    type Unsafe = OrderUpdateFixedUnsafe;
    type Data = OrderUpdateFixedData;
    const BASE_SIZE: usize = 720;
    const BASE_SIZE_OFFSET: isize = 0;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, OrderUpdateFixedData::new()),
        }
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, _: usize) -> Self {
        Self {
            data: data as *const OrderUpdateFixedData,
        }
    }
}

impl crate::Message for OrderUpdateVLS {
    type Safe = OrderUpdateVLS;
    type Unsafe = OrderUpdateVLSUnsafe;
    type Data = OrderUpdateVLSData;
    const BASE_SIZE: usize = 216;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, OrderUpdateVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        self
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const OrderUpdateVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for OrderUpdateVLS {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const OrderUpdateVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
impl crate::Message for OrderUpdateVLSUnsafe {
    type Safe = OrderUpdateVLS;
    type Unsafe = OrderUpdateVLSUnsafe;
    type Data = OrderUpdateVLSData;
    const BASE_SIZE: usize = 216;
    const BASE_SIZE_OFFSET: isize = 4;
    const DEFAULT_CAPACITY: usize = Self::BASE_SIZE * 2;

    #[inline]
    fn new() -> Self {
        Self {
            data: crate::allocate(Self::BASE_SIZE, OrderUpdateVLSData::new()),
            capacity: Self::DEFAULT_CAPACITY,
        }
    }

    #[inline]
    fn to_safe(self) -> Self::Safe {
        let mut s = Self::Safe::new();
        self.copy_to(&mut s);
        s
    }

    #[inline]
    fn size(&self) -> u16 {
        u16::from_le(self.size)
    }

    #[inline]
    fn r#type(&self) -> u16 {
        u16::from_le(self.r#type)
    }

    #[inline]
    fn base_size(&self) -> u16 {
        u16::from_le(self.base_size)
    }

    #[inline]
    fn capacity(&self) -> u16 {
        self.capacity as u16
    }

    #[inline]
    unsafe fn as_ptr(&self) -> *const Self::Data {
        self.data
    }

    #[inline]
    unsafe fn from_raw_parts(data: *const u8, capacity: usize) -> Self {
        Self {
            data: data as *const OrderUpdateVLSData,
            capacity,
        }
    }
}

impl crate::VLSMessage for OrderUpdateVLSUnsafe {
    #[inline]
    unsafe fn set_ptr(&mut self, value: *const u8) {
        self.data = value as *const OrderUpdateVLSData;
    }

    #[inline]
    fn set_capacity(&mut self, capacity: u16) {
        self.capacity = capacity as usize;
    }

    #[inline]
    fn set_size(&mut self, size: u16) {
        self.size = size.to_le();
    }
}
/// The OrderUpdateVLS is a unified message from the Server to the Client
/// which communicates the complete details of an order, the Order Status,
/// and the reason for sending the message (OrderUpdateReason).
///
/// DTC uses this single unified message to provide an update for an order.
/// The OrderUpdateReason field provides a clear indication for each reason
/// this message is being sent.
impl OrderUpdate for OrderUpdateVLS {
    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn request_id(&self) -> i32 {
        i32::from_le(self.request_id)
    }

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn total_num_messages(&self) -> i32 {
        i32::from_le(self.total_num_messages)
    }

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn message_number(&self) -> i32 {
        i32::from_le(self.message_number)
    }

    /// The symbol for the order.
    fn symbol(&self) -> &str {
        crate::get_vls(self, self.symbol)
    }

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str {
        crate::get_vls(self, self.exchange)
    }

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn previous_server_order_id(&self) -> &str {
        crate::get_vls(self, self.previous_server_order_id)
    }

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn server_order_id(&self) -> &str {
        crate::get_vls(self, self.server_order_id)
    }

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn client_order_id(&self) -> &str {
        crate::get_vls(self, self.client_order_id)
    }

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn exchange_order_id(&self) -> &str {
        crate::get_vls(self, self.exchange_order_id)
    }

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn order_status(&self) -> OrderStatusEnum {
        OrderStatusEnum::from_le(self.order_status)
    }

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn order_update_reason(&self) -> OrderUpdateReasonEnum {
        OrderUpdateReasonEnum::from_le(self.order_update_reason)
    }

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn order_type(&self) -> OrderTypeEnum {
        OrderTypeEnum::from_le(self.order_type)
    }

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn buy_sell(&self) -> BuySellEnum {
        BuySellEnum::from_le(self.buy_sell)
    }

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price1(&self) -> f64 {
        crate::f64_le(self.price1)
    }

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price2(&self) -> f64 {
        crate::f64_le(self.price2)
    }

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn time_in_force(&self) -> TimeInForceEnum {
        TimeInForceEnum::from_le(self.time_in_force)
    }

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn good_till_date_time(&self) -> DateTime {
        i64::from_le(self.good_till_date_time)
    }

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn order_quantity(&self) -> f64 {
        crate::f64_le(self.order_quantity)
    }

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn filled_quantity(&self) -> f64 {
        crate::f64_le(self.filled_quantity)
    }

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn remaining_quantity(&self) -> f64 {
        crate::f64_le(self.remaining_quantity)
    }

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn average_fill_price(&self) -> f64 {
        crate::f64_le(self.average_fill_price)
    }

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_price(&self) -> f64 {
        crate::f64_le(self.last_fill_price)
    }

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_date_time(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.last_fill_date_time)
    }

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_quantity(&self) -> f64 {
        crate::f64_le(self.last_fill_quantity)
    }

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_execution_id(&self) -> &str {
        crate::get_vls(self, self.last_fill_execution_id)
    }

    /// The trade account the order belongs to.
    fn trade_account(&self) -> &str {
        crate::get_vls(self, self.trade_account)
    }

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn info_text(&self) -> &str {
        crate::get_vls(self, self.info_text)
    }

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn no_orders(&self) -> u8 {
        self.no_orders
    }

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn parent_server_order_id(&self) -> &str {
        crate::get_vls(self, self.parent_server_order_id)
    }

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn oco_linked_order_server_order_id(&self) -> &str {
        crate::get_vls(self, self.oco_linked_order_server_order_id)
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum {
        OpenCloseTradeEnum::from_le(self.open_or_close)
    }

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn previous_client_order_id(&self) -> &str {
        crate::get_vls(self, self.previous_client_order_id)
    }

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn free_form_text(&self) -> &str {
        crate::get_vls(self, self.free_form_text)
    }

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn order_received_date_time(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.order_received_date_time)
    }

    fn latest_transaction_date_time(&self) -> DateTimeWithMilliseconds {
        crate::f64_le(self.latest_transaction_date_time)
    }

    fn username(&self) -> &str {
        crate::get_vls(self, self.username)
    }

    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn set_request_id(&mut self, value: i32) -> &mut Self {
        self.request_id = value.to_le();
        self
    }

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn set_total_num_messages(&mut self, value: i32) -> &mut Self {
        self.total_num_messages = value.to_le();
        self
    }

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn set_message_number(&mut self, value: i32) -> &mut Self {
        self.message_number = value.to_le();
        self
    }

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self {
        self.symbol = crate::set_vls(self, self.symbol, value);
        self
    }

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self {
        self.exchange = crate::set_vls(self, self.exchange, value);
        self
    }

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn set_previous_server_order_id(&mut self, value: &str) -> &mut Self {
        self.previous_server_order_id = crate::set_vls(self, self.previous_server_order_id, value);
        self
    }

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn set_server_order_id(&mut self, value: &str) -> &mut Self {
        self.server_order_id = crate::set_vls(self, self.server_order_id, value);
        self
    }

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self {
        self.client_order_id = crate::set_vls(self, self.client_order_id, value);
        self
    }

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn set_exchange_order_id(&mut self, value: &str) -> &mut Self {
        self.exchange_order_id = crate::set_vls(self, self.exchange_order_id, value);
        self
    }

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn set_order_status(&mut self, value: OrderStatusEnum) -> &mut Self {
        self.order_status = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn set_order_update_reason(&mut self, value: OrderUpdateReasonEnum) -> &mut Self {
        self.order_update_reason = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self {
        self.order_type = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self {
        self.buy_sell = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price1(&mut self, value: f64) -> &mut Self {
        self.price1 = f64_le(value);
        self
    }

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price2(&mut self, value: f64) -> &mut Self {
        self.price2 = f64_le(value);
        self
    }

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self {
        self.time_in_force = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self {
        self.good_till_date_time = value.to_le();
        self
    }

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_order_quantity(&mut self, value: f64) -> &mut Self {
        self.order_quantity = f64_le(value);
        self
    }

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_filled_quantity(&mut self, value: f64) -> &mut Self {
        self.filled_quantity = f64_le(value);
        self
    }

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_remaining_quantity(&mut self, value: f64) -> &mut Self {
        self.remaining_quantity = f64_le(value);
        self
    }

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_average_fill_price(&mut self, value: f64) -> &mut Self {
        self.average_fill_price = f64_le(value);
        self
    }

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_price(&mut self, value: f64) -> &mut Self {
        self.last_fill_price = f64_le(value);
        self
    }

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        self.last_fill_date_time = value.to_le();
        self
    }

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_quantity(&mut self, value: f64) -> &mut Self {
        self.last_fill_quantity = f64_le(value);
        self
    }

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_execution_id(&mut self, value: &str) -> &mut Self {
        self.last_fill_execution_id = crate::set_vls(self, self.last_fill_execution_id, value);
        self
    }

    /// The trade account the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        self.trade_account = crate::set_vls(self, self.trade_account, value);
        self
    }

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn set_info_text(&mut self, value: &str) -> &mut Self {
        self.info_text = crate::set_vls(self, self.info_text, value);
        self
    }

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn set_no_orders(&mut self, value: u8) -> &mut Self {
        self.no_orders = value;
        self
    }

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn set_parent_server_order_id(&mut self, value: &str) -> &mut Self {
        self.parent_server_order_id = crate::set_vls(self, self.parent_server_order_id, value);
        self
    }

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn set_oco_linked_order_server_order_id(&mut self, value: &str) -> &mut Self {
        self.oco_linked_order_server_order_id =
            crate::set_vls(self, self.oco_linked_order_server_order_id, value);
        self
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self {
        self.open_or_close = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn set_previous_client_order_id(&mut self, value: &str) -> &mut Self {
        self.previous_client_order_id = crate::set_vls(self, self.previous_client_order_id, value);
        self
    }

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self {
        self.free_form_text = crate::set_vls(self, self.free_form_text, value);
        self
    }

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn set_order_received_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        self.order_received_date_time = value.to_le();
        self
    }

    fn set_latest_transaction_date_time(&mut self, value: DateTimeWithMilliseconds) -> &mut Self {
        self.latest_transaction_date_time = f64_le(value);
        self
    }

    fn set_username(&mut self, value: &str) -> &mut Self {
        self.username = crate::set_vls(self, self.username, value);
        self
    }
}

/// The OrderUpdateVLS is a unified message from the Server to the Client
/// which communicates the complete details of an order, the Order Status,
/// and the reason for sending the message (OrderUpdateReason).
///
/// DTC uses this single unified message to provide an update for an order.
/// The OrderUpdateReason field provides a clear indication for each reason
/// this message is being sent.
impl OrderUpdate for OrderUpdateVLSUnsafe {
    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn request_id(&self) -> i32 {
        if self.is_out_of_bounds(12) {
            0
        } else {
            i32::from_le(self.request_id)
        }
    }

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn total_num_messages(&self) -> i32 {
        if self.is_out_of_bounds(16) {
            0
        } else {
            i32::from_le(self.total_num_messages)
        }
    }

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn message_number(&self) -> i32 {
        if self.is_out_of_bounds(20) {
            0
        } else {
            i32::from_le(self.message_number)
        }
    }

    /// The symbol for the order.
    fn symbol(&self) -> &str {
        if self.is_out_of_bounds(24) {
            ""
        } else {
            crate::get_vls(self, self.symbol)
        }
    }

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str {
        if self.is_out_of_bounds(28) {
            ""
        } else {
            crate::get_vls(self, self.exchange)
        }
    }

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn previous_server_order_id(&self) -> &str {
        if self.is_out_of_bounds(32) {
            ""
        } else {
            crate::get_vls(self, self.previous_server_order_id)
        }
    }

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn server_order_id(&self) -> &str {
        if self.is_out_of_bounds(36) {
            ""
        } else {
            crate::get_vls(self, self.server_order_id)
        }
    }

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn client_order_id(&self) -> &str {
        if self.is_out_of_bounds(40) {
            ""
        } else {
            crate::get_vls(self, self.client_order_id)
        }
    }

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn exchange_order_id(&self) -> &str {
        if self.is_out_of_bounds(44) {
            ""
        } else {
            crate::get_vls(self, self.exchange_order_id)
        }
    }

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn order_status(&self) -> OrderStatusEnum {
        if self.is_out_of_bounds(48) {
            OrderStatusEnum::OrderStatusUnspecified.to_le()
        } else {
            OrderStatusEnum::from_le(self.order_status)
        }
    }

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn order_update_reason(&self) -> OrderUpdateReasonEnum {
        if self.is_out_of_bounds(52) {
            OrderUpdateReasonEnum::OrderUpdateReasonUnset.to_le()
        } else {
            OrderUpdateReasonEnum::from_le(self.order_update_reason)
        }
    }

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn order_type(&self) -> OrderTypeEnum {
        if self.is_out_of_bounds(56) {
            OrderTypeEnum::OrderTypeUnset.to_le()
        } else {
            OrderTypeEnum::from_le(self.order_type)
        }
    }

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn buy_sell(&self) -> BuySellEnum {
        if self.is_out_of_bounds(60) {
            BuySellEnum::BuySellUnset.to_le()
        } else {
            BuySellEnum::from_le(self.buy_sell)
        }
    }

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price1(&self) -> f64 {
        if self.is_out_of_bounds(72) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.price1)
        }
    }

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price2(&self) -> f64 {
        if self.is_out_of_bounds(80) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.price2)
        }
    }

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn time_in_force(&self) -> TimeInForceEnum {
        if self.is_out_of_bounds(84) {
            TimeInForceEnum::TifUnset.to_le()
        } else {
            TimeInForceEnum::from_le(self.time_in_force)
        }
    }

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn good_till_date_time(&self) -> DateTime {
        if self.is_out_of_bounds(96) {
            0
        } else {
            i64::from_le(self.good_till_date_time)
        }
    }

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn order_quantity(&self) -> f64 {
        if self.is_out_of_bounds(104) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.order_quantity)
        }
    }

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn filled_quantity(&self) -> f64 {
        if self.is_out_of_bounds(112) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.filled_quantity)
        }
    }

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn remaining_quantity(&self) -> f64 {
        if self.is_out_of_bounds(120) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.remaining_quantity)
        }
    }

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn average_fill_price(&self) -> f64 {
        if self.is_out_of_bounds(128) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.average_fill_price)
        }
    }

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_price(&self) -> f64 {
        if self.is_out_of_bounds(136) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.last_fill_price)
        }
    }

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_date_time(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(144) {
            0
        } else {
            i64::from_le(self.last_fill_date_time)
        }
    }

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_quantity(&self) -> f64 {
        if self.is_out_of_bounds(152) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.last_fill_quantity)
        }
    }

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_execution_id(&self) -> &str {
        if self.is_out_of_bounds(156) {
            ""
        } else {
            crate::get_vls(self, self.last_fill_execution_id)
        }
    }

    /// The trade account the order belongs to.
    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(160) {
            ""
        } else {
            crate::get_vls(self, self.trade_account)
        }
    }

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn info_text(&self) -> &str {
        if self.is_out_of_bounds(164) {
            ""
        } else {
            crate::get_vls(self, self.info_text)
        }
    }

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn no_orders(&self) -> u8 {
        if self.is_out_of_bounds(165) {
            0
        } else {
            self.no_orders
        }
    }

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn parent_server_order_id(&self) -> &str {
        if self.is_out_of_bounds(170) {
            ""
        } else {
            crate::get_vls(self, self.parent_server_order_id)
        }
    }

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn oco_linked_order_server_order_id(&self) -> &str {
        if self.is_out_of_bounds(174) {
            ""
        } else {
            crate::get_vls(self, self.oco_linked_order_server_order_id)
        }
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum {
        if self.is_out_of_bounds(180) {
            OpenCloseTradeEnum::TradeUnset.to_le()
        } else {
            OpenCloseTradeEnum::from_le(self.open_or_close)
        }
    }

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn previous_client_order_id(&self) -> &str {
        if self.is_out_of_bounds(184) {
            ""
        } else {
            crate::get_vls(self, self.previous_client_order_id)
        }
    }

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn free_form_text(&self) -> &str {
        if self.is_out_of_bounds(188) {
            ""
        } else {
            crate::get_vls(self, self.free_form_text)
        }
    }

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn order_received_date_time(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(200) {
            0
        } else {
            i64::from_le(self.order_received_date_time)
        }
    }

    fn latest_transaction_date_time(&self) -> DateTimeWithMilliseconds {
        if self.is_out_of_bounds(208) {
            0.0f64
        } else {
            crate::f64_le(self.latest_transaction_date_time)
        }
    }

    fn username(&self) -> &str {
        if self.is_out_of_bounds(212) {
            ""
        } else {
            crate::get_vls(self, self.username)
        }
    }

    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn set_request_id(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(12) {
            self.request_id = value.to_le();
        }
        self
    }

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn set_total_num_messages(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(16) {
            self.total_num_messages = value.to_le();
        }
        self
    }

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn set_message_number(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(20) {
            self.message_number = value.to_le();
        }
        self
    }

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(24) {
            self.symbol = crate::set_vls(self, self.symbol, value);
        }
        self
    }

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(28) {
            self.exchange = crate::set_vls(self, self.exchange, value);
        }
        self
    }

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn set_previous_server_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(32) {
            self.previous_server_order_id =
                crate::set_vls(self, self.previous_server_order_id, value);
        }
        self
    }

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn set_server_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(36) {
            self.server_order_id = crate::set_vls(self, self.server_order_id, value);
        }
        self
    }

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(40) {
            self.client_order_id = crate::set_vls(self, self.client_order_id, value);
        }
        self
    }

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn set_exchange_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(44) {
            self.exchange_order_id = crate::set_vls(self, self.exchange_order_id, value);
        }
        self
    }

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn set_order_status(&mut self, value: OrderStatusEnum) -> &mut Self {
        if !self.is_out_of_bounds(48) {
            self.order_status = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn set_order_update_reason(&mut self, value: OrderUpdateReasonEnum) -> &mut Self {
        if !self.is_out_of_bounds(52) {
            self.order_update_reason = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self {
        if !self.is_out_of_bounds(56) {
            self.order_type = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self {
        if !self.is_out_of_bounds(60) {
            self.buy_sell = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(72) {
            self.price1 = f64_le(value);
        }
        self
    }

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price2(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(80) {
            self.price2 = f64_le(value);
        }
        self
    }

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self {
        if !self.is_out_of_bounds(84) {
            self.time_in_force = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self {
        if !self.is_out_of_bounds(96) {
            self.good_till_date_time = value.to_le();
        }
        self
    }

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_order_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(104) {
            self.order_quantity = f64_le(value);
        }
        self
    }

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_filled_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(112) {
            self.filled_quantity = f64_le(value);
        }
        self
    }

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_remaining_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(120) {
            self.remaining_quantity = f64_le(value);
        }
        self
    }

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_average_fill_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(128) {
            self.average_fill_price = f64_le(value);
        }
        self
    }

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(136) {
            self.last_fill_price = f64_le(value);
        }
        self
    }

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(144) {
            self.last_fill_date_time = value.to_le();
        }
        self
    }

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(152) {
            self.last_fill_quantity = f64_le(value);
        }
        self
    }

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_execution_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(156) {
            self.last_fill_execution_id = crate::set_vls(self, self.last_fill_execution_id, value);
        }
        self
    }

    /// The trade account the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(160) {
            self.trade_account = crate::set_vls(self, self.trade_account, value);
        }
        self
    }

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn set_info_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(164) {
            self.info_text = crate::set_vls(self, self.info_text, value);
        }
        self
    }

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn set_no_orders(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(165) {
            self.no_orders = value;
        }
        self
    }

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn set_parent_server_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(170) {
            self.parent_server_order_id = crate::set_vls(self, self.parent_server_order_id, value);
        }
        self
    }

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn set_oco_linked_order_server_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(174) {
            self.oco_linked_order_server_order_id =
                crate::set_vls(self, self.oco_linked_order_server_order_id, value);
        }
        self
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self {
        if !self.is_out_of_bounds(180) {
            self.open_or_close = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn set_previous_client_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(184) {
            self.previous_client_order_id =
                crate::set_vls(self, self.previous_client_order_id, value);
        }
        self
    }

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(188) {
            self.free_form_text = crate::set_vls(self, self.free_form_text, value);
        }
        self
    }

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn set_order_received_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(200) {
            self.order_received_date_time = value.to_le();
        }
        self
    }

    fn set_latest_transaction_date_time(&mut self, value: DateTimeWithMilliseconds) -> &mut Self {
        if !self.is_out_of_bounds(208) {
            self.latest_transaction_date_time = f64_le(value);
        }
        self
    }

    fn set_username(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(212) {
            self.username = crate::set_vls(self, self.username, value);
        }
        self
    }
}

/// The OrderUpdateVLS is a unified message from the Server to the Client
/// which communicates the complete details of an order, the Order Status,
/// and the reason for sending the message (OrderUpdateReason).
///
/// DTC uses this single unified message to provide an update for an order.
/// The OrderUpdateReason field provides a clear indication for each reason
/// this message is being sent.
impl OrderUpdate for OrderUpdateFixed {
    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn request_id(&self) -> i32 {
        i32::from_le(self.request_id)
    }

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn total_num_messages(&self) -> i32 {
        i32::from_le(self.total_num_messages)
    }

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn message_number(&self) -> i32 {
        i32::from_le(self.message_number)
    }

    /// The symbol for the order.
    fn symbol(&self) -> &str {
        crate::get_fixed(&self.symbol[..])
    }

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str {
        crate::get_fixed(&self.exchange[..])
    }

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn previous_server_order_id(&self) -> &str {
        crate::get_fixed(&self.previous_server_order_id[..])
    }

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn server_order_id(&self) -> &str {
        crate::get_fixed(&self.server_order_id[..])
    }

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn client_order_id(&self) -> &str {
        crate::get_fixed(&self.client_order_id[..])
    }

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn exchange_order_id(&self) -> &str {
        crate::get_fixed(&self.exchange_order_id[..])
    }

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn order_status(&self) -> OrderStatusEnum {
        OrderStatusEnum::from_le(self.order_status)
    }

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn order_update_reason(&self) -> OrderUpdateReasonEnum {
        OrderUpdateReasonEnum::from_le(self.order_update_reason)
    }

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn order_type(&self) -> OrderTypeEnum {
        OrderTypeEnum::from_le(self.order_type)
    }

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn buy_sell(&self) -> BuySellEnum {
        BuySellEnum::from_le(self.buy_sell)
    }

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price1(&self) -> f64 {
        crate::f64_le(self.price1)
    }

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price2(&self) -> f64 {
        crate::f64_le(self.price2)
    }

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn time_in_force(&self) -> TimeInForceEnum {
        TimeInForceEnum::from_le(self.time_in_force)
    }

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn good_till_date_time(&self) -> DateTime {
        i64::from_le(self.good_till_date_time)
    }

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn order_quantity(&self) -> f64 {
        crate::f64_le(self.order_quantity)
    }

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn filled_quantity(&self) -> f64 {
        crate::f64_le(self.filled_quantity)
    }

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn remaining_quantity(&self) -> f64 {
        crate::f64_le(self.remaining_quantity)
    }

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn average_fill_price(&self) -> f64 {
        crate::f64_le(self.average_fill_price)
    }

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_price(&self) -> f64 {
        crate::f64_le(self.last_fill_price)
    }

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_date_time(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.last_fill_date_time)
    }

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_quantity(&self) -> f64 {
        crate::f64_le(self.last_fill_quantity)
    }

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_execution_id(&self) -> &str {
        crate::get_fixed(&self.last_fill_execution_id[..])
    }

    /// The trade account the order belongs to.
    fn trade_account(&self) -> &str {
        crate::get_fixed(&self.trade_account[..])
    }

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn info_text(&self) -> &str {
        crate::get_fixed(&self.info_text[..])
    }

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn no_orders(&self) -> u8 {
        self.no_orders
    }

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn parent_server_order_id(&self) -> &str {
        crate::get_fixed(&self.parent_server_order_id[..])
    }

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn oco_linked_order_server_order_id(&self) -> &str {
        crate::get_fixed(&self.oco_linked_order_server_order_id[..])
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum {
        OpenCloseTradeEnum::from_le(self.open_or_close)
    }

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn previous_client_order_id(&self) -> &str {
        crate::get_fixed(&self.previous_client_order_id[..])
    }

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn free_form_text(&self) -> &str {
        crate::get_fixed(&self.free_form_text[..])
    }

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn order_received_date_time(&self) -> DateTimeWithMillisecondsInt {
        i64::from_le(self.order_received_date_time)
    }

    fn latest_transaction_date_time(&self) -> DateTimeWithMilliseconds {
        crate::f64_le(self.latest_transaction_date_time)
    }

    fn username(&self) -> &str {
        crate::get_fixed(&self.username[..])
    }

    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn set_request_id(&mut self, value: i32) -> &mut Self {
        self.request_id = value.to_le();
        self
    }

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn set_total_num_messages(&mut self, value: i32) -> &mut Self {
        self.total_num_messages = value.to_le();
        self
    }

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn set_message_number(&mut self, value: i32) -> &mut Self {
        self.message_number = value.to_le();
        self
    }

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.symbol[..], value);
        self
    }

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.exchange[..], value);
        self
    }

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn set_previous_server_order_id(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.previous_server_order_id[..], value);
        self
    }

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn set_server_order_id(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.server_order_id[..], value);
        self
    }

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.client_order_id[..], value);
        self
    }

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn set_exchange_order_id(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.exchange_order_id[..], value);
        self
    }

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn set_order_status(&mut self, value: OrderStatusEnum) -> &mut Self {
        self.order_status = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn set_order_update_reason(&mut self, value: OrderUpdateReasonEnum) -> &mut Self {
        self.order_update_reason = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self {
        self.order_type = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self {
        self.buy_sell = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price1(&mut self, value: f64) -> &mut Self {
        self.price1 = f64_le(value);
        self
    }

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price2(&mut self, value: f64) -> &mut Self {
        self.price2 = f64_le(value);
        self
    }

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self {
        self.time_in_force = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self {
        self.good_till_date_time = value.to_le();
        self
    }

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_order_quantity(&mut self, value: f64) -> &mut Self {
        self.order_quantity = f64_le(value);
        self
    }

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_filled_quantity(&mut self, value: f64) -> &mut Self {
        self.filled_quantity = f64_le(value);
        self
    }

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_remaining_quantity(&mut self, value: f64) -> &mut Self {
        self.remaining_quantity = f64_le(value);
        self
    }

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_average_fill_price(&mut self, value: f64) -> &mut Self {
        self.average_fill_price = f64_le(value);
        self
    }

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_price(&mut self, value: f64) -> &mut Self {
        self.last_fill_price = f64_le(value);
        self
    }

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        self.last_fill_date_time = value.to_le();
        self
    }

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_quantity(&mut self, value: f64) -> &mut Self {
        self.last_fill_quantity = f64_le(value);
        self
    }

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_execution_id(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.last_fill_execution_id[..], value);
        self
    }

    /// The trade account the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.trade_account[..], value);
        self
    }

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn set_info_text(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.info_text[..], value);
        self
    }

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn set_no_orders(&mut self, value: u8) -> &mut Self {
        self.no_orders = value;
        self
    }

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn set_parent_server_order_id(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.parent_server_order_id[..], value);
        self
    }

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn set_oco_linked_order_server_order_id(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.oco_linked_order_server_order_id[..], value);
        self
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self {
        self.open_or_close = unsafe { core::mem::transmute((value as i32).to_le()) };
        self
    }

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn set_previous_client_order_id(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.previous_client_order_id[..], value);
        self
    }

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.free_form_text[..], value);
        self
    }

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn set_order_received_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        self.order_received_date_time = value.to_le();
        self
    }

    fn set_latest_transaction_date_time(&mut self, value: DateTimeWithMilliseconds) -> &mut Self {
        self.latest_transaction_date_time = f64_le(value);
        self
    }

    fn set_username(&mut self, value: &str) -> &mut Self {
        crate::set_fixed(&mut self.username[..], value);
        self
    }
}

/// The OrderUpdateVLS is a unified message from the Server to the Client
/// which communicates the complete details of an order, the Order Status,
/// and the reason for sending the message (OrderUpdateReason).
///
/// DTC uses this single unified message to provide an update for an order.
/// The OrderUpdateReason field provides a clear indication for each reason
/// this message is being sent.
impl OrderUpdate for OrderUpdateFixedUnsafe {
    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn request_id(&self) -> i32 {
        if self.is_out_of_bounds(8) {
            0
        } else {
            i32::from_le(self.request_id)
        }
    }

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn total_num_messages(&self) -> i32 {
        if self.is_out_of_bounds(12) {
            0
        } else {
            i32::from_le(self.total_num_messages)
        }
    }

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn message_number(&self) -> i32 {
        if self.is_out_of_bounds(16) {
            0
        } else {
            i32::from_le(self.message_number)
        }
    }

    /// The symbol for the order.
    fn symbol(&self) -> &str {
        if self.is_out_of_bounds(80) {
            ""
        } else {
            crate::get_fixed(&self.symbol[..])
        }
    }

    /// The optional exchange for the symbol.
    fn exchange(&self) -> &str {
        if self.is_out_of_bounds(96) {
            ""
        } else {
            crate::get_fixed(&self.exchange[..])
        }
    }

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn previous_server_order_id(&self) -> &str {
        if self.is_out_of_bounds(128) {
            ""
        } else {
            crate::get_fixed(&self.previous_server_order_id[..])
        }
    }

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn server_order_id(&self) -> &str {
        if self.is_out_of_bounds(160) {
            ""
        } else {
            crate::get_fixed(&self.server_order_id[..])
        }
    }

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn client_order_id(&self) -> &str {
        if self.is_out_of_bounds(192) {
            ""
        } else {
            crate::get_fixed(&self.client_order_id[..])
        }
    }

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn exchange_order_id(&self) -> &str {
        if self.is_out_of_bounds(224) {
            ""
        } else {
            crate::get_fixed(&self.exchange_order_id[..])
        }
    }

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn order_status(&self) -> OrderStatusEnum {
        if self.is_out_of_bounds(228) {
            OrderStatusEnum::OrderStatusUnspecified.to_le()
        } else {
            OrderStatusEnum::from_le(self.order_status)
        }
    }

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn order_update_reason(&self) -> OrderUpdateReasonEnum {
        if self.is_out_of_bounds(232) {
            OrderUpdateReasonEnum::OrderUpdateReasonUnset.to_le()
        } else {
            OrderUpdateReasonEnum::from_le(self.order_update_reason)
        }
    }

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn order_type(&self) -> OrderTypeEnum {
        if self.is_out_of_bounds(236) {
            OrderTypeEnum::OrderTypeUnset.to_le()
        } else {
            OrderTypeEnum::from_le(self.order_type)
        }
    }

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn buy_sell(&self) -> BuySellEnum {
        if self.is_out_of_bounds(240) {
            BuySellEnum::BuySellUnset.to_le()
        } else {
            BuySellEnum::from_le(self.buy_sell)
        }
    }

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price1(&self) -> f64 {
        if self.is_out_of_bounds(248) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.price1)
        }
    }

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn price2(&self) -> f64 {
        if self.is_out_of_bounds(256) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.price2)
        }
    }

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn time_in_force(&self) -> TimeInForceEnum {
        if self.is_out_of_bounds(260) {
            TimeInForceEnum::TifUnset.to_le()
        } else {
            TimeInForceEnum::from_le(self.time_in_force)
        }
    }

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn good_till_date_time(&self) -> DateTime {
        if self.is_out_of_bounds(272) {
            0
        } else {
            i64::from_le(self.good_till_date_time)
        }
    }

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn order_quantity(&self) -> f64 {
        if self.is_out_of_bounds(280) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.order_quantity)
        }
    }

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn filled_quantity(&self) -> f64 {
        if self.is_out_of_bounds(288) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.filled_quantity)
        }
    }

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn remaining_quantity(&self) -> f64 {
        if self.is_out_of_bounds(296) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.remaining_quantity)
        }
    }

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn average_fill_price(&self) -> f64 {
        if self.is_out_of_bounds(304) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.average_fill_price)
        }
    }

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_price(&self) -> f64 {
        if self.is_out_of_bounds(312) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.last_fill_price)
        }
    }

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_date_time(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(320) {
            0
        } else {
            i64::from_le(self.last_fill_date_time)
        }
    }

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn last_fill_quantity(&self) -> f64 {
        if self.is_out_of_bounds(328) {
            f64_le(f64::MAX)
        } else {
            crate::f64_le(self.last_fill_quantity)
        }
    }

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn last_fill_execution_id(&self) -> &str {
        if self.is_out_of_bounds(392) {
            ""
        } else {
            crate::get_fixed(&self.last_fill_execution_id[..])
        }
    }

    /// The trade account the order belongs to.
    fn trade_account(&self) -> &str {
        if self.is_out_of_bounds(424) {
            ""
        } else {
            crate::get_fixed(&self.trade_account[..])
        }
    }

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn info_text(&self) -> &str {
        if self.is_out_of_bounds(520) {
            ""
        } else {
            crate::get_fixed(&self.info_text[..])
        }
    }

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn no_orders(&self) -> u8 {
        if self.is_out_of_bounds(521) {
            0
        } else {
            self.no_orders
        }
    }

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn parent_server_order_id(&self) -> &str {
        if self.is_out_of_bounds(553) {
            ""
        } else {
            crate::get_fixed(&self.parent_server_order_id[..])
        }
    }

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn oco_linked_order_server_order_id(&self) -> &str {
        if self.is_out_of_bounds(585) {
            ""
        } else {
            crate::get_fixed(&self.oco_linked_order_server_order_id[..])
        }
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn open_or_close(&self) -> OpenCloseTradeEnum {
        if self.is_out_of_bounds(592) {
            OpenCloseTradeEnum::TradeUnset.to_le()
        } else {
            OpenCloseTradeEnum::from_le(self.open_or_close)
        }
    }

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn previous_client_order_id(&self) -> &str {
        if self.is_out_of_bounds(624) {
            ""
        } else {
            crate::get_fixed(&self.previous_client_order_id[..])
        }
    }

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn free_form_text(&self) -> &str {
        if self.is_out_of_bounds(672) {
            ""
        } else {
            crate::get_fixed(&self.free_form_text[..])
        }
    }

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn order_received_date_time(&self) -> DateTimeWithMillisecondsInt {
        if self.is_out_of_bounds(680) {
            0
        } else {
            i64::from_le(self.order_received_date_time)
        }
    }

    fn latest_transaction_date_time(&self) -> DateTimeWithMilliseconds {
        if self.is_out_of_bounds(688) {
            0.0f64
        } else {
            crate::f64_le(self.latest_transaction_date_time)
        }
    }

    fn username(&self) -> &str {
        if self.is_out_of_bounds(720) {
            ""
        } else {
            crate::get_fixed(&self.username[..])
        }
    }

    /// Set to 0 unless this is in response to an OpenOrdersRequestVLS, in which
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    /// case this must be set to the RequestID given in the OpenOrdersRequestVLS.
    ///
    /// If this OrderUpdateVLS is unsolicited, for example a real-time fill or
    /// other unsolicited order event, the Server must leave this at 0.
    fn set_request_id(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(8) {
            self.request_id = value.to_le();
        }
        self
    }

    /// This indicates the total number of OrderUpdateVLS messages when a batch
    /// of reports is being sent in response to an OpenOrdersRequestVLS. If there
    /// is only one order being sent, this will be 1. The Server must use a value
    /// of 1 for an unsolicited report. A Client should not rely on this field
    /// for an unsolicited report.
    fn set_total_num_messages(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(12) {
            self.total_num_messages = value.to_le();
        }
        self
    }

    /// This indicates the 1-based index of the OrderUpdateVLS message when a
    /// batch of reports is being sent in response to an OpenOrdersRequestVLS.
    /// If there is only one order being sent, this will be 1. Use a value of
    /// 1 for an unsolicited report. A Client should not rely on this field for
    /// an unsolicited report.
    fn set_message_number(&mut self, value: i32) -> &mut Self {
        if !self.is_out_of_bounds(16) {
            self.message_number = value.to_le();
        }
        self
    }

    /// The symbol for the order.
    fn set_symbol(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(80) {
            crate::set_fixed(&mut self.symbol[..], value);
        }
        self
    }

    /// The optional exchange for the symbol.
    fn set_exchange(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(96) {
            crate::set_fixed(&mut self.exchange[..], value);
        }
        self
    }

    /// Used upon a Cancel and Replace operation (ORDER_CANCEL_REPLACE_COMPLETE)
    /// where a new Server Order identifier is given.
    ///
    /// In this case this field needs to be set to the previous Server Order identifier.
    /// In this case this field needs to be set to the previous Server Order identifier.
    ///
    /// This should be left at the default setting of empty in the case where
    /// the Server does not change the Server Order identifier upon a Cancel and
    /// Replace operation.
    fn set_previous_server_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(128) {
            crate::set_fixed(&mut self.previous_server_order_id[..], value);
        }
        self
    }

    /// The ServerOrderID is set by the server and uniquely identifies the order.
    /// When a new order is submitted by the Client and the Server responds with
    /// an OrderUpdateVLS, this field needs to be set to the order identifier
    /// which is good for the life of the order.
    ///
    /// This ServerOrderID can optionally change on a Cancel and Replace operation.
    /// In this case, the PreviousServerOrderID field will contain the previous
    /// ServerOrderID upon a ORDER_CANCEL_REPLACE_COMPLETE OrderUpdateReason.
    ///
    /// ServerOrderID must always be set except it is not required in the cases
    /// when the OrderUpdateReason is one of the following: NEW_ORDER_REJECTED,
    /// ORDER_CANCEL_REJECTED, ORDER_CANCEL_REPLACE_REJECTED. If it is not set,
    /// then the ClientOrderID must be set.
    fn set_server_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(160) {
            crate::set_fixed(&mut self.server_order_id[..], value);
        }
        self
    }

    /// The ClientOrderID is the order identifier provided by the Client. When
    /// the Client submits a new order, cancels and replaces an existing order,
    /// or cancels an order, then the Client needs to specify this identifier.
    ///
    /// The Client must maintain the same order identifier throughout the life
    /// of the order.
    ///
    /// The Server should persist the ClientOrderID across sessions. A session
    /// is defined as the period of time from the start of the network connection
    /// between the Client and Server to the end of that connection.
    ///
    /// The Client should only rely upon the ClientOrderID being set when the
    /// OrderUpdateReason is one of the following: NEW_ORDER_ACCEPTED, NEW_ORDER_REJECTED,
    /// ORDER_CANCELED, ORDER_CANCEL_REPLACE_COMPLETE, ORDER_CANCEL_REJECTED,
    /// ORDER_CANCEL_REPLACE_REJECTED.
    ///
    /// After a new order has been accepted, the Client will rely upon the given
    /// ServerOrderID from the server to identify the order and should no longer
    /// rely upon the given ClientOrderID. However, the Client needs to maintain
    /// a copy of the ClientOrderID for any subsequent order modifications and
    /// cancellations because this is a required field for those.
    fn set_client_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(192) {
            crate::set_fixed(&mut self.client_order_id[..], value);
        }
        self
    }

    /// The order identifier from the exchange that handles the order. This is
    /// optional.
    fn set_exchange_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(224) {
            crate::set_fixed(&mut self.exchange_order_id[..], value);
        }
        self
    }

    /// This is required. Needs to be set to one of the following values by the
    /// Server to indicate the current status of the order, unless NoneOrder =
    /// 1:
    ///
    /// ORDER_STATUS_UNSPECIFIED (0): The status of the order is unset. Use this
    /// when NoneOrder = 1, or when the Server does not know the true status of
    /// an order when the Order Update Report message is sent.
    /// ORDER_STATUS_ORDER_SENT (1): When a Client sends an order to the Server,
    /// then the Client internally will set the status to ORDER_STATUS_ORDER_SENT.
    /// The Server will not set this Status.
    /// ORDER_STATUS_PENDING_OPEN (2): This means the Server has accepted the
    /// order but it is not yet considered in a fully working state for any reason.
    /// order but it is not yet considered in a fully working state for any reason.
    /// ORDER_STATUS_PENDING_CHILD (3): This status applies to a Limit or Stop
    /// order attached to a parent order. It will have this status if the parent
    /// order has not yet filled.
    /// ORDER_STATUS_OPEN (4): Order is open and working.
    /// ORDER_STATUS_PENDING_CANCEL_REPLACE (5): Order is pending a Cancel and
    /// Replace operation. The Server should send a OrderUpdateVLS message with
    /// the OrderUpdateReason set to GENERAL_OrderUpdateVLS and the OrderStatus
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// set to this status to indicate the pending Cancel and Replace operation.
    /// ORDER_STATUS_PENDING_CANCEL (6): Order is pending a Cancel operation.
    /// The Server should send a OrderUpdateVLS message with the OrderUpdateReason
    /// set to GENERAL_OrderUpdateVLS and the OrderStatus set to this status to
    /// indicate the pending Cancel operation.
    /// ORDER_STATUS_FILLED (7): Order is filled and no longer working.
    /// ORDER_STATUS_CANCELED (8): Order is canceled. If the user tries to cancel
    /// an order that has already been canceled, then continue to return this
    /// Order Status for it.
    /// ORDER_STATUS_REJECTED (9): Order has been rejected after the initial order
    /// submission. It is not working.
    /// ORDER_STATUS_PARTIALLY_FILLED (10): Order is partially filled and still
    /// working.
    fn set_order_status(&mut self, value: OrderStatusEnum) -> &mut Self {
        if !self.is_out_of_bounds(228) {
            self.order_status = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// This is required. This field needs to be set to one of the following values
    /// by the Server to indicate the reason the OrderUpdateVLS is being sent.
    ///
    /// OpenOrdersRequestVLS_RESPONSE (1): When the OrderUpdateVLS is specifically
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// sent in response to an OpenOrdersRequestVLS request, this is the OrderUpdateReason.
    /// NEW_ORDER_ACCEPTED (2): This OrderUpdate indicates a new order has been
    /// accepted.
    /// GENERAL_OrderUpdateVLS (3): A general order update. For example, when
    /// an order is in the process of being canceled, the Server may send an OrderUpdateVLS
    /// message with the OrderStatus set to ORDER_STATUS_PENDING_CANCEL. In this
    /// particular case the OrderUpdateReason needs to be set to GENERAL_OrderUpdateVLS
    /// (3).
    /// ORDER_FILLED (4): Upon a complete fill of the order, this is the OrderUpdateReason.
    /// This OrderUpdateReason must only be used when an OrderUpdateVLS is sent
    /// at the moment in time of a fill. A previously filled order that is being
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// restated in response to an OpenOrdersRequestVLS must not use this OrderUpdateReason.
    /// ORDER_FILLED_PARTIALLY (5): Upon a partial fill of the order, this is
    /// the OrderUpdateReason. This OrderUpdateReason must only be used when an
    /// OrderUpdateVLS is sent at the moment in time of a fill. A previously filled
    /// order that is being restated in response to an OpenOrdersRequestVLS must
    /// not use this OrderUpdateReason.
    /// ORDER_CANCELED (6): This OrderUpdateReason indicates the order is now
    /// successfully canceled.
    /// ORDER_CANCEL_REPLACE_COMPLETE (7): This OrderUpdateReason indicates the
    /// order is now successfully canceled and replaced (modified).
    /// NEW_ORDER_REJECTED (8): After an order has been submitted by the Client,
    /// it has been rejected for any reason and was never working, the Server
    /// will send through an OrderUpdateVLS with this OrderUpdateReason. In this
    /// case the Server needs to set the OrderStatus in the OrderUpdateVLS to
    /// ORDER_STATUS_REJECTED.
    ///
    /// The following fields need to be set for a NEW_ORDER_REJECTED OrderUpdateReason:
    /// OrderUpdateReason, OrderStatus, MessageNumber, TotalNumMessages, ClientOrderID,
    /// Symbol, Exchange, TradeAccount.
    /// ORDER_CANCEL_REJECTED (9): A request by the Client to cancel the order
    /// with the CancelOrderVLS message has been rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelOrderVLS message. The ClientOrderID must always be set in
    /// this case in an OrderUpdateVLS.
    ///
    /// In the case where the order has already been canceled for the given ServerOrderID
    /// in a CancelOrderVLS message, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REJECTED and set the OrderStatus
    /// to ORDER_STATUS_CANCELED.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// that was attempted to be canceled, then set the OrderStatus to ORDER_STATUS_UNSPECIFIED.
    /// ORDER_CANCEL_REPLACE_REJECTED (10): A request by the Client to cancel
    /// and replace the order with the CancelReplaceOrderVLS message has been
    /// rejected.
    ///
    /// The current status of the order must be set in the OrderStatus member
    /// of the OrderUpdateVLS message.
    ///
    /// In the case where the given ServerOrderID in a CancelReplaceOrderVLS message
    /// from the Client is not known, then respond with an OrderUpdateVLS message
    /// and set the OrderUpdateReason to ORDER_CANCEL_REPLACE_REJECTED and set
    /// the OrderStatus to ORDER_STATUS_REJECTED.
    ///
    /// In the case where the ServerOrderID is not known, then in the OrderUpdateVLS
    /// message, it should not be set. However, in this case it is necessary to
    /// set the ClientOrderID in the OrderUpdateVLS message to the given ClientOrderID
    /// in the CancelReplaceOrderVLS message. The ClientOrderID must always be
    /// set in this case in an OrderUpdateVLS.
    ///
    /// If for some reason the Server is uncertain as to the status of the order
    /// that was attempted to be canceled and replaced, then set the OrderStatus
    /// to ORDER_STATUS_UNSPECIFIED.
    fn set_order_update_reason(&mut self, value: OrderUpdateReasonEnum) -> &mut Self {
        if !self.is_out_of_bounds(232) {
            self.order_update_reason = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// The order type. Can be set to one of the following.
    ///
    /// ORDER_TYPE_MARKET
    /// ORDER_TYPE_LIMIT
    /// ORDER_TYPE_STOP
    /// ORDER_TYPE_STOP_LIMIT
    /// ORDER_TYPE_MARKET_IF_TOUCHED
    fn set_order_type(&mut self, value: OrderTypeEnum) -> &mut Self {
        if !self.is_out_of_bounds(236) {
            self.order_type = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// Indicates whether the order is a Buy or Sell order. Can be set to one
    /// of the following constants: DTC::BUY (1) or DTC::SELL (2).
    fn set_buy_sell(&mut self, value: BuySellEnum) -> &mut Self {
        if !self.is_out_of_bounds(240) {
            self.buy_sell = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// For orders that require a price, this is the order price.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price1(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(248) {
            self.price1 = f64_le(value);
        }
        self
    }

    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    /// For Stop-Limit orders this is the Limit price. Otherwise, this is unset.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_price2(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(256) {
            self.price2 = f64_le(value);
        }
        self
    }

    /// The Time in Force of the order. Can be any of the following:
    ///
    /// TIF_DAY
    /// TIF_GOOD_TILL_CANCELED
    /// TIF_GOOD_TILL_DATE_TIME
    /// TIF_IMMEDIATE_OR_CANCEL
    /// TIF_ALL_OR_NONE
    /// TIF_FILL_OR_KILL
    fn set_time_in_force(&mut self, value: TimeInForceEnum) -> &mut Self {
        if !self.is_out_of_bounds(260) {
            self.time_in_force = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// The expiration Date and Time of the order in the case when TimeInForce
    /// is TIF_GOOD_TILL_DATE_TIME.
    fn set_good_till_date_time(&mut self, value: DateTime) -> &mut Self {
        if !self.is_out_of_bounds(272) {
            self.good_till_date_time = value.to_le();
        }
        self
    }

    /// The quantity of the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_order_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(280) {
            self.order_quantity = f64_le(value);
        }
        self
    }

    /// The number of shares or contracts that have filled in the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_filled_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(288) {
            self.filled_quantity = f64_le(value);
        }
        self
    }

    /// The number of shares or contracts that still remain to be filled.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_remaining_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(296) {
            self.remaining_quantity = f64_le(value);
        }
        self
    }

    /// The average price of all of the fills for the order.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_average_fill_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(304) {
            self.average_fill_price = f64_le(value);
        }
        self
    }

    /// The price of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_price(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(312) {
            self.last_fill_price = f64_le(value);
        }
        self
    }

    /// The date and Time of the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(320) {
            self.last_fill_date_time = value.to_le();
        }
        self
    }

    /// The number of contracts/shares that has filled for the specific order
    /// fill that is currently reported through the OrderUpdateVLS message.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    ///
    /// For binary encoding, if this field is not set it needs to be set to DBL_MAX.
    /// Refer to Unset Message Fields.
    fn set_last_fill_quantity(&mut self, value: f64) -> &mut Self {
        if !self.is_out_of_bounds(328) {
            self.last_fill_quantity = f64_le(value);
        }
        self
    }

    /// The unique identifier for the most recent fill.
    ///
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    /// Only necessary to set if OrderUpdateReason is ORDER_FILLED or ORDER_FILLED_PARTIALLY.
    fn set_last_fill_execution_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(392) {
            crate::set_fixed(&mut self.last_fill_execution_id[..], value);
        }
        self
    }

    /// The trade account the order belongs to.
    fn set_trade_account(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(424) {
            crate::set_fixed(&mut self.trade_account[..], value);
        }
        self
    }

    /// Free-form text with information to communicate about the order. When an
    /// order is rejected, this should be set by the Server to indicate the reason
    /// for the rejection.
    fn set_info_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(520) {
            crate::set_fixed(&mut self.info_text[..], value);
        }
        self
    }

    /// Set by the Server to 1 to indicate there are no orders when OpenOrdersRequestVLS
    /// message has been received and is being responded to. Otherwise, leave
    /// at the default of 0.
    fn set_no_orders(&mut self, value: u8) -> &mut Self {
        if !self.is_out_of_bounds(521) {
            self.no_orders = value;
        }
        self
    }

    /// This is the ServerOrderID of the parent order when the order that this
    /// Order Update Report is for, is a child order in a bracket order. Otherwise,
    /// this is an empty text string.
    fn set_parent_server_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(553) {
            crate::set_fixed(&mut self.parent_server_order_id[..], value);
        }
        self
    }

    /// In the case of an OCO order set submitted with SubmitNewOCOOrderVLS, whether
    /// it has a Parent order or not, this is the ServerOrderID of the other order
    /// in the OCO pair. These two orders are considered "linked" together. Otherwise,
    /// this is an empty text string.
    fn set_oco_linked_order_server_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(585) {
            crate::set_fixed(&mut self.oco_linked_order_server_order_id[..], value);
        }
        self
    }

    /// For the description for this field, refer to OpenCloseTradeEnum.
    fn set_open_or_close(&mut self, value: OpenCloseTradeEnum) -> &mut Self {
        if !self.is_out_of_bounds(592) {
            self.open_or_close = unsafe { core::mem::transmute((value as i32).to_le()) };
        }
        self
    }

    /// The PreviousClientOrderID is the previous ClientOrderID provided by the
    /// Client for the order, if the Client changed it during order cancel and
    /// replace request or an order cancel request.
    ///
    /// A Server only is obligated to provide this field immediately after the
    /// ClientOrderID has been changed. Subsequent OrderUpdateVLS messages do
    /// not need to set this field.
    fn set_previous_client_order_id(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(624) {
            crate::set_fixed(&mut self.previous_client_order_id[..], value);
        }
        self
    }

    /// This is the optional free-form text that was originally set with a new
    /// order using the new order messages.
    fn set_free_form_text(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(672) {
            crate::set_fixed(&mut self.free_form_text[..], value);
        }
        self
    }

    /// This is the Date-Time when the original order was received by the Server.
    /// Order modifications normally will not cause this Date-Time to be updated.
    /// Order modifications normally will not cause this Date-Time to be updated.
    fn set_order_received_date_time(&mut self, value: DateTimeWithMillisecondsInt) -> &mut Self {
        if !self.is_out_of_bounds(680) {
            self.order_received_date_time = value.to_le();
        }
        self
    }

    fn set_latest_transaction_date_time(&mut self, value: DateTimeWithMilliseconds) -> &mut Self {
        if !self.is_out_of_bounds(688) {
            self.latest_transaction_date_time = f64_le(value);
        }
        self
    }

    fn set_username(&mut self, value: &str) -> &mut Self {
        if !self.is_out_of_bounds(720) {
            crate::set_fixed(&mut self.username[..], value);
        }
        self
    }
}
